--- jupyterlab\handlers\announcements.py (old)
+++ jupyterlab\handlers\announcements.py (new)
@@ -6,9 +6,9 @@
 import abc
 import hashlib
 import json
-import xml.etree.ElementTree as ET  # noqa
+import xml.etree.ElementTree as ET
 from dataclasses import asdict, dataclass, field
-from datetime import datetime, timezone
+from datetime import datetime
 from typing import Awaitable, Optional, Tuple, Union
 
 from jupyter_server.base.handlers import APIHandler
@@ -16,7 +16,7 @@
 from packaging.version import parse
 from tornado import httpclient, web
 
-from jupyterlab._version import __version__
+from .._version import __version__
 
 ISO8601_FORMAT = "%Y-%m-%dT%H:%M:%S%z"
 JUPYTERLAB_LAST_RELEASE_URL = "https://pypi.org/pypi/jupyterlab/json"
@@ -40,9 +40,9 @@
         options: Notification options
     """
 
-    createdAt: float  # noqa
+    createdAt: float
     message: str
-    modifiedAt: float  # noqa
+    modifiedAt: float
     type: str = "default"
     link: Tuple[str, str] = field(default_factory=tuple)
     options: dict = field(default_factory=dict)
@@ -71,8 +71,7 @@
             or the notification message
             or the notification message and a tuple(label, URL link) for the user to get more information
         """
-        msg = "CheckForUpdateABC.__call__ is not implemented"
-        raise NotImplementedError(msg)
+        raise NotImplementedError("CheckForUpdateABC.__call__ is not implemented")
 
 
 class CheckForUpdate(CheckForUpdateABC):
@@ -170,15 +169,15 @@
         out = await self.update_checker()
         if out:
             message, link = (out, ()) if isinstance(out, str) else out
-            now = datetime.now(tz=timezone.utc).timestamp() * 1000.0
-            hash_ = hashlib.sha1(message.encode()).hexdigest()  # noqa: S324
+            now = datetime.now().timestamp() * 1000.0
+            hash = hashlib.sha1(message.encode()).hexdigest()
             notification = Notification(
                 message=message,
                 createdAt=now,
                 modifiedAt=now,
                 type="info",
                 link=link,
-                options={"data": {"id": hash_, "tags": ["update"]}},
+                options={"data": {"id": hash, "tags": ["update"]}},
             )
 
         self.set_status(200)
@@ -227,7 +226,7 @@
                     self.news_url,
                     headers={"Content-Type": "application/atom+xml"},
                 )
-                tree = ET.fromstring(response.body)  # noqa S314
+                tree = ET.fromstring(response.body)
 
                 def build_entry(node):
                     def get_xml_text(attr: str, default: Optional[str] = None) -> str:
@@ -238,7 +237,7 @@
                             return default
                         else:
                             error_m = (
-                                f"atom feed entry does not contain a required attribute: {attr}"
+                                f'atom feed entry does not contain a required attribute: {attr}'
                             )
                             raise KeyError(error_m)
 
@@ -246,10 +245,10 @@
                     entry_id = get_xml_text("id")
                     entry_updated = get_xml_text("updated")
                     entry_published = get_xml_text("published", entry_updated)
-                    entry_summary = get_xml_text("summary", default="")
+                    entry_summary = get_xml_text("summary", default='')
                     links = node.findall("atom:link", xml_namespaces)
                     if len(links) > 1:
-                        alternate = list(filter(lambda elem: elem.get("rel") == "alternate", links))
+                        alternate = list(filter(lambda elem: elem.get('rel') == 'alternate', links))
                         link_node = alternate[0] if alternate else links[0]
                     else:
                         link_node = links[0] if len(links) == 1 else None