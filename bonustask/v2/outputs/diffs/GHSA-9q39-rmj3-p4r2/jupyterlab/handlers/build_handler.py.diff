--- jupyterlab\handlers\build_handler.py (old)
+++ jupyterlab\handlers\build_handler.py (new)
@@ -11,10 +11,11 @@
 from tornado import gen, web
 from tornado.concurrent import run_on_executor
 
-from jupyterlab.commands import AppOptions, _ensure_options, build, build_check, clean
+from ..commands import AppOptions, _ensure_options, build, build_check, clean
+from ..coreconfig import CoreConfig
 
 
-class Builder:
+class Builder(object):
     building = False
     executor = ThreadPoolExecutor(max_workers=5)
     canceled = False
@@ -33,9 +34,9 @@
     @gen.coroutine
     def get_status(self):
         if self.core_mode:
-            raise gen.Return({"status": "stable", "message": ""})
+            raise gen.Return(dict(status="stable", message=""))
         if self.building:
-            raise gen.Return({"status": "building", "message": ""})
+            raise gen.Return(dict(status="building", message=""))
 
         try:
             messages = yield self._run_build_check(
@@ -43,22 +44,21 @@
             )
             status = "needed" if messages else "stable"
             if messages:
-                self.log.warning("Build recommended")
-                [self.log.warning(m) for m in messages]
+                self.log.warn("Build recommended")
+                [self.log.warn(m) for m in messages]
             else:
                 self.log.info("Build is up to date")
-        except ValueError:
-            self.log.warning("Could not determine jupyterlab build status without nodejs")
+        except ValueError as e:
+            self.log.warn("Could not determine jupyterlab build status without nodejs")
             status = "stable"
             messages = []
 
-        raise gen.Return({"status": status, "message": "\n".join(messages)})
+        raise gen.Return(dict(status=status, message="\n".join(messages)))
 
     @gen.coroutine
     def build(self):
         if self._canceling:
-            msg = "Cancel in progress"
-            raise ValueError(msg)
+            raise ValueError("Cancel in progress")
         if not self.building:
             self.canceled = False
             self._future = future = gen.Future()
@@ -84,8 +84,7 @@
     @gen.coroutine
     def cancel(self):
         if not self.building:
-            msg = "No current build"
-            raise ValueError(msg)
+            raise ValueError("No current build")
         self._canceling = True
         yield self._future
         self._canceling = False
@@ -113,17 +112,17 @@
         )
         try:
             return build(app_options=app_options)
-        except Exception:
+        except Exception as e:
             if self._kill_event.is_set():
                 return
-            self.log.warning("Build failed, running a clean and rebuild")
+            self.log.warn("Build failed, running a clean and rebuild")
             clean(app_options=app_options)
             return build(app_options=app_options)
 
 
 class BuildHandler(ExtensionHandlerMixin, APIHandler):
     def initialize(self, builder=None, name=None):
-        super().initialize(name=name)
+        super(BuildHandler, self).initialize(name=name)
         self.builder = builder
 
     @web.authenticated
@@ -139,7 +138,7 @@
         try:
             yield self.builder.cancel()
         except Exception as e:
-            raise web.HTTPError(500, str(e)) from None
+            raise web.HTTPError(500, str(e))
         self.set_status(204)
 
     @web.authenticated
@@ -149,7 +148,7 @@
         try:
             yield self.builder.build()
         except Exception as e:
-            raise web.HTTPError(500, str(e)) from None
+            raise web.HTTPError(500, str(e))
 
         if self.builder.canceled:
             raise web.HTTPError(400, "Build canceled")