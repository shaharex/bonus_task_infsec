--- packages\docregistry\src\context.ts (old)
+++ packages\docregistry\src\context.ts (new)
@@ -1,15 +1,22 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
+import { DocumentChange, ISharedDocument } from '@jupyterlab/shared-models';
 import {
   Dialog,
   ISessionContext,
   SessionContext,
-  SessionContextDialogs,
+  sessionContextDialogs,
   showDialog,
   showErrorMessage
 } from '@jupyterlab/apputils';
-import { PathExt } from '@jupyterlab/coreutils';
+import { PageConfig, PathExt } from '@jupyterlab/coreutils';
+import {
+  IDocumentProvider,
+  IDocumentProviderFactory,
+  ProviderMock
+} from '@jupyterlab/docprovider';
+import { IModelDB, ModelDB } from '@jupyterlab/observables';
 import { RenderMimeRegistry } from '@jupyterlab/rendermime';
 import { IRenderMime } from '@jupyterlab/rendermime-interfaces';
 import {
@@ -22,12 +29,10 @@
   nullTranslator,
   TranslationBundle
 } from '@jupyterlab/translation';
-
 import { PartialJSONValue, PromiseDelegate } from '@lumino/coreutils';
 import { DisposableDelegate, IDisposable } from '@lumino/disposable';
 import { ISignal, Signal } from '@lumino/signaling';
 import { Widget } from '@lumino/widgets';
-
 import { DocumentRegistry } from './registry';
 
 /**
@@ -37,8 +42,7 @@
  */
 export class Context<
   T extends DocumentRegistry.IModel = DocumentRegistry.IModel
-> implements DocumentRegistry.IContext<T>
-{
+> implements DocumentRegistry.IContext<T> {
   /**
    * Construct a new document context.
    */
@@ -47,30 +51,42 @@
     this.translator = options.translator || nullTranslator;
     this._trans = this.translator.load('jupyterlab');
     this._factory = options.factory;
-    this._dialogs =
-      options.sessionDialogs ??
-      new SessionContextDialogs({ translator: options.translator });
+    this._dialogs = options.sessionDialogs || sessionContextDialogs;
     this._opener = options.opener || Private.noOp;
     this._path = this._manager.contents.normalize(options.path);
     this._lastModifiedCheckMargin = options.lastModifiedCheckMargin || 500;
     const localPath = this._manager.contents.localPath(this._path);
     const lang = this._factory.preferredLanguage(PathExt.basename(localPath));
 
-    const sharedFactory = this._manager.contents.getSharedModelFactory(
-      this._path
-    );
-    const sharedModel = sharedFactory?.createNew({
-      path: localPath,
-      format: this._factory.fileFormat,
-      contentType: this._factory.contentType,
-      collaborative: this._factory.collaborative
-    });
-
-    this._model = this._factory.createNew({
-      languagePreference: lang,
-      sharedModel,
-      collaborationEnabled: sharedFactory?.collaborative ?? false
-    });
+    const dbFactory = options.modelDBFactory;
+    if (dbFactory) {
+      const localPath = manager.contents.localPath(this._path);
+      this._modelDB = dbFactory.createNew(localPath);
+      this._model = this._factory.createNew(
+        lang,
+        this._modelDB,
+        false,
+        PageConfig.getOption('collaborative') === 'true'
+      );
+    } else {
+      this._model = this._factory.createNew(
+        lang,
+        undefined,
+        false,
+        PageConfig.getOption('collaborative') === 'true'
+      );
+    }
+
+    const docProviderFactory = options.docProviderFactory;
+    this._provider = docProviderFactory
+      ? docProviderFactory({
+          path: this._path,
+          contentType: this._factory.contentType,
+          format: this._factory.fileFormat!,
+          model: this._model.sharedModel,
+          collaborative: this._model.collaborative
+        })
+      : new ProviderMock();
 
     this._readyPromise = manager.ready.then(() => {
       return this._populatedPromise.promise;
@@ -80,7 +96,7 @@
     this.sessionContext = new SessionContext({
       sessionManager: manager.sessions,
       specsManager: manager.kernelspecs,
-      path: localPath,
+      path: this._path,
       type: ext === '.ipynb' ? 'notebook' : 'file',
       name: PathExt.basename(localPath),
       kernelPreference: options.kernelPreference || { shouldStart: false },
@@ -93,6 +109,7 @@
       path: this._path,
       contents: manager.contents
     });
+    this.model.sharedModel.changed.connect(this.onStateChanged, this);
   }
 
   /**
@@ -105,7 +122,7 @@
   /**
    * A signal emitted when the model is saved or reverted.
    */
-  get fileChanged(): ISignal<this, Omit<Contents.IModel, 'content'>> {
+  get fileChanged(): ISignal<this, Contents.IModel> {
     return this._fileChanged;
   }
 
@@ -163,14 +180,14 @@
   }
 
   /**
-   * The document metadata, stored as a services contents model.
+   * The current contents model associated with the document.
    *
    * #### Notes
-   * The contents model will be `null` until the context is populated.
-   * It will not have a `content` field.
-   */
-  get contentsModel(): Omit<Contents.IModel, 'content'> | null {
-    return this._contentsModel ? { ...this._contentsModel } : null;
+   * The contents model will be null until the context is populated.
+   * It will have an  empty `contents` field.
+   */
+  get contentsModel(): Contents.IModel | null {
+    return this._contentsModel;
   }
 
   /**
@@ -199,9 +216,11 @@
     }
     this._isDisposed = true;
     this.sessionContext.dispose();
+    if (this._modelDB) {
+      this._modelDB.dispose();
+    }
     this._model.dispose();
-    // Ensure we dispose the `sharedModel` as it may have been generated in the context
-    // through the shared model factory.
+    this._provider.dispose();
     this._model.sharedModel.dispose();
     this._disposed.emit(void 0);
     Signal.clearData(this);
@@ -241,10 +260,15 @@
    * @returns a promise that resolves upon initialization.
    */
   async initialize(isNew: boolean) {
-    if (isNew) {
-      await this._save();
+    if (this._model.collaborative) {
+      await this._loadContext();
     } else {
-      await this._revert();
+      if (isNew) {
+        await this._save();
+      } else {
+        await this._revert();
+      }
+      this._model.initialize();
     }
     this.model.sharedModel.clearUndoHistory();
   }
@@ -306,6 +330,8 @@
 
   /**
    * Download a file.
+   *
+   * @param path - The path of the file to be downloaded.
    *
    * @returns A promise which resolves when the file has begun
    *   downloading.
@@ -405,6 +431,38 @@
     });
   }
 
+  protected onStateChanged(sender: ISharedDocument, changes: DocumentChange) {
+    if (changes.stateChange) {
+      changes.stateChange.forEach(change => {
+        if (change.name === 'path') {
+          const driveName = this._manager.contents.driveName(this._path);
+          let newPath = change.newValue;
+          if (driveName) {
+            newPath = `${driveName}:${change.newValue}`;
+          }
+
+          if (this._path !== newPath) {
+            this._path = newPath;
+            const localPath = this._manager.contents.localPath(newPath);
+            const name = PathExt.basename(localPath);
+            this.sessionContext.session?.setPath(newPath) as any;
+            void this.sessionContext.session?.setName(name);
+            (this.urlResolver as RenderMimeRegistry.UrlResolver).path = newPath;
+            if (this._contentsModel) {
+              const contentsModel = {
+                ...this._contentsModel,
+                name: name,
+                path: newPath
+              };
+              this._updateContentsModel(contentsModel);
+            }
+            this._pathChanged.emit(newPath);
+          }
+        }
+      });
+    }
+  }
+
   /**
    * Handle a change on the contents manager.
    */
@@ -433,11 +491,19 @@
           path: newPath
         };
       }
-      this._updateContentsModel({
+      this._path = newPath;
+      const updateModel = {
         ...this._contentsModel,
         ...changeModel
-      } as Contents.IModel);
-      this._updatePath(newPath);
+      };
+
+      const localPath = this._manager.contents.localPath(newPath);
+      void this.sessionContext.session?.setPath(newPath);
+      void this.sessionContext.session?.setName(PathExt.basename(localPath));
+      (this.urlResolver as RenderMimeRegistry.UrlResolver).path = newPath;
+      this._updateContentsModel(updateModel as Contents.IModel);
+      this._model.sharedModel.setState('path', localPath);
+      this._pathChanged.emit(newPath);
     }
   }
 
@@ -448,87 +514,55 @@
     if (type !== 'path') {
       return;
     }
-
-    // The session uses local paths.
-    // We need to convert it to a global path.
-    const driveName = this._manager.contents.driveName(this.path);
-    let newPath = this.sessionContext.session!.path;
-    if (driveName) {
-      newPath = `${driveName}:${newPath}`;
-    }
-    this._updatePath(newPath);
+    const path = this.sessionContext.session!.path;
+    if (path !== this._path) {
+      this._path = path;
+      const localPath = this._manager.contents.localPath(path);
+      const name = PathExt.basename(localPath);
+      (this.urlResolver as RenderMimeRegistry.UrlResolver).path = path;
+      if (this._contentsModel) {
+        const contentsModel = {
+          ...this._contentsModel,
+          name: name,
+          path: path
+        };
+        this._updateContentsModel(contentsModel);
+      }
+      this._model.sharedModel.setState('path', localPath);
+      this._pathChanged.emit(path);
+    }
   }
 
   /**
    * Update our contents model, without the content.
    */
-  private _updateContentsModel(
-    model: Contents.IModel | Omit<Contents.IModel, 'content'>
-  ): void {
+  private _updateContentsModel(model: Contents.IModel): void {
     const writable = model.writable && !this._model.collaborative;
-    const newModel: Omit<Contents.IModel, 'content'> = {
+    const newModel: Contents.IModel = {
       path: model.path,
       name: model.name,
       type: model.type,
+      content: undefined,
       writable,
       created: model.created,
       last_modified: model.last_modified,
       mimetype: model.mimetype,
-      format: model.format,
-      hash: model.hash,
-      hash_algorithm: model.hash_algorithm
+      format: model.format
     };
-    const mod = this._contentsModel?.last_modified ?? null;
-    const hash = this._contentsModel?.hash ?? null;
+    const mod = this._contentsModel ? this._contentsModel.last_modified : null;
     this._contentsModel = newModel;
-    if (
-      // If neither modification date nor hash available, assume the file has changed
-      (!mod && !hash) ||
-      // Compare last_modified if no hash
-      (!hash && newModel.last_modified !== mod) ||
-      // Compare hash if available
-      (hash && newModel.hash !== hash)
-    ) {
+    this._model.sharedModel.setState('last_modified', newModel.last_modified);
+    if (!mod || newModel.last_modified !== mod) {
       this._fileChanged.emit(newModel);
     }
   }
 
-  private _updatePath(newPath: string): void {
-    if (this._path === newPath) {
-      return;
-    }
-
-    this._path = newPath;
-    const localPath = this._manager.contents.localPath(newPath);
-    const name = PathExt.basename(localPath);
-    if (this.sessionContext.session?.path !== localPath) {
-      void this.sessionContext.session?.setPath(localPath);
-    }
-    if (this.sessionContext.session?.name !== name) {
-      void this.sessionContext.session?.setName(name);
-    }
-    if ((this.urlResolver as RenderMimeRegistry.UrlResolver).path !== newPath) {
-      (this.urlResolver as RenderMimeRegistry.UrlResolver).path = newPath;
-    }
-    if (
-      this._contentsModel &&
-      (this._contentsModel.path !== newPath ||
-        this._contentsModel.name !== name)
-    ) {
-      const contentsModel = {
-        ...this._contentsModel,
-        name: name,
-        path: newPath
-      };
-      this._updateContentsModel(contentsModel);
-    }
-    this._pathChanged.emit(newPath);
-  }
-
   /**
    * Handle an initial population.
    */
   private async _populate(): Promise<void> {
+    await this._provider.ready;
+
     this._isPopulated = true;
     this._isReady = true;
     this._populatedPromise.resolve(void 0);
@@ -552,7 +586,7 @@
     // any kernel has started.
     void this.sessionContext.initialize().then(shouldSelect => {
       if (shouldSelect) {
-        void this._dialogs.selectKernel(this.sessionContext);
+        void this._dialogs.selectKernel(this.sessionContext, this.translator);
       }
     });
   }
@@ -573,18 +607,32 @@
 
     // rename triggers a fileChanged which updates the contents model
     await this._manager.contents.rename(this.path, newPath);
+    await this.sessionContext.session?.setPath(newPath);
+    await this.sessionContext.session?.setName(newName);
+
+    this._path = newPath;
+    const localPath = this._manager.contents.localPath(this._path);
+    (this.urlResolver as RenderMimeRegistry.UrlResolver).path = newPath;
+    this._model.sharedModel.setState('path', localPath);
+    this._pathChanged.emit(newPath);
   }
 
   /**
    * Save the document contents to disk.
    */
   private async _save(): Promise<void> {
+    // if collaborative mode is enabled, saving happens in the back-end
+    // after each change to the document
+    if (this._model.collaborative) {
+      return;
+    }
     this._saveState.emit('started');
     const options = this._createSaveOptions();
 
     try {
+      let value: Contents.IModel;
       await this._manager.ready;
-      const value = await this._maybeSave(options);
+      value = await this._maybeSave(options);
       if (this.isDisposed) {
         return;
       }
@@ -599,25 +647,69 @@
       // Emit completion.
       this._saveState.emit('completed');
     } catch (err) {
-      // If the save has been canceled by the user, throw the error
-      // so that whoever called save() can decide what to do.
-      const { name } = err;
-      if (name === 'ModalCancelError' || name === 'ModalDuplicateError') {
+      // If the save has been canceled by the user,
+      // throw the error so that whoever called save()
+      // can decide what to do.
+      if (
+        err.message === 'Cancel' ||
+        err.message === 'Modal is already displayed'
+      ) {
         throw err;
       }
 
       // Otherwise show an error message and throw the error.
       const localPath = this._manager.contents.localPath(this._path);
-      const file = PathExt.basename(localPath);
+      const name = PathExt.basename(localPath);
       void this._handleError(
         err,
-        this._trans.__('File Save Error for %1', file)
+        this._trans.__('File Save Error for %1', name)
       );
 
       // Emit failure.
       this._saveState.emit('failed');
       throw err;
     }
+  }
+
+  /**
+   * Load the metadata of the document without the content.
+   */
+  private _loadContext(): Promise<void> {
+    const opts: Contents.IFetchOptions = {
+      type: this._factory.contentType,
+      content: false,
+      ...(this._factory.fileFormat !== null
+        ? { format: this._factory.fileFormat }
+        : {})
+    };
+    const path = this._path;
+    return this._manager.ready
+      .then(() => {
+        return this._manager.contents.get(path, opts);
+      })
+      .then(contents => {
+        if (this.isDisposed) {
+          return;
+        }
+        const model = {
+          ...contents,
+          format: this._factory.fileFormat
+        };
+        this._updateContentsModel(model);
+        this._model.dirty = false;
+        if (!this._isPopulated) {
+          return this._populate();
+        }
+      })
+      .catch(async err => {
+        const localPath = this._manager.contents.localPath(this._path);
+        const name = PathExt.basename(localPath);
+        void this._handleError(
+          err,
+          this._trans.__('File Load Error for %1', name)
+        );
+        throw err;
+      });
   }
 
   /**
@@ -630,7 +722,6 @@
     const opts: Contents.IFetchOptions = {
       type: this._factory.contentType,
       content: this._factory.fileFormat !== null,
-      hash: this._factory.fileFormat !== null,
       ...(this._factory.fileFormat !== null
         ? { format: this._factory.fileFormat }
         : {})
@@ -645,26 +736,23 @@
         if (this.isDisposed) {
           return;
         }
-        if (contents.content) {
-          if (contents.format === 'json') {
-            model.fromJSON(contents.content);
+        if (contents.format === 'json') {
+          model.fromJSON(contents.content);
+        } else {
+          let content = contents.content;
+          // Convert line endings if necessary, marking the file
+          // as dirty.
+          if (content.indexOf('\r\n') !== -1) {
+            this._lineEnding = '\r\n';
+            content = content.replace(/\r\n/g, '\n');
+          } else if (content.indexOf('\r') !== -1) {
+            this._lineEnding = '\r';
+            content = content.replace(/\r/g, '\n');
           } else {
-            let content = contents.content;
-            // Convert line endings if necessary, marking the file
-            // as dirty.
-            if (content.indexOf('\r\n') !== -1) {
-              this._lineEnding = '\r\n';
-              content = content.replace(/\r\n/g, '\n');
-            } else if (content.indexOf('\r') !== -1) {
-              this._lineEnding = '\r';
-              content = content.replace(/\r/g, '\n');
-            } else {
-              this._lineEnding = null;
-            }
-            model.fromString(content);
+            this._lineEnding = null;
           }
+          model.fromString(content);
         }
-
         this._updateContentsModel(contents);
         model.dirty = false;
         if (!this._isPopulated) {
@@ -690,78 +778,34 @@
   ): Promise<Contents.IModel> {
     const path = this._path;
     // Make sure the file has not changed on disk.
-    const promise = this._manager.contents.get(path, {
-      content: false,
-      hash: true
-    });
+    const promise = this._manager.contents.get(path, { content: false });
     return promise.then(
       model => {
         if (this.isDisposed) {
           return Promise.reject(new Error('Disposed'));
         }
-        // Since jupyter server may provide hash in model, we compare hash first
-        const hashAvailable =
-          this.contentsModel?.hash !== undefined &&
-          this.contentsModel?.hash !== null &&
-          model.hash !== undefined &&
-          model.hash !== null;
-        const hClient = this.contentsModel?.hash;
-        const hDisk = model.hash;
-        if (hashAvailable && hClient !== hDisk) {
-          console.warn(`Different hash found for ${this.path}`);
-          return this._raiseConflict(model, options);
-        }
-
-        // When hash is not provided, we compare last_modified
         // We want to check last_modified (disk) > last_modified (client)
         // (our last save)
         // In some cases the filesystem reports an inconsistent time, so we allow buffer when comparing.
         const lastModifiedCheckMargin = this._lastModifiedCheckMargin;
-        const modified = this.contentsModel?.last_modified;
+        const ycontextModified = this._model.sharedModel.getState(
+          'last_modified'
+        ) as string;
+        // prefer using the timestamp from the state because it is more up to date
+        const modified = ycontextModified || this.contentsModel?.last_modified;
         const tClient = modified ? new Date(modified) : new Date();
         const tDisk = new Date(model.last_modified);
         if (
-          !hashAvailable &&
           modified &&
           tDisk.getTime() - tClient.getTime() > lastModifiedCheckMargin
         ) {
-          console.warn(
-            `Last saving performed ${tClient} ` +
-              `while the current file seems to have been saved ` +
-              `${tDisk}`
-          );
-          return this._raiseConflict(model, options);
+          return this._timeConflict(tClient, model, options);
         }
-
-        return this._manager.contents
-          .save(path, options)
-          .then(async contentsModel => {
-            const model = await this._manager.contents.get(path, {
-              content: false,
-              hash: true
-            });
-            return {
-              ...contentsModel,
-              hash: model.hash,
-              hash_algorithm: model.hash_algorithm
-            } as Contents.IModel;
-          });
+        return this._manager.contents.save(path, options);
       },
       err => {
         if (err.response && err.response.status === 404) {
-          return this._manager.contents
-            .save(path, options)
-            .then(async contentsModel => {
-              const model = await this._manager.contents.get(path, {
-                content: false,
-                hash: true
-              });
-              return {
-                ...contentsModel,
-                hash: model.hash,
-                hash_algorithm: model.hash_algorithm
-              } as Contents.IModel;
-            });
+          return this._manager.contents.save(path, options);
         }
         throw err;
       }
@@ -803,17 +847,23 @@
       }
     });
   }
+
   /**
    * Handle a time conflict.
    */
-  private _raiseConflict(
+  private _timeConflict(
+    tClient: Date,
     model: Contents.IModel,
     options: Partial<Contents.IModel>
   ): Promise<Contents.IModel> {
-    if (this._conflictModalIsOpen) {
-      const error = new Error('Modal is already displayed');
-      error.name = 'ModalDuplicateError';
-      return Promise.reject(error);
+    const tDisk = new Date(model.last_modified);
+    console.warn(
+      `Last saving performed ${tClient} ` +
+        `while the current file seems to have been saved ` +
+        `${tDisk}`
+    );
+    if (this._timeConflictModalIsOpen) {
+      return Promise.reject(new Error('Modal is already displayed'));
     }
     const body = this._trans.__(
       `"%1" has changed on disk since the last time it was opened or saved.
@@ -821,35 +871,30 @@
 or load the version on disk (revert)?`,
       this.path
     );
-    const revertBtn = Dialog.okButton({
-      label: this._trans.__('Revert'),
-      actions: ['revert']
-    });
+    const revertBtn = Dialog.okButton({ label: this._trans.__('Revert') });
     const overwriteBtn = Dialog.warnButton({
-      label: this._trans.__('Overwrite'),
-      actions: ['overwrite']
-    });
-    this._conflictModalIsOpen = true;
+      label: this._trans.__('Overwrite')
+    });
+    this._timeConflictModalIsOpen = true;
     return showDialog({
       title: this._trans.__('File Changed'),
       body,
       buttons: [Dialog.cancelButton(), revertBtn, overwriteBtn]
     }).then(result => {
-      this._conflictModalIsOpen = false;
+      this._timeConflictModalIsOpen = false;
       if (this.isDisposed) {
         return Promise.reject(new Error('Disposed'));
       }
-      if (result.button.actions.includes('overwrite')) {
+      if (result.button.label === this._trans.__('Overwrite')) {
         return this._manager.contents.save(this._path, options);
       }
-      if (result.button.actions.includes('revert')) {
+      // FIXME-TRANS: Why compare to label?
+      if (result.button.label === this._trans.__('Revert')) {
         return this.revert().then(() => {
           return model;
         });
       }
-      const error = new Error('Cancel');
-      error.name = 'ModalCancelError';
-      return Promise.reject(error); // Otherwise cancel the save.
+      return Promise.reject(new Error('Cancel')); // Otherwise cancel the save.
     });
   }
 
@@ -862,8 +907,7 @@
       path
     );
     const overwriteBtn = Dialog.warnButton({
-      label: this._trans.__('Overwrite'),
-      accept: true
+      label: this._trans.__('Overwrite')
     });
     return showDialog({
       title: this._trans.__('File Overwrite?'),
@@ -873,8 +917,8 @@
       if (this.isDisposed) {
         return Promise.reject(new Error('Disposed'));
       }
-
-      if (result.button.accept) {
+      // FIXME-TRANS: Why compare to label?
+      if (result.button.label === this._trans.__('Overwrite')) {
         return this._manager.contents.delete(path).then(() => {
           return this._finishSaveAs(path);
         });
@@ -939,34 +983,31 @@
   }
 
   protected translator: ITranslator;
-
-  private _isReady = false;
-  private _isDisposed = false;
-  private _isPopulated = false;
   private _trans: TranslationBundle;
   private _manager: ServiceManager.IManager;
   private _opener: (
     widget: Widget,
     options?: DocumentRegistry.IOpenOptions
   ) => void;
-
   private _model: T;
+  private _modelDB: IModelDB;
   private _path = '';
   private _lineEnding: string | null = null;
   private _factory: DocumentRegistry.IModelFactory<T>;
-  private _contentsModel: Omit<Contents.IModel, 'content'> | null = null;
-
+  private _contentsModel: Contents.IModel | null = null;
   private _readyPromise: Promise<void>;
   private _populatedPromise = new PromiseDelegate<void>();
+  private _isPopulated = false;
+  private _isReady = false;
+  private _isDisposed = false;
   private _pathChanged = new Signal<this, string>(this);
-  private _fileChanged = new Signal<this, Omit<Contents.IModel, 'content'>>(
-    this
-  );
+  private _fileChanged = new Signal<this, Contents.IModel>(this);
   private _saveState = new Signal<this, DocumentRegistry.SaveState>(this);
   private _disposed = new Signal<this, void>(this);
   private _dialogs: ISessionContext.IDialogs;
+  private _provider: IDocumentProvider;
   private _lastModifiedCheckMargin = 500;
-  private _conflictModalIsOpen = false;
+  private _timeConflictModalIsOpen = false;
 }
 
 /**
@@ -993,9 +1034,28 @@
     path: string;
 
     /**
+     * Whether the model is collaborative.
+     *
+     * @deprecated It will be removed in 4.0.0. The collaborative feature
+     * is provided by the `DocumentRegistry.IModel` (can be customized by the
+     * `DocumentRegistry.IModelFactory`)
+     */
+    collaborative?: boolean;
+
+    /**
      * The kernel preference associated with the context.
      */
     kernelPreference?: ISessionContext.IKernelPreference;
+
+    /**
+     * An factory method for the document provider.
+     */
+    docProviderFactory?: IDocumentProviderFactory<ISharedDocument>;
+
+    /**
+     * An IModelDB factory method which may be used for the document.
+     */
+    modelDBFactory?: ModelDB.IFactory;
 
     /**
      * An optional callback for opening sibling widgets.
@@ -1038,13 +1098,14 @@
     translator = translator || nullTranslator;
     const trans = translator.load('jupyterlab');
 
-    const saveBtn = Dialog.okButton({ label: trans.__('Save'), accept: true });
+    const saveBtn = Dialog.okButton({ label: trans.__('Save') });
     return showDialog({
-      title: trans.__('Save File Asâ€¦'),
+      title: trans.__('Save File As..'),
       body: new SaveWidget(path),
       buttons: [Dialog.cancelButton(), saveBtn]
     }).then(result => {
-      if (result.button.accept) {
+      // FIXME-TRANS: Why use the label?
+      if (result.button.label === trans.__('Save')) {
         return result.value ?? undefined;
       }
       return;