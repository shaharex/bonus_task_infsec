--- packages\docregistry\test\context.spec.ts (old)
+++ packages\docregistry\test\context.spec.ts (new)
@@ -8,14 +8,16 @@
   TextModelFactory
 } from '@jupyterlab/docregistry';
 import { RenderMimeRegistry } from '@jupyterlab/rendermime';
-import { Contents, Drive, ServiceManager } from '@jupyterlab/services';
+import { Contents, ServiceManager } from '@jupyterlab/services';
 import {
   acceptDialog,
   dismissDialog,
+  initNotebookContext,
+  NBTestUtils,
   signalToPromise,
   waitForDialog
-} from '@jupyterlab/testing';
-import { ServiceManagerMock } from '@jupyterlab/services/lib/testutils';
+} from '@jupyterlab/testutils';
+import * as Mock from '@jupyterlab/testutils/lib/mock';
 import { UUID } from '@lumino/coreutils';
 import { Widget } from '@lumino/widgets';
 
@@ -24,8 +26,7 @@
   const factory = new TextModelFactory();
 
   beforeAll(() => {
-    manager = new ServiceManagerMock();
-    manager.contents.addDrive(new Drive({ name: 'TestDrive' }));
+    manager = new Mock.ServiceManagerMock();
     return manager.ready;
   });
 
@@ -53,17 +54,6 @@
           path: UUID.uuid4() + '.txt'
         });
         expect(context).toBeInstanceOf(Context);
-      });
-
-      it('should set the session path with local path', () => {
-        const localPath = `${UUID.uuid4()}.txt`;
-        context = new Context({
-          manager,
-          factory,
-          path: `TestDrive:${localPath}`
-        });
-
-        expect(context.sessionContext.path).toEqual(localPath);
       });
     });
 
@@ -94,107 +84,6 @@
         await context.initialize(true);
         expect(called).toBe(true);
       });
-
-      it('should be emitted when the file hash changes', async () => {
-        let called = false;
-        context = new Context({
-          manager,
-          factory,
-          // The path below is a magic string instructing the `get()`
-          // method of the contents manager mock to return a random hash.
-          path: 'random-hash.txt'
-        });
-
-        await context.initialize(true);
-
-        context.fileChanged.connect((_sender, _args) => {
-          called = true;
-        });
-
-        const promise = context.save();
-
-        // Expect the correct dialog
-        await waitForDialog();
-        const dialog = document.body.getElementsByClassName(
-          'jp-Dialog'
-        )[0] as HTMLElement;
-        expect(dialog.innerHTML).toMatch(
-          'has changed on disk since the last time it was opened or saved'
-        );
-
-        // Accept dialog (overwrite)
-        await acceptDialog();
-        await promise;
-
-        // Expect the signal to have been emitted
-        expect(called).toBe(true);
-      });
-
-      it('should be emitted when the file timestamp changes and there is no hash', async () => {
-        let called = false;
-        context = new Context({
-          manager,
-          factory,
-          // The path below is a magic string instructing the `get()`
-          // method of the contents manager mock to return a newer timestamp and no hash.
-          path: 'newer-timestamp-no-hash.txt'
-        });
-
-        await context.initialize(true);
-
-        context.fileChanged.connect((_sender, _args) => {
-          called = true;
-        });
-
-        const promise = context.save();
-
-        // Expect the correct dialog
-        await waitForDialog();
-        const dialog = document.body.getElementsByClassName(
-          'jp-Dialog'
-        )[0] as HTMLElement;
-        expect(dialog.innerHTML).toMatch(
-          'has changed on disk since the last time it was opened or saved'
-        );
-
-        // Accept dialog (overwrite)
-        await acceptDialog();
-        await promise;
-
-        // Expect the signal to have been emitted
-        expect(called).toBe(true);
-      });
-
-      it('should not be emitted when the file hash is not changed', async () => {
-        let called = false;
-        context = new Context({
-          manager,
-          factory,
-          // The path below is a magic string instructing the `save()`
-          // method of the contents manager mock to not update time nor hash.
-          path: 'frozen-time-and-hash.txt'
-        });
-
-        await context.initialize(true);
-
-        context.fileChanged.connect(() => {
-          called = true;
-        });
-
-        await context.save();
-        expect(called).toBe(false);
-      });
-
-      it('should not contain the file content attribute', async () => {
-        let called = false;
-        context.fileChanged.connect((sender, args) => {
-          // @ts-expect-error content is omitted
-          expect(args['content']).toBeUndefined();
-          called = true;
-        });
-        await context.initialize(true);
-        expect(called).toBe(true);
-      });
     });
 
     describe('#saving', () => {
@@ -203,9 +92,7 @@
         let checked = false;
         context.saveState.connect((sender, args) => {
           if (!called) {
-            // eslint-disable-next-line jest/no-conditional-expect
             expect(sender).toBe(context);
-            // eslint-disable-next-line jest/no-conditional-expect
             expect(args).toBe('started');
 
             checked = true;
@@ -224,9 +111,7 @@
         let checked = false;
         context.saveState.connect((sender, args) => {
           if (called > 0) {
-            // eslint-disable-next-line jest/no-conditional-expect
             expect(sender).toBe(context);
-            // eslint-disable-next-line jest/no-conditional-expect
             expect(args).toBe('completed');
             checked = true;
           }
@@ -250,7 +135,6 @@
         let checked;
         context.saveState.connect((sender, args) => {
           if (called > 0) {
-            // eslint-disable-next-line jest/no-conditional-expect
             expect(sender).toBe(context);
             checked = args;
           }
@@ -258,8 +142,8 @@
           called += 1;
         });
 
-        await expect(context.initialize(true)).rejects.toThrow(
-          /Invalid response: 403/
+        await expect(context.initialize(true)).rejects.toThrowError(
+          'Invalid response: 403 Forbidden'
         );
         expect(called).toBe(2);
         expect(checked).toBe('failed');
@@ -284,7 +168,7 @@
     describe('#ready()', () => {
       it('should resolve when the file is saved for the first time', async () => {
         await context.initialize(true);
-        await expect(context.ready).resolves.not.toThrow();
+        await context.ready;
       });
 
       it('should resolve when the file is reverted for the first time', async () => {
@@ -294,7 +178,30 @@
           content: 'foo'
         });
         await context.initialize(false);
-        await expect(context.ready).resolves.not.toThrow();
+        await context.ready;
+      });
+
+      it('should initialize the model when the file is saved for the first time', async () => {
+        const context = await initNotebookContext({ manager });
+        context.model.fromJSON(NBTestUtils.DEFAULT_CONTENT);
+        expect(context.model.cells.canUndo).toBe(true);
+        await context.initialize(true);
+        await context.ready;
+        expect(context.model.cells.canUndo).toBe(false);
+      });
+
+      it('should initialize the model when the file is reverted for the first time', async () => {
+        const context = await initNotebookContext({ manager });
+        await manager.contents.save(context.path, {
+          type: 'notebook',
+          format: 'json',
+          content: NBTestUtils.DEFAULT_CONTENT
+        });
+        context.model.fromJSON(NBTestUtils.DEFAULT_CONTENT);
+        expect(context.model.cells.canUndo).toBe(true);
+        await context.initialize(false);
+        await context.ready;
+        expect(context.model.cells.canUndo).toBe(false);
       });
     });
 
@@ -351,8 +258,6 @@
         void context.initialize(true);
         await context.ready;
         expect(context.contentsModel!.path).toBe(path);
-        // @ts-expect-error content is omitted
-        expect(context.contentsModel!['content']).toBeUndefined();
       });
     });
 