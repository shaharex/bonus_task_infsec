--- packages\completer\src\widget.ts (old)
+++ packages\completer\src\widget.ts (new)
@@ -1,17 +1,16 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
-import { Sanitizer } from '@jupyterlab/apputils';
+import { defaultSanitizer, HoverBox, ISanitizer } from '@jupyterlab/apputils';
 import { CodeEditor } from '@jupyterlab/codeeditor';
-import { IRenderMime, renderText } from '@jupyterlab/rendermime';
-import { HoverBox, LabIcon } from '@jupyterlab/ui-components';
-import { JSONObject } from '@lumino/coreutils';
+import { LabIcon } from '@jupyterlab/ui-components';
+import { IIterator, IterableOrArrayLike, toArray } from '@lumino/algorithm';
+import { JSONExt, JSONObject } from '@lumino/coreutils';
 import { IDisposable } from '@lumino/disposable';
 import { ElementExt } from '@lumino/domutils';
 import { Message } from '@lumino/messaging';
 import { ISignal, Signal } from '@lumino/signaling';
 import { Widget } from '@lumino/widgets';
-
 import { CompletionHandler } from './handler';
 
 /**
@@ -25,14 +24,14 @@
 const ACTIVE_CLASS = 'jp-mod-active';
 
 /**
- * The class used by item listing which determines the height of the completer.
+ * The minimum height of a completer widget.
  */
-const LIST_CLASS = 'jp-Completer-list';
+const MIN_HEIGHT = 20;
 
 /**
- * Class of the documentation panel.
+ * The maximum height of a completer widget.
  */
-const DOC_PANEL_CLASS = 'jp-Completer-docpanel';
+const MAX_HEIGHT = 300;
 
 /**
  * A flag to indicate that event handlers are caught in the capture phase.
@@ -60,41 +59,18 @@
    */
   constructor(options: Completer.IOptions) {
     super({ node: document.createElement('div') });
-    this.sanitizer = options.sanitizer ?? new Sanitizer();
-    this._defaultRenderer = Completer.getDefaultRenderer(this.sanitizer);
-    this._renderer = options.renderer ?? this._defaultRenderer;
-    this._docPanel = this._createDocPanelNode();
-    this.model = options.model ?? null;
-    this.editor = options.editor ?? null;
+    this.sanitizer = options.sanitizer ?? defaultSanitizer;
+    this._renderer =
+      options.renderer ?? Completer.getDefaultRenderer(this.sanitizer);
+    this.model = options.model || null;
+    this.editor = options.editor || null;
     this.addClass('jp-Completer');
-    this._updateConstraints();
-  }
-
-  /**
-   * Cache style constraints from CSS.
-   */
-  protected _updateConstraints() {
-    const tempNode = document.createElement('div');
-    tempNode.classList.add(LIST_CLASS);
-    tempNode.style.visibility = 'hidden';
-    tempNode.style.overflowY = 'scroll';
-    document.body.appendChild(tempNode);
-    const computedStyle = window.getComputedStyle(tempNode);
-    this._maxHeight = parseInt(computedStyle.maxHeight, 10);
-    this._minHeight = parseInt(computedStyle.minHeight, 10);
-    this._scrollbarWidth = tempNode.offsetWidth - tempNode.clientWidth;
-    document.body.removeChild(tempNode);
-    const tempDocPanel = this._createDocPanelNode();
-    this._docPanelWidth = Private.measureSize(
-      tempDocPanel,
-      'inline-block'
-    ).width;
-  }
-
-  /**
-   * The sanitizer used to sanitize untrusted HTML inputs.
-   */
-  readonly sanitizer: IRenderMime.ISanitizer;
+  }
+
+  /**
+   * The sanitizer used to sanitize untrusted html inputs.
+   */
+  readonly sanitizer: ISanitizer;
 
   /**
    * The active index.
@@ -106,10 +82,10 @@
   /**
    * The editor used by the completion widget.
    */
-  get editor(): CodeEditor.IEditor | null | undefined {
+  get editor(): CodeEditor.IEditor | null {
     return this._editor;
   }
-  set editor(newValue: CodeEditor.IEditor | null | undefined) {
+  set editor(newValue: CodeEditor.IEditor | null) {
     this._editor = newValue;
   }
 
@@ -150,41 +126,17 @@
     }
     if (this._model) {
       this._model.stateChanged.disconnect(this.onModelStateChanged, this);
-      this._model.queryChanged.disconnect(this.onModelQueryChanged, this);
     }
     this._model = model;
     if (this._model) {
       this._model.stateChanged.connect(this.onModelStateChanged, this);
-      this._model.queryChanged.connect(this.onModelQueryChanged, this);
-    }
-  }
-
-  /**
-   * The completer used by the completer widget.
-   */
-  get renderer(): Completer.IRenderer {
-    return this._renderer;
-  }
-  set renderer(renderer: Completer.IRenderer) {
-    this._renderer = renderer;
-  }
-
-  /**
-   * Enable/disable the document panel.
-   */
-  set showDocsPanel(showDoc: boolean) {
-    this._showDoc = showDoc;
-  }
-
-  get showDocsPanel(): boolean {
-    return this._showDoc;
+    }
   }
 
   /**
    * Dispose of the resources held by the completer widget.
    */
-  dispose(): void {
-    this._sizeCache = undefined;
+  dispose() {
     this._model = null;
     super.dispose();
   }
@@ -227,10 +179,6 @@
     if (this._model) {
       this._model.reset(true);
     }
-    this._docPanel.style.display = 'none';
-    // Clear size cache.
-    this._sizeCache = undefined;
-    this.node.scrollTop = 0;
   }
 
   /**
@@ -276,81 +224,52 @@
   }
 
   /**
-   * Handle model query changes.
-   */
-  protected onModelQueryChanged(
-    model: Completer.IModel,
-    queryChange: Completer.IQueryChange
-  ): void {
-    // If query was changed by the user typing, the filtered down items
-    // may no longer reach/exceed the maxHeight of the completer widget,
-    // hence size needs to be recalculated.
-    if (this._sizeCache && queryChange.origin === 'editorUpdate') {
-      const newItems = model.completionItems();
-      const oldItems = this._sizeCache.items;
-      // Only reset size if the number of items changed, or the longest item changed.
-      const oldWidest = oldItems[this._findWidestItemIndex(oldItems)];
-      const newWidest = newItems[this._findWidestItemIndex(newItems)];
-      const heuristic = this._getPreferredItemWidthHeuristic();
-      if (
-        newItems.length !== this._sizeCache.items.length ||
-        heuristic(oldWidest) !== heuristic(newWidest)
-      ) {
-        this._sizeCache = undefined;
-      }
-    }
-  }
-
-  /**
    * Handle `update-request` messages.
    */
   protected onUpdateRequest(msg: Message): void {
     const model = this._model;
+
     if (!model) {
       return;
     }
 
-    // If this is the first time the current completer session has loaded,
-    // populate any initial subset match. This is being done before node
-    // gets rendered to avoid rendering it twice.
-    if (!model.query) {
-      this._populateSubset();
-    }
-
-    let items = model.completionItems();
-
-    // If there are no items, reset and bail.
-    if (!items.length) {
+    if (this._resetFlag) {
+      this._resetFlag = false;
       if (!this.isHidden) {
-        this.reset();
         this.hide();
         this._visibilityChanged.emit(undefined);
       }
       return;
     }
 
-    // Update constraints before any DOM modifications
-    this._updateConstraints();
-
-    // Do not trigger any geometry updates from async code when in lock.
-    this._geometryLock = true;
-
-    const node = this._createCompleterNode(model, items);
-
-    let active = node.querySelectorAll(`.${ITEM_CLASS}`)[
-      this._activeIndex
-    ] as HTMLElement;
+    let node: HTMLElement | null = null;
+    let completionItemList = model.completionItems && model.completionItems();
+    if (completionItemList && completionItemList.length) {
+      node = this._createCompletionItemNode(model, completionItemList);
+    } else {
+      node = this._createIItemNode(model);
+    }
+    if (!node) {
+      return;
+    }
+
+    let active = node.querySelectorAll(`.${ITEM_CLASS}`)[this._activeIndex];
     active.classList.add(ACTIVE_CLASS);
 
-    const resolvedItem = this.model?.resolveItem(items[this._activeIndex]);
-
     // Add the documentation panel
-    if (this._showDoc) {
-      this._docPanel.innerText = '';
-      node.appendChild(this._docPanel);
-      this._docPanelExpanded = false;
-      this._docPanel.style.display = 'none';
-      this._updateDocPanel(resolvedItem, active);
+    let docPanel = document.createElement('div');
+    docPanel.className = 'jp-Completer-docpanel';
+    node.appendChild(docPanel);
+    this._updateDocPanel();
+
+    // If this is the first time the current completer session has loaded,
+    // populate any initial subset match.
+    if (!model.query) {
+      const populated = this._populateSubset();
+      if (populated) {
+        this.update();
+        return;
+      }
     }
 
     if (this.isHidden) {
@@ -360,33 +279,22 @@
     } else {
       this._setGeometry();
     }
-    this._geometryLock = false;
-  }
-
-  /**
-   * Get cached dimensions of the completer box.
-   */
-  protected get sizeCache(): Completer.IDimensions | undefined {
-    if (!this._sizeCache) {
-      return;
-    }
-    return {
-      width: this._sizeCache.width + this._sizeCache.docPanelWidth,
-      height: Math.max(this._sizeCache.height, this._sizeCache.docPanelHeight)
-    };
-  }
-
-  private _createDocPanelNode() {
-    const docPanel = document.createElement('div');
-    docPanel.className = DOC_PANEL_CLASS;
-    return docPanel;
-  }
-
-  private _createCompleterNode(
+  }
+
+  private _createCompletionItemNode(
     model: Completer.IModel,
     items: CompletionHandler.ICompletionItems
-  ): HTMLElement {
-    const current = ++this._renderCounter;
+  ): HTMLElement | null {
+    // If there are no items, reset and bail.
+    if (!items.length) {
+      this._resetFlag = true;
+      this.reset();
+      if (!this.isHidden) {
+        this.hide();
+        this._visibilityChanged.emit(undefined);
+      }
+      return null;
+    }
 
     // Clear the node.
     let node = this.node;
@@ -398,135 +306,64 @@
 
     // Populate the completer items.
     let ul = document.createElement('ul');
-    ul.className = LIST_CLASS;
-
-    // Add first N items to fill the first "page" assuming that the completer
-    // would reach its maximum allowed height.
-    const first = this._renderer.createCompletionItemNode(
-      items[0],
-      orderedTypes
-    );
-    const renderedItems = [first];
-
-    const firstItemSize = Private.measureSize(first, 'inline-grid');
-    const pageSize = Math.max(
-      Math.ceil(this._maxHeight / firstItemSize.height),
-      5
-    );
-    // We add one item in case if height heuristic is inaccurate.
-    const toRenderImmediately = Math.min(pageSize + 1, items.length);
-
-    const start = performance.now();
-    for (let i = 1; i < toRenderImmediately; i++) {
-      const li = this._renderer.createCompletionItemNode(
-        items[i],
+    ul.className = 'jp-Completer-list';
+    for (let item of items) {
+      if (!this._renderer.createCompletionItemNode) {
+        return null;
+      }
+      let li = this._renderer.createCompletionItemNode(item, orderedTypes);
+      ul.appendChild(li);
+    }
+    node.appendChild(ul);
+    return node;
+  }
+
+  private _createIItemNode(model: Completer.IModel): HTMLElement | null {
+    const items = toArray(model.items());
+
+    // If there are no items, reset and bail.
+    if (!items || !items.length) {
+      this._resetFlag = true;
+      this.reset();
+      if (!this.isHidden) {
+        this.hide();
+        this._visibilityChanged.emit(undefined);
+      }
+      return null;
+    }
+
+    // If there is only one option, signal and bail.
+    // We don't test the filtered `items`, as that
+    // is too aggressive of completer behavior, it can
+    // lead to double typing of an option.
+    const options = toArray(model.options());
+    if (options.length === 1) {
+      this._selected.emit(options[0]);
+      this.reset();
+      return null;
+    }
+
+    // Clear the node.
+    const node = this.node;
+    node.textContent = '';
+
+    // Compute an ordered list of all the types in the typeMap, this is computed
+    // once by the model each time new data arrives for efficiency.
+    const orderedTypes = model.orderedTypes();
+
+    // Populate the completer items.
+    let ul = document.createElement('ul');
+    ul.className = 'jp-Completer-list';
+    for (const item of items) {
+      const li = this._renderer.createItemNode(
+        item!,
+        model.typeMap(),
         orderedTypes
       );
-      renderedItems.push(li);
-    }
-
-    for (const li of renderedItems) {
       ul.appendChild(li);
     }
-
-    // Pre-calculate size:
-    //  - height will equal first element height times number of items,
-    //    or maximum allowed height if there are more items than fit on a page,
-    //  - width will be estimated from the widest item.
-    const widestItemIndex = this._findWidestItemIndex(items);
-    const widestItem =
-      widestItemIndex < renderedItems.length
-        ? renderedItems[widestItemIndex]
-        : this._renderer.createCompletionItemNode(
-            items[widestItemIndex],
-            orderedTypes
-          );
-
-    // The node needs to be cloned to avoid side-effect of detaching it.
-    const widestItemSize = Private.measureSize(
-      widestItem.cloneNode(true) as HTMLElement,
-      'inline-grid'
-    );
-
-    this._sizeCache = {
-      height: Math.min(this._maxHeight, firstItemSize.height * items.length),
-      width: widestItemSize.width + this._scrollbarWidth,
-      items: items,
-      docPanelWidth: 0,
-      docPanelHeight: 0
-    };
-
-    if (toRenderImmediately < items.length) {
-      // Render remaining items on idle in subsequent animation frames,
-      // in chunks of size such that each frame would take about 16ms
-      // allowing for 4ms of overhead, but keep the chunks no smaller
-      // than 5 items at a time.
-      const timePerItem = (performance.now() - start) / toRenderImmediately;
-
-      const chunkSize = Math.max(5, Math.floor(12 / timePerItem));
-
-      let alreadyRendered = toRenderImmediately;
-      let previousChunkFinal = renderedItems[renderedItems.length - 1];
-
-      const renderChunk = () => {
-        if (alreadyRendered >= items.length) {
-          return;
-        }
-        // Add a filler so that the list with partially rendered items has the total
-        // height equal to the (predicted) final height to avoid scrollbar jitter.
-        const predictedMissingHeight =
-          firstItemSize.height * (items.length - alreadyRendered);
-        previousChunkFinal.style.marginBottom = `${predictedMissingHeight}px`;
-
-        requestAnimationFrame(() => {
-          if (current != this._renderCounter) {
-            // Bail if rendering afresh was requested in the meantime.
-            return;
-          }
-          previousChunkFinal.style.marginBottom = '';
-          const limit = Math.min(items.length, alreadyRendered + chunkSize);
-          for (let i = alreadyRendered; i < limit; i++) {
-            const li = this._renderer.createCompletionItemNode(
-              items[i],
-              orderedTypes
-            );
-            ul.appendChild(li);
-            previousChunkFinal = li;
-          }
-          alreadyRendered = limit;
-
-          renderChunk();
-        });
-      };
-      renderChunk();
-    }
-
     node.appendChild(ul);
     return node;
-  }
-
-  /**
-   * Use preferred heuristic to find the index of the widest item.
-   */
-  private _findWidestItemIndex(
-    items: CompletionHandler.ICompletionItems
-  ): number {
-    const widthHeuristic = this._getPreferredItemWidthHeuristic();
-
-    const widthHeuristics = items.map(widthHeuristic);
-    return widthHeuristics.indexOf(Math.max(...widthHeuristics));
-  }
-
-  /**
-   * Get item width heuristic function from renderer if available,
-   * or the default one otherwise.
-   */
-  private _getPreferredItemWidthHeuristic(): (
-    item: CompletionHandler.ICompletionItem
-  ) => number {
-    return this._renderer.itemWidthHeuristic
-      ? this._renderer.itemWidthHeuristic.bind(this._renderer)
-      : this._defaultRenderer.itemWidthHeuristic.bind(this._defaultRenderer);
   }
 
   /**
@@ -540,42 +377,40 @@
   private _cycle(direction: Private.scrollType): void {
     const items = this.node.querySelectorAll(`.${ITEM_CLASS}`);
     const index = this._activeIndex;
-    const last = items.length - 1;
     let active = this.node.querySelector(`.${ACTIVE_CLASS}`) as HTMLElement;
     active.classList.remove(ACTIVE_CLASS);
 
-    switch (direction) {
-      case 'up':
-        this._activeIndex = index === 0 ? last : index - 1;
-        break;
-      case 'down':
-        this._activeIndex = index < last ? index + 1 : 0;
-        break;
-      case 'pageUp':
-      case 'pageDown': {
-        // Measure the number of items on a page and clamp to the list length.
-        const container = this.node.getBoundingClientRect();
-        const current = active.getBoundingClientRect();
-        const page = Math.floor(container.height / current.height);
-        const sign = direction === 'pageUp' ? -1 : 1;
-        this._activeIndex = Math.min(Math.max(0, index + sign * page), last);
-        break;
-      }
+    if (direction === 'up') {
+      this._activeIndex = index === 0 ? items.length - 1 : index - 1;
+    } else if (direction === 'down') {
+      this._activeIndex = index < items.length - 1 ? index + 1 : 0;
+    } else {
+      // Measure the number of items on a page.
+      const boxHeight = this.node.getBoundingClientRect().height;
+      const itemHeight = active.getBoundingClientRect().height;
+      const pageLength = Math.floor(boxHeight / itemHeight);
+
+      // Update the index
+      if (direction === 'pageUp') {
+        this._activeIndex = index - pageLength;
+      } else {
+        this._activeIndex = index + pageLength;
+      }
+      // Clamp to the length of the list.
+      this._activeIndex = Math.min(
+        Math.max(0, this._activeIndex),
+        items.length - 1
+      );
     }
 
     active = items[this._activeIndex] as HTMLElement;
     active.classList.add(ACTIVE_CLASS);
-    let completionList = this.node.querySelector(`.${LIST_CLASS}`) as Element;
+    let completionList = this.node.querySelector(
+      '.jp-Completer-list'
+    ) as Element;
     ElementExt.scrollIntoViewIfNeeded(completionList, active);
     this._indexChanged.emit(this._activeIndex);
-    const visibleCompletionItems = this.model?.completionItems();
-    const activeCompletionItem = visibleCompletionItems?.[this._activeIndex];
-    if (activeCompletionItem) {
-      const resolvedItem = this.model?.resolveItem(activeCompletionItem);
-      if (this._showDoc) {
-        this._updateDocPanel(resolvedItem, active);
-      }
-    }
+    this._updateDocPanel();
   }
 
   /**
@@ -600,7 +435,7 @@
           return;
         }
         // Autoinsert single completions on manual request (tab)
-        const items = model.completionItems();
+        const items = model.completionItems && model.completionItems();
         if (items && items.length === 1) {
           this._selected.emit(items[0].insertText || items[0].label);
           this.reset();
@@ -613,13 +448,12 @@
         // then emit a completion signal with that `query` (=subset match),
         // but only if the query has actually changed.
         // See: https://github.com/jupyterlab/jupyterlab/issues/10439#issuecomment-875189540
-        if (model.query && model.query !== this._lastSubsetMatch) {
+        if (model.query && model.query != this._lastSubsetMatch) {
           model.subsetMatch = true;
           this._selected.emit(model.query);
           model.subsetMatch = false;
           this._lastSubsetMatch = model.query;
         }
-
         // If the query changed, update rendering of the options.
         if (populated) {
           this.update();
@@ -723,10 +557,8 @@
       return false;
     }
 
-    const items = model.completionItems();
-    const subset = Private.commonSubset(
-      items.map(item => item.insertText || item.label)
-    );
+    const items = this.node.querySelectorAll(`.${ITEM_CLASS}`);
+    const subset = Private.commonSubset(Private.itemValues(items));
     const { query } = model;
 
     // If a common subset exists and it is not the current query, highlight it.
@@ -756,12 +588,7 @@
 
     const start = model.cursor.start;
     const position = editor.getPositionAt(start) as CodeEditor.IPosition;
-    const anchor = editor.getCoordinateForPosition(position);
-
-    if (!anchor) {
-      return;
-    }
-
+    const anchor = editor.getCoordinateForPosition(position) as ClientRect;
     const style = window.getComputedStyle(node);
     const borderLeft = parseInt(style.borderLeftWidth!, 10) || 0;
     const paddingLeft = parseInt(style.paddingLeft!, 10) || 0;
@@ -775,157 +602,72 @@
       (editor.host.closest('.jp-MainAreaWidget > .lm-Widget') as HTMLElement) ||
       editor.host;
 
-    const items = model.completionItems();
-
-    // Fast cache invalidation (only checks for length rather than length + width)
-    if (this._sizeCache && this._sizeCache.items.length !== items.length) {
-      this._sizeCache = undefined;
-    }
-
     // Calculate the geometry of the completer.
     HoverBox.setGeometry({
       anchor,
       host: host,
-      maxHeight: this._maxHeight,
-      minHeight: this._minHeight,
+      maxHeight: MAX_HEIGHT,
+      minHeight: MIN_HEIGHT,
       node: node,
-      size: this.sizeCache,
       offset: { horizontal: borderLeft + paddingLeft },
       privilege: 'below',
       style: style,
       outOfViewDisplay: {
-        top: 'stick-inside',
-        bottom: 'stick-inside',
+        top: 'hidden-inside',
+        bottom: 'hidden-inside',
         left: 'stick-inside',
         right: 'stick-outside'
       }
     });
-    const current = ++this._geometryCounter;
-    if (!this._sizeCache) {
-      // If size was not pre-calculated using heuristics, save the actual
-      // size into cache once rendered.
-      requestAnimationFrame(() => {
-        if (current != this._geometryCounter) {
-          // Do not set size to cache if it may already be outdated.
-          return;
-        }
-        let rect = node.getBoundingClientRect();
-        let panel = this._docPanel.getBoundingClientRect();
-        this._sizeCache = {
-          width: rect.width - panel.width,
-          height: rect.height,
-          items: items,
-          docPanelWidth: panel.width,
-          docPanelHeight: panel.height
-        };
-      });
-    }
   }
 
   /**
    * Update the display-state and contents of the documentation panel
    */
-  private _updateDocPanel(
-    resolvedItem: Promise<CompletionHandler.ICompletionItem | null> | undefined,
-    activeNode: HTMLElement
-  ): void {
-    let docPanel = this._docPanel;
-
-    if (!resolvedItem) {
-      this._toggleDocPanel(false);
-      return;
-    }
-
-    const loadingIndicator =
-      this._renderer.createLoadingDocsIndicator?.() ??
-      this._defaultRenderer.createLoadingDocsIndicator();
-    activeNode.appendChild(loadingIndicator);
-
-    resolvedItem
-      .then(activeItem => {
-        if (!activeItem) {
-          return;
-        }
-        if (!docPanel) {
-          return;
-        }
-        if (activeItem.documentation) {
-          const node =
-            this._renderer.createDocumentationNode?.(activeItem) ??
-            this._defaultRenderer.createDocumentationNode(activeItem);
-          docPanel.textContent = '';
-          docPanel.appendChild(node);
-          this._toggleDocPanel(true);
-        } else {
-          this._toggleDocPanel(false);
-        }
-      })
-      .catch(e => console.error(e))
-      .finally(() => {
-        activeNode.removeChild(loadingIndicator);
-      });
-  }
-
-  private _toggleDocPanel(show: boolean): void {
-    let docPanel = this._docPanel;
-
-    if (show) {
-      if (this._docPanelExpanded) {
-        return;
-      }
-      docPanel.style.display = '';
-      this._docPanelExpanded = true;
+  private _updateDocPanel(): void {
+    let docPanel = this.node.querySelector('.jp-Completer-docpanel');
+    if (!docPanel) {
+      return;
+    }
+    if (!this.model?.completionItems) {
+      return;
+    }
+    let items = this.model?.completionItems();
+    if (!items) {
+      docPanel.setAttribute('style', 'display:none');
+      return;
+    }
+    let activeItem = items[this._activeIndex];
+    if (!activeItem) {
+      docPanel.setAttribute('style', 'display:none');
+      return;
+    }
+    docPanel.textContent = '';
+    if (activeItem.documentation) {
+      let node: HTMLElement;
+      if (!this._renderer.createDocumentationNode) {
+        node = Completer.getDefaultRenderer(
+          this.sanitizer
+        ).createDocumentationNode(activeItem);
+      } else {
+        node = this._renderer.createDocumentationNode(activeItem);
+      }
+      docPanel.appendChild(node);
+      docPanel.setAttribute('style', '');
     } else {
-      if (!this._docPanelExpanded) {
-        return;
-      }
-      docPanel.style.display = 'none';
-      this._docPanelExpanded = false;
-    }
-    const sizeCache = this._sizeCache;
-    if (sizeCache) {
-      sizeCache.docPanelHeight = show ? this._maxHeight : 0;
-      sizeCache.docPanelWidth = show ? this._docPanelWidth : 0;
-      if (!this._geometryLock) {
-        this._setGeometry();
-      }
+      docPanel.setAttribute('style', 'display:none');
     }
   }
 
   private _activeIndex = 0;
-  private _editor: CodeEditor.IEditor | null | undefined = null;
+  private _editor: CodeEditor.IEditor | null = null;
   private _model: Completer.IModel | null = null;
   private _renderer: Completer.IRenderer;
-  private _defaultRenderer: Completer.Renderer;
+  private _resetFlag = false;
   private _selected = new Signal<this, string>(this);
   private _visibilityChanged = new Signal<this, void>(this);
   private _indexChanged = new Signal<this, number>(this);
   private _lastSubsetMatch: string = '';
-  private _showDoc: boolean;
-  private _sizeCache: Private.IDimensionsCache | undefined;
-
-  /**
-   * The maximum height of a completer widget.
-   */
-  private _maxHeight: number;
-
-  /**
-   * The minimum height of a completer widget.
-   */
-  private _minHeight: number;
-
-  private _scrollbarWidth: number;
-  private _docPanelWidth: number;
-  private _docPanel: HTMLElement;
-  private _geometryLock = false;
-
-  /**
-   * Increasing this counter invalidates previous request to save geometry cache in animation callback.
-   */
-  private _geometryCounter: number = 0;
-
-  private _docPanelExpanded = false;
-  private _renderCounter: number = 0;
 }
 
 export namespace Completer {
@@ -954,14 +696,9 @@
     renderer?: IRenderer;
 
     /**
-     * Flag to show or hide the document panel.
-     */
-    showDoc?: boolean;
-
-    /**
      * Sanitizer used to sanitize html strings
      */
-    sanitizer?: IRenderMime.ISanitizer;
+    sanitizer?: ISanitizer;
   }
 
   /**
@@ -974,6 +711,16 @@
     readonly text: string;
 
     /**
+     * The height of a character in the editor.
+     */
+    readonly lineHeight: number;
+
+    /**
+     * The width of a character in the editor.
+     */
+    readonly charWidth: number;
+
+    /**
      * The line number of the editor cursor.
      */
     readonly line: number;
@@ -985,37 +732,15 @@
   }
 
   /**
-   * Information about the query string change.
-   */
-  export interface IQueryChange {
-    /**
-     * The new value of the query.
-     */
-    newValue: string;
-    /**
-     * The event which caused the query to change, one of:
-     * - `editorUpdate`: as a result of editor change, e.g. user typing code,
-     * - `setter`: programatically, e.g. by the logic in the widget,
-     * - `reset`: due to completer model being reset.
-     */
-    origin: 'setter' | 'editorUpdate' | 'reset';
-  }
-
-  /**
    * The data model backing a code completer widget.
    */
   export interface IModel extends IDisposable {
     /**
-     * A signal emitted when state of the completer model changes.
+     * A signal emitted when state of the completer menu changes.
      */
     readonly stateChanged: ISignal<IModel, void>;
 
     /**
-     * A signal emitted when query string changes (at invocation, or as user types).
-     */
-    readonly queryChanged: ISignal<IModel, IQueryChange>;
-
-    /**
      * The current text state details.
      */
     current: ITextState | null;
@@ -1043,27 +768,22 @@
     /**
      * Get the list of visible CompletionItems in the completer menu.
      */
-    completionItems(): CompletionHandler.ICompletionItems;
+    completionItems?(): CompletionHandler.ICompletionItems;
 
     /**
      * Set the list of visible CompletionItems in the completer menu.
      */
-    setCompletionItems(items: CompletionHandler.ICompletionItems): void;
-
-    /**
-     * Lazy load missing data of an item.
-     * @param activeIndex - the item or its index
-     * @remarks
-     * Resolving item by index will be deprecated in
-     * the next major release.
-     *
-     * @return Return `undefined` if the completion item with {@link activeIndex} index can not be found.
-     *  Return a promise of `null` if another {@link resolveItem} is called. Otherwise return the
-     * promise of resolved completion item.
-     */
-    resolveItem(
-      activeIndex: number | CompletionHandler.ICompletionItem
-    ): Promise<CompletionHandler.ICompletionItem | null> | undefined;
+    setCompletionItems?(items: CompletionHandler.ICompletionItems): void;
+
+    /**
+     * Get the of visible items in the completer menu.
+     */
+    items(): IIterator<IItem>;
+
+    /**
+     * Get the unfiltered options in a completer menu.
+     */
+    options(): IIterator<string>;
 
     /**
      * The map from identifiers (`a.b`) to their types (function, module, class,
@@ -1075,6 +795,14 @@
      * An ordered list of types used for visual encoding.
      */
     orderedTypes(): string[];
+
+    /**
+     * Set the available options in the completer menu.
+     */
+    setOptions(
+      options: IterableOrArrayLike<string>,
+      typeMap?: JSONObject
+    ): void;
 
     /**
      * Handle a cursor change.
@@ -1120,6 +848,21 @@
   }
 
   /**
+   * A completer menu item.
+   */
+  export interface IItem {
+    /**
+     * The highlighted, marked up text of a visible completer item.
+     */
+    text: string;
+
+    /**
+     * The raw text of a visible completer item.
+     */
+    raw: string;
+  }
+
+  /**
    * A cursor span.
    */
   export interface ICursorSpan extends JSONObject {
@@ -1137,71 +880,39 @@
   /**
    * A renderer for completer widget nodes.
    */
-  export interface IRenderer<
-    T extends
-      CompletionHandler.ICompletionItem = CompletionHandler.ICompletionItem
-  > {
-    /**
-     * Create an item node (an `li` element) from a ICompletionItem
+  export interface IRenderer {
+    /**
+     * Create an item node (an `li` element)  from a ICompletionItem
      * for a text completer menu.
-     *
-     * #### Notes
-     * The item provided to renderer is already pre-processed by the model:
-     * - the `label` is escaped to ensure that no user-generated HTML is included;
-     *   if `insertText` was not originally provided, it is set to raw `label`
-     *   (prior to escaping) if needed,
-     * - if there were any matches against the query the `label` has them
-     *    highlighted with `<mark>`s.
-     */
-    createCompletionItemNode(item: T, orderedTypes: string[]): HTMLLIElement;
+     */
+    createCompletionItemNode?(
+      item: CompletionHandler.ICompletionItem,
+      orderedTypes: string[]
+    ): HTMLLIElement;
+
+    /**
+     * Create an item node (an `li` element) for a text completer menu.
+     */
+    createItemNode(
+      item: IItem,
+      typeMap: TypeMap,
+      orderedTypes: string[]
+    ): HTMLLIElement;
 
     /**
      * Create a documentation node (a `pre` element by default) for
      * documentation panel.
      */
-    createDocumentationNode?(activeItem: T): HTMLElement;
-
-    /**
-     * Create a loading indicator element for document panel.
-     */
-    createLoadingDocsIndicator?(): HTMLElement;
-
-    /**
-     * Get a heuristic for the width of an item.
-     *
-     * As a performance optimization completer will infer the hover box width
-     * from the widest item node which will be rendered before all other nodes.
-     * By default the widest item is selected based on label length heuristic;
-     * renderers which customize item rendering can use this method to provide
-     * a custom heuristic.
-     */
-    itemWidthHeuristic?(a: T): number;
-  }
-
-  /**
-   * A namespace for the default renderer.
-   */
-  export namespace Renderer {
-    export interface IOptions {
-      /**
-       * The sanitizer used to sanitize untrusted HTML inputs.
-       */
-      sanitizer?: IRenderMime.ISanitizer;
-    }
+    createDocumentationNode?(
+      activeItem: CompletionHandler.ICompletionItem
+    ): HTMLElement;
   }
 
   /**
    * The default implementation of an `IRenderer`.
    */
   export class Renderer implements IRenderer {
-    constructor(options?: Renderer.IOptions) {
-      this.sanitizer = options?.sanitizer || new Sanitizer();
-    }
-
-    /**
-     * The sanitizer used to sanitize untrusted HTML inputs.
-     */
-    readonly sanitizer: IRenderMime.ISanitizer;
+    constructor(readonly sanitizer: ISanitizer = defaultSanitizer) {}
 
     /**
      * Create an item node from an ICompletionItem for a text completer menu.
@@ -1210,13 +921,13 @@
       item: CompletionHandler.ICompletionItem,
       orderedTypes: string[]
     ): HTMLLIElement {
-      let wrapperNode = this._createWrapperNode(item.insertText || item.label);
+      let baseNode = this._createBaseNode(item.insertText || item.label);
       if (item.deprecated) {
-        wrapperNode.classList.add('jp-Completer-deprecated');
+        baseNode.classList.add('jp-Completer-deprecated');
       }
       return this._constructNode(
-        wrapperNode,
-        this._createLabelNode(item.label),
+        baseNode,
+        this._createMatchNode(item.label),
         !!item.type,
         item.type,
         orderedTypes,
@@ -1225,46 +936,37 @@
     }
 
     /**
+     * Create an item node for a text completer menu.
+     */
+    createItemNode(
+      item: IItem,
+      typeMap: TypeMap,
+      orderedTypes: string[]
+    ): HTMLLIElement {
+      return this._constructNode(
+        this._createBaseNode(item.raw),
+        this._createMatchNode(item.text),
+        !JSONExt.deepEqual(typeMap, {}),
+        typeMap[item.raw] || '',
+        orderedTypes
+      );
+    }
+
+    /**
      * Create a documentation node for documentation panel.
      */
     createDocumentationNode(
       activeItem: CompletionHandler.ICompletionItem
     ): HTMLElement {
-      const host = document.createElement('div');
-      host.classList.add('jp-RenderedText');
-      const sanitizer = this.sanitizer;
-      const source = activeItem.documentation || '';
-
-      renderText({ host, sanitizer, source }).catch(console.error);
-      return host;
-    }
-
-    /**
-     * Get a heuristic for the width of an item.
-     */
-    itemWidthHeuristic(item: CompletionHandler.ICompletionItem): number {
-      // Get the label text without HTML markup (`<mark>` is the only markup
-      // that is allowed in processed items, everything else gets escaped).
-      const labelText = item.label.replace(/<(\/)?mark>/g, '');
-      return labelText.length + (item.type?.length || 0);
-    }
-
-    /**
-     * Create a loading bar for the documentation panel.
-     */
-    createLoadingDocsIndicator(): HTMLElement {
-      const loadingContainer = document.createElement('div');
-      loadingContainer.classList.add('jp-Completer-loading-bar-container');
-      const loadingBar = document.createElement('div');
-      loadingBar.classList.add('jp-Completer-loading-bar');
-      loadingContainer.append(loadingBar);
-      return loadingContainer;
-    }
-
-    /**
-     * Create base node with the value to be inserted.
-     */
-    private _createWrapperNode(value: string): HTMLLIElement {
+      let pre = document.createElement('pre');
+      pre.textContent = activeItem.documentation || '';
+      return pre;
+    }
+
+    /**
+     * Create base node with the value to be inserted
+     */
+    private _createBaseNode(value: string): HTMLLIElement {
       const li = document.createElement('li');
       li.className = ITEM_CLASS;
       // Set the raw, un-marked up value as a data attribute.
@@ -1275,11 +977,13 @@
     /**
      * Create match node to highlight potential prefix match within result.
      */
-    private _createLabelNode(result: string): HTMLElement {
+    private _createMatchNode(result: string): HTMLElement {
       const matchNode = document.createElement('code');
       matchNode.className = 'jp-Completer-match';
       // Use innerHTML because search results include <mark> tags.
-      matchNode.innerHTML = result;
+      matchNode.innerHTML = this.sanitizer.sanitize(result, {
+        allowedTags: ['mark']
+      });
       return matchNode;
     }
 
@@ -1339,37 +1043,28 @@
   }
 
   /**
-   * Default renderer
+   * The default `IRenderer` instance.
+   *
+   * @deprecated Will be removed in v4 - you should use `getDefaultRenderer` instead.
+   */
+  export const defaultRenderer = new Renderer();
+
+  /**
+   * Default renderer with custom sanitizer.
    */
   let _defaultRenderer: Renderer;
 
   /**
    * The default `IRenderer` instance.
    */
-  export function getDefaultRenderer(
-    sanitizer?: IRenderMime.ISanitizer
-  ): Renderer {
+  export function getDefaultRenderer(sanitizer?: ISanitizer): Renderer {
     if (
       !_defaultRenderer ||
       (sanitizer && _defaultRenderer.sanitizer !== sanitizer)
     ) {
-      _defaultRenderer = new Renderer({ sanitizer: sanitizer });
+      _defaultRenderer = new Renderer(sanitizer);
     }
     return _defaultRenderer;
-  }
-
-  /**
-   * Pre-calculated dimensions of the completer widget box.
-   */
-  export interface IDimensions {
-    /**
-     * The total width including the documentation panel if visible.
-     */
-    width: number;
-    /**
-     * The total height of the visible part of the completer.
-     */
-    height: number;
   }
 }
 
@@ -1412,6 +1107,20 @@
       subset += ch;
     }
     return subset;
+  }
+
+  /**
+   * Returns the list of raw item values currently in the DOM.
+   */
+  export function itemValues(items: NodeList): string[] {
+    const values: string[] = [];
+    for (let i = 0, len = items.length; i < len; i++) {
+      const attr = (items[i] as HTMLElement).getAttribute('data-value');
+      if (attr) {
+        values.push(attr);
+      }
+    }
+    return values;
   }
 
   /**
@@ -1426,41 +1135,4 @@
       event.metaKey
     );
   }
-
-  /**
-   * Measure size of provided HTML element without painting it.
-   *
-   * #### Notes
-   * The provided element has to be detached (not connected to DOM),
-   * or a side-effect of detaching it will occur.
-   */
-  export function measureSize(element: HTMLElement, display: string): DOMRect {
-    if (element.isConnected) {
-      console.warn(
-        'Measuring connected elements with `measureSize` has side-effects'
-      );
-    }
-    element.style.visibility = 'hidden';
-    element.style.display = display;
-    document.body.appendChild(element);
-    const size = element.getBoundingClientRect();
-    document.body.removeChild(element);
-    element.removeAttribute('style');
-    return size;
-  }
-
-  export interface IDimensionsCache extends Completer.IDimensions {
-    /**
-     * The items for which the cache was most originally computed.
-     */
-    items: CompletionHandler.ICompletionItems;
-    /**
-     * The width of documentation panel.
-     */
-    docPanelWidth: number;
-    /**
-     * The height of documentation panel.
-     */
-    docPanelHeight: number;
-  }
 }