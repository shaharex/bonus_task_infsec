--- packages\extensionmanager\src\model.ts (old)
+++ packages\extensionmanager\src\model.ts (new)
@@ -1,16 +1,26 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
-/* global RequestInit */
-
-import { Dialog, showDialog } from '@jupyterlab/apputils';
-import { PageConfig, URLExt } from '@jupyterlab/coreutils';
-import { ServerConnection, ServiceManager } from '@jupyterlab/services';
+import { JupyterFrontEnd } from '@jupyterlab/application';
+import { VDomModel } from '@jupyterlab/apputils';
+import {
+  KernelSpec,
+  ServerConnection,
+  ServiceManager
+} from '@jupyterlab/services';
+import { ISettingRegistry } from '@jupyterlab/settingregistry';
 import { ITranslator, nullTranslator } from '@jupyterlab/translation';
-import { VDomModel } from '@jupyterlab/ui-components';
 import { Debouncer } from '@lumino/polling';
 import * as semver from 'semver';
+import { doBuild } from './build-helper';
+import {
+  IKernelInstallInfo,
+  KernelCompanion,
+  presentCompanions
+} from './companions';
 import { reportInstallError } from './dialog';
+import { IListEntry, Lister, ListResult } from './listings';
+import { ISearchResult, isJupyterOrg, Searcher } from './npm';
 
 /**
  * Information about an extension.
@@ -29,22 +39,12 @@
   /**
    * A representative link of the package.
    */
-  homepage_url: string;
+  url: string;
 
   /**
    * Whether the extension is currently installed.
    */
-  installed?: boolean | null;
-
-  /**
-   * Whether the extension is allowed or not.
-   */
-  allowed: boolean;
-
-  /**
-   * Whether the extension is approved by the system administrators.
-   */
-  approved: boolean;
+  installed: boolean;
 
   /**
    * Whether the extension is currently enabled.
@@ -52,6 +52,11 @@
   enabled: boolean;
 
   /**
+   * A flag indicating the status of an installed extension.
+   */
+  status: 'ok' | 'warning' | 'error' | 'deprecated' | null;
+
+  /**
    * The latest version of the extension.
    */
   latest_version: string;
@@ -61,10 +66,9 @@
    */
   installed_version: string;
 
-  /**
-   * A flag indicating the status of an installed extension.
-   */
-  status: 'ok' | 'warning' | 'error' | 'deprecated' | null;
+  blockedExtensionsEntry: IListEntry | undefined;
+
+  allowedExtensionsEntry: IListEntry | undefined;
 
   /**
    * The package type (prebuilt or source).
@@ -74,37 +78,7 @@
   /**
    * The information about extension installation.
    */
-  install?: IInstall | null;
-
-  /**
-   * Package author.
-   */
-  author?: string;
-
-  /**
-   * Package license.
-   */
-  license?: string;
-
-  /**
-   * URL to the package bug tracker.
-   */
-  bug_tracker_url?: string;
-
-  /**
-   * URL to the package documentation.
-   */
-  documentation_url?: string;
-
-  /**
-   * URL to the package URL in the packager website.
-   */
-  package_manager_url?: string;
-
-  /**
-   * URL to the package code source.
-   */
-  repository_url?: string;
+  install: IInstall | undefined;
 }
 
 /**
@@ -129,6 +103,82 @@
 }
 
 /**
+ * Wire format for installed extensions.
+ */
+export interface IInstalledEntry {
+  /**
+   * The name of the extension.
+   */
+  name: string;
+
+  /**
+   * A short description of the extension.
+   */
+  description: string;
+
+  /**
+   * A representative link of the package.
+   */
+  url: string;
+
+  /**
+   * Whether the extension is currently installed.
+   */
+  installed?: boolean;
+
+  /**
+   * Whether the extension is currently enabled.
+   */
+  enabled: boolean;
+
+  /**
+   * The latest version of the extension.
+   */
+  latest_version: string;
+
+  /**
+   * The installed version of the extension.
+   */
+  installed_version: string;
+
+  /**
+   * A flag indicating the status of an installed extension.
+   */
+  status: 'ok' | 'warning' | 'error' | 'deprecated' | null;
+
+  /**
+   * The package type (prebuilt or source).
+   */
+  pkg_type: 'prebuilt' | 'source';
+
+  /**
+   * The information about extension installation.
+   */
+  install: IInstallEntry | undefined;
+}
+
+/**
+ * Information about extension installation.
+ */
+export interface IInstallEntry {
+  /**
+   * The used package manager (e.g. pip, conda...)
+   */
+  packageManager: string | undefined;
+
+  /**
+   * The package name as known by the package manager.
+   */
+  packageName: string | undefined;
+
+  /**
+   * The uninstallation instructions as a comprehensive
+   * text for the end user.
+   */
+  uninstallInstructions: string | undefined;
+}
+
+/**
  * An object representing a server reply to performing an action.
  */
 export interface IActionReply {
@@ -141,29 +191,6 @@
    * An optional message when the status is not 'ok'.
    */
   message?: string;
-
-  /**
-   * Follow-up restart needed by the action
-   */
-  needs_restart: ('frontend' | 'kernel' | 'server')[];
-}
-
-/**
- * Extension manager metadata
- */
-interface IExtensionManagerMetadata {
-  /**
-   * Extension manager name.
-   */
-  name: string;
-  /**
-   * Whether the extension manager can un-/install extensions.
-   */
-  can_install: boolean;
-  /**
-   * Extensions installation path.
-   */
-  install_path: string | null;
 }
 
 /**
@@ -175,59 +202,73 @@
  * Extension actions that the server API accepts
  */
 export type Action = 'install' | 'uninstall' | 'enable' | 'disable';
-
-/**
- * Additional options for an action.
- */
-export interface IActionOptions {
-  /**
-   * Install the version of the entry.
-   *
-   * #### Note
-   * This is ignored by all actions except install.
-   */
-  useVersion?: string;
-}
 
 /**
  * Model for an extension list.
  */
 export class ListModel extends VDomModel {
   constructor(
-    serviceManager: ServiceManager.IManager,
+    app: JupyterFrontEnd,
+    serviceManager: ServiceManager,
+    settings: ISettingRegistry.ISettings,
     translator?: ITranslator
   ) {
     super();
-
-    const metadata = JSON.parse(
-      // The page config option may not be defined; e.g. in the federated example
-      PageConfig.getOption('extensionManager') || '{}'
-    ) as IExtensionManagerMetadata;
-
-    this.name = metadata.name;
-    this.canInstall = metadata.can_install;
-    this.installPath = metadata.install_path;
     this.translator = translator || nullTranslator;
+    this._app = app;
     this._installed = [];
-    this._lastSearchResult = [];
+    this._searchResult = [];
     this.serviceManager = serviceManager;
-    this._debouncedSearch = new Debouncer(this.search.bind(this), 1000);
-  }
-
-  /**
-   * Extension manager name.
-   */
-  readonly name: string;
-
-  /**
-   * Whether the extension manager support installation methods or not.
-   */
-  readonly canInstall: boolean;
-
-  /**
-   * Extensions installation path.
-   */
-  installPath: string | null;
+    this.serverConnectionSettings = ServerConnection.makeSettings();
+    this._debouncedUpdate = new Debouncer(this.update.bind(this), 1000);
+    this.lister.listingsLoaded.connect(this._listingIsLoaded, this);
+    this.searcher = new Searcher(
+      settings.composite['npmRegistry'] as string,
+      settings.composite['npmCdn'] as string,
+      settings.composite['enableCdn'] as boolean
+    );
+    _isDisclaimed = settings.composite['disclaimed'] === true;
+    settings.changed.connect(() => {
+      _isDisclaimed = settings.composite['disclaimed'] === true;
+      this.searcher = new Searcher(
+        settings.composite['npmRegistry'] as string,
+        settings.composite['npmCdn'] as string,
+        settings.composite['enableCdn'] as boolean
+      );
+      void this.update();
+    });
+  }
+
+  private _listingIsLoaded(_: Lister, listings: ListResult) {
+    this._listMode = listings!.mode;
+    this._blockedExtensionsArray = new Array<IListEntry>();
+    if (this._listMode === 'block') {
+      listings!.entries.map(e => {
+        this._blockedExtensionsArray.push({
+          name: e.name,
+          regexp: new RegExp(e.name),
+          type: e.type,
+          reason: e.reason,
+          creation_date: e.creation_date,
+          last_update_date: e.last_update_date
+        });
+      });
+    }
+    this._allowedExtensionsArray = new Array<IListEntry>();
+    if (this._listMode === 'allow') {
+      listings!.entries.map(e => {
+        this._allowedExtensionsArray.push({
+          name: e.name,
+          regexp: new RegExp(e.name),
+          type: e.type,
+          reason: e.reason,
+          creation_date: e.creation_date,
+          last_update_date: e.last_update_date
+        });
+      });
+    }
+    void this.initialize();
+  }
 
   /**
    * A readonly array of the installed extensions.
@@ -237,83 +278,46 @@
   }
 
   /**
-   * Whether the warning is disclaimed or not.
-   */
-  get isDisclaimed(): boolean {
-    return this._isDisclaimed;
-  }
-  set isDisclaimed(v: boolean) {
-    if (v !== this._isDisclaimed) {
-      this._isDisclaimed = v;
-      this.stateChanged.emit();
-      void this._debouncedSearch.invoke();
-    }
-  }
-
-  /**
-   * Whether the extension manager is enabled or not.
-   */
-  get isEnabled(): boolean {
-    return this._isEnabled;
-  }
-  set isEnabled(v: boolean) {
-    if (v !== this._isEnabled) {
-      this._isEnabled = v;
-      this.stateChanged.emit();
-    }
-  }
-
-  get isLoadingInstalledExtensions(): boolean {
-    return this._isLoadingInstalledExtensions;
-  }
-
-  get isSearching(): boolean {
-    return this._isSearching;
-  }
-
-  /**
    * A readonly array containing the latest search result
    */
   get searchResult(): ReadonlyArray<IEntry> {
-    return this._lastSearchResult;
-  }
-
-  /**
-   * The search query.
+    return this._searchResult;
+  }
+
+  /**
+   * The current NPM repository search query.
    *
    * Setting its value triggers a new search.
    */
-  get query(): string {
+  get query(): string | null {
     return this._query;
   }
-  set query(value: string) {
-    if (this._query !== value) {
-      this._query = value;
-      this._page = 1;
-      void this._debouncedSearch.invoke();
-    }
-  }
-
-  /**
-   * The current search page.
+  set query(value: string | null) {
+    this._query = value;
+    void this._debouncedUpdate.invoke();
+  }
+
+  /**
+   * The current NPM repository search page.
+   *
+   * The npm repository search is paginated by the `pagination` attribute.
+   * The `page` value selects which page is used.
    *
    * Setting its value triggers a new search.
-   *
-   * ### Note
-   * First page is 1.
    */
   get page(): number {
     return this._page;
   }
   set page(value: number) {
-    if (this._page !== value) {
-      this._page = value;
-      void this._debouncedSearch.invoke();
-    }
-  }
-
-  /**
-   * The search pagination.
+    this._page = value;
+    void this.update();
+  }
+
+  /**
+   * The NPM repository search pagination.
+   *
+   * The npm repository search is paginated by the `pagination` attribute.
+   * The `page` value selects which page is used.
    *
    * Setting its value triggers a new search.
    */
@@ -321,17 +325,36 @@
     return this._pagination;
   }
   set pagination(value: number) {
-    if (this._pagination !== value) {
-      this._pagination = value;
-      void this._debouncedSearch.invoke();
-    }
-  }
-
-  /**
-   * The last page of results in the current search.
-   */
-  get lastPage(): number {
-    return this._lastPage;
+    this._pagination = value;
+    void this.update();
+  }
+
+  /**
+   * The total number of results in the current search.
+   */
+  get totalEntries(): number {
+    return this._totalEntries;
+  }
+
+  /**
+   * The list mode.
+   */
+  get listMode(): 'block' | 'allow' | 'default' | 'invalid' {
+    return this._listMode;
+  }
+
+  /**
+   * The total number of blockedExtensions results in the current search.
+   */
+  get totalblockedExtensionsFound(): number {
+    return this._totalblockedExtensionsFound;
+  }
+
+  /**
+   * The total number of allowedExtensions results in the current search.
+   */
+  get totalallowedExtensionsFound(): number {
+    return this._totalallowedExtensionsFound;
   }
 
   /**
@@ -341,8 +364,23 @@
     if (this.isDisposed) {
       return;
     }
-    this._debouncedSearch.dispose();
+    this._debouncedUpdate.dispose();
     super.dispose();
+  }
+
+  /**
+   * Initialize the model.
+   */
+  initialize(): Promise<void> {
+    return this.update()
+      .then(() => {
+        this.initialized = true;
+        this.stateChanged.emit(undefined);
+      })
+      .catch(() => {
+        this.initialized = true;
+        this.stateChanged.emit(undefined);
+      });
   }
 
   /**
@@ -356,17 +394,26 @@
    * Install an extension.
    *
    * @param entry An entry indicating which extension to install.
-   * @param options Additional options for the action.
-   */
-  async install(
-    entry: IEntry,
-    options: { useVersion?: string } = {}
-  ): Promise<void> {
-    await this.performAction('install', entry, options).then(data => {
-      if (data.status !== 'ok') {
-        reportInstallError(entry.name, data.message, this.translator);
-      }
-      return this.update(true);
+   */
+  async install(entry: IEntry): Promise<void> {
+    if (entry.installed) {
+      // Updating
+      await this._performAction('install', entry).then(data => {
+        if (data.status !== 'ok') {
+          reportInstallError(entry.name, data.message, this.translator);
+        }
+        return this.update();
+      });
+    }
+    await this.checkCompanionPackages(entry).then(shouldInstall => {
+      if (shouldInstall) {
+        return this._performAction('install', entry).then(data => {
+          if (data.status !== 'ok') {
+            reportInstallError(entry.name, data.message, this.translator);
+          }
+          return this.update();
+        });
+      }
     });
   }
 
@@ -379,8 +426,8 @@
     if (!entry.installed) {
       throw new Error(`Not installed, cannot uninstall: ${entry.name}`);
     }
-    await this.performAction('uninstall', entry);
-    return this.update(true);
+    await this._performAction('uninstall', entry);
+    return this.update();
   }
 
   /**
@@ -392,8 +439,8 @@
     if (entry.enabled) {
       throw new Error(`Already enabled: ${entry.name}`);
     }
-    await this.performAction('enable', entry);
-    await this.refreshInstalled(true);
+    await this._performAction('enable', entry);
+    await this.update();
   }
 
   /**
@@ -405,91 +452,337 @@
     if (!entry.enabled) {
       throw new Error(`Already disabled: ${entry.name}`);
     }
-    await this.performAction('disable', entry);
-    await this.refreshInstalled(true);
-  }
-
-  /**
-   * Refresh installed packages
-   *
-   * @param force Force refreshing the list of installed packages
-   */
-  async refreshInstalled(force = false): Promise<void> {
-    this.installedError = null;
-    this._isLoadingInstalledExtensions = true;
-    this.stateChanged.emit();
+    await this._performAction('disable', entry);
+    await this.update();
+  }
+
+  /**
+   * Check for companion packages in kernels or server.
+   *
+   * @param entry An entry indicating which extension to check.
+   */
+  checkCompanionPackages(entry: IEntry): Promise<boolean> {
+    return this.searcher
+      .fetchPackageData(entry.name, entry.latest_version)
+      .then(data => {
+        if (!data || !data.jupyterlab || !data.jupyterlab.discovery) {
+          return true;
+        }
+        const discovery = data.jupyterlab.discovery;
+        const kernelCompanions: KernelCompanion[] = [];
+        if (discovery.kernel) {
+          // match specs
+          for (const kernelInfo of discovery.kernel) {
+            const matches = Private.matchSpecs(
+              kernelInfo,
+              this.serviceManager.kernelspecs.specs
+            );
+            kernelCompanions.push({ kernelInfo, kernels: matches });
+          }
+        }
+        if (kernelCompanions.length < 1 && !discovery.server) {
+          return true;
+        }
+        return presentCompanions(
+          kernelCompanions,
+          discovery.server,
+          this.translator
+        );
+      });
+  }
+
+  /**
+   * Trigger a build check to incorporate actions taken.
+   */
+  triggerBuildCheck(): void {
+    const builder = this.serviceManager.builder;
+    if (builder.isAvailable && !this.promptBuild) {
+      const completed = builder.getStatus().then(response => {
+        if (response.status === 'building') {
+          // Piggy-back onto existing build
+          // TODO: Can this cause dialog collision on build completion?
+          return doBuild(this._app, builder);
+        }
+        if (response.status !== 'needed') {
+          return;
+        }
+        if (!this.promptBuild) {
+          this.promptBuild = true;
+          this.stateChanged.emit(undefined);
+        }
+      });
+      this._addPendingAction(completed);
+    }
+  }
+
+  /**
+   * Perform a build on the server
+   */
+  performBuild(): void {
+    if (this.promptBuild) {
+      this.promptBuild = false;
+      this.stateChanged.emit(undefined);
+    }
+    const completed = doBuild(this._app, this.serviceManager.builder);
+    this._addPendingAction(completed);
+  }
+
+  /**
+   * Ignore a build recommendation
+   */
+  ignoreBuildRecommendation(): void {
+    if (this.promptBuild) {
+      this.promptBuild = false;
+      this.stateChanged.emit(undefined);
+    }
+  }
+
+  /**
+   * Ignore a build recommendation
+   */
+  refreshInstalled(): void {
+    const refresh = this.update(true);
+    this._addPendingAction(refresh);
+  }
+
+  /**
+   * Translate search results from an npm repository query into entries
+   * and remove entries with 'deprecated' in the keyword list
+   *
+   * @param res Promise to an npm query result.
+   */
+  protected async translateSearchResult(
+    res: Promise<ISearchResult>
+  ): Promise<{ [key: string]: IEntry }> {
+    const entries: { [key: string]: IEntry } = {};
+    this._totalblockedExtensionsFound = 0;
+    this._totalallowedExtensionsFound = 0;
+    this._totalEntries = 0;
+    for (const obj of (await res).objects) {
+      const pkg = obj.package;
+      if (pkg.keywords.indexOf('deprecated') >= 0) {
+        continue;
+      }
+      this._totalEntries = this._totalEntries + 1;
+      const isblockedExtensions = this.isListed(
+        pkg.name,
+        this._blockedExtensionsArray
+      );
+      if (isblockedExtensions) {
+        this._totalblockedExtensionsFound =
+          this._totalblockedExtensionsFound + 1;
+      }
+      const isallowedExtensions = this.isListed(
+        pkg.name,
+        this._allowedExtensionsArray
+      );
+      if (isallowedExtensions) {
+        this._totalallowedExtensionsFound =
+          this._totalallowedExtensionsFound + 1;
+      }
+      entries[pkg.name] = {
+        name: pkg.name,
+        description: pkg.description,
+        url:
+          'homepage' in pkg.links
+            ? pkg.links.homepage
+            : 'repository' in pkg.links
+            ? pkg.links.repository
+            : pkg.links.npm,
+        installed: false,
+        enabled: false,
+        status: null,
+        latest_version: pkg.version,
+        installed_version: '',
+        blockedExtensionsEntry: isblockedExtensions,
+        allowedExtensionsEntry: isallowedExtensions,
+        pkg_type: 'source',
+        install: undefined
+      };
+    }
+    return entries;
+  }
+
+  /**
+   * Translate installed extensions information from the server into entries.
+   *
+   * @param res Promise to the server reply data.
+   */
+  protected async translateInstalled(
+    res: Promise<IInstalledEntry[]>
+  ): Promise<{ [key: string]: IEntry }> {
+    const promises = [];
+    const entries: { [key: string]: IEntry } = {};
+    for (const pkg of await res) {
+      promises.push(
+        res.then(info => {
+          entries[pkg.name] = {
+            name: pkg.name,
+            description: pkg.description,
+            url: pkg.url,
+            installed: pkg.installed !== false,
+            enabled: pkg.enabled,
+            status: pkg.status,
+            latest_version: pkg.latest_version,
+            installed_version: pkg.installed_version,
+            blockedExtensionsEntry: this.isListed(
+              pkg.name,
+              this._blockedExtensionsArray
+            ),
+            allowedExtensionsEntry: this.isListed(
+              pkg.name,
+              this._allowedExtensionsArray
+            ),
+            pkg_type: pkg.pkg_type,
+            install: {
+              packageManager: pkg.install?.packageManager,
+              packageName: pkg.install?.packageName,
+              uninstallInstructions: pkg.install?.uninstallInstructions
+            }
+          };
+        })
+      );
+    }
+    return Promise.all(promises).then(() => {
+      return entries;
+    });
+  }
+
+  private isListed(
+    name: string,
+    listArray: Array<IListEntry>
+  ): IListEntry | undefined {
+    let entry: IListEntry | undefined = undefined;
+    listArray.forEach((listEntry: IListEntry) => {
+      if (listEntry.regexp && listEntry.regexp?.test(name)) {
+        entry = listEntry;
+      }
+    });
+    return entry;
+  }
+
+  /**
+   * Make a request to the server for info about its installed extensions.
+   */
+  protected fetchInstalled(
+    refreshInstalled = false
+  ): Promise<IInstalledEntry[]> {
+    const url = new URL(
+      EXTENSION_API_PATH,
+      this.serverConnectionSettings.baseUrl
+    );
+    if (refreshInstalled) {
+      url.searchParams.append('refresh', '1');
+    }
+    const request = ServerConnection.makeRequest(
+      url.toString(),
+      {},
+      this.serverConnectionSettings
+    ).then(response => {
+      Private.handleError(response);
+      return response.json() as Promise<IInstalledEntry[]>;
+    });
+    request.then(
+      () => {
+        this.serverConnectionError = null;
+      },
+      reason => {
+        this.serverConnectionError = reason.toString();
+      }
+    );
+    return request;
+  }
+
+  /**
+   * Search with current query.
+   *
+   * Sets searchError and totalEntries as appropriate.
+   *
+   * @returns {Promise<{ [key: string]: IEntry; }>} The search result as a map of entries.
+   */
+  protected async performSearch(): Promise<{ [key: string]: IEntry }> {
+    if (this.query === null) {
+      this.query = '';
+    }
+
+    // Start the search without waiting for it:
+    const search = this.searcher.searchExtensions(
+      this.query,
+      this.page,
+      this.pagination
+    );
+    const searchMapPromise = this.translateSearchResult(search);
+
+    let searchMap: { [key: string]: IEntry };
     try {
-      const [extensions] = await Private.requestAPI<IEntry[]>({
-        refresh: force ? 1 : 0
-      });
-      this._installed = extensions.sort(Private.comparator);
+      searchMap = await searchMapPromise;
+      this.searchError = null;
     } catch (reason) {
+      searchMap = {};
+      this.searchError = reason.toString();
+    }
+
+    return searchMap;
+  }
+
+  /**
+   * Query the installed extensions.
+   *
+   * Sets installedError as appropriate.
+   *
+   * @returns {Promise<{ [key: string]: IEntry; }>} A map of installed extensions.
+   */
+  protected async queryInstalled(
+    refreshInstalled: boolean
+  ): Promise<{ [key: string]: IEntry }> {
+    let installedMap;
+    try {
+      installedMap = await this.translateInstalled(
+        this.fetchInstalled(refreshInstalled)
+      );
+      this.installedError = null;
+    } catch (reason) {
+      installedMap = {};
       this.installedError = reason.toString();
-    } finally {
-      this._isLoadingInstalledExtensions = false;
-      this.stateChanged.emit();
-    }
-  }
-
-  /**
-   * Search with current query.
-   *
-   * Sets searchError and totalEntries as appropriate.
-   *
-   * @returns The extensions matching the current query.
-   */
-  protected async search(force = false): Promise<void> {
-    if (!this.isDisclaimed) {
-      return Promise.reject('Installation warning is not disclaimed.');
-    }
-
-    this.searchError = null;
-    this._isSearching = true;
-    this.stateChanged.emit();
-    try {
-      const [extensions, links] = await Private.requestAPI<IEntry[]>({
-        query: this.query ?? '',
-        page: this.page,
-        per_page: this.pagination,
-        refresh: force ? 1 : 0
-      });
-
-      const lastURL = links['last'];
-      if (lastURL) {
-        const lastPage = URLExt.queryStringToObject(
-          URLExt.parse(lastURL).search ?? ''
-        )['page'];
-
-        if (lastPage) {
-          this._lastPage = parseInt(lastPage, 10);
+    }
+    return installedMap;
+  }
+
+  /**
+   * Update the current model.
+   *
+   * This will query the NPM repository, and the notebook server.
+   *
+   * Emits the `stateChanged` signal on successful completion.
+   */
+  protected async update(refreshInstalled = false) {
+    if (ListModel.isDisclaimed()) {
+      const [searchMap, installedMap] = await Promise.all([
+        this.performSearch(),
+        this.queryInstalled(refreshInstalled)
+      ]);
+
+      // Map results to attributes:
+      const installed: IEntry[] = [];
+      for (const key of Object.keys(installedMap)) {
+        installed.push(installedMap[key]);
+      }
+      this._installed = installed.sort(Private.comparator);
+
+      const searchResult: IEntry[] = [];
+      for (const key of Object.keys(searchMap)) {
+        // Filter out installed entries from search results:
+        if (installedMap[key] === undefined) {
+          searchResult.push(searchMap[key]);
+        } else {
+          searchResult.push(installedMap[key]);
         }
       }
-
-      const installedNames = this._installed.map(pkg => pkg.name);
-      this._lastSearchResult = extensions
-        .filter(pkg => !installedNames.includes(pkg.name))
-        .sort(Private.comparator);
-    } catch (reason) {
-      this.searchError = reason.toString();
-    } finally {
-      this._isSearching = false;
-      this.stateChanged.emit();
-    }
-  }
-
-  /**
-   * Update the current model.
-   *
-   * This will query the packages repository, and the notebook server.
-   *
-   * Emits the `stateChanged` signal on successful completion.
-   */
-  protected async update(force = false): Promise<void> {
-    if (this.isDisclaimed) {
-      // First refresh the installed list - so the search results are correctly filtered
-      await this.refreshInstalled(force);
-      await this.search();
-    }
+      this._searchResult = searchResult.sort(Private.comparator);
+    }
+
+    // Signal updated state
+    this.stateChanged.emit(undefined);
   }
 
   /**
@@ -497,73 +790,41 @@
    *
    * @param action A valid action to perform.
    * @param entry The extension to perform the action on.
-   * @param actionOptions Additional options for the action.
-   */
-  protected performAction(
+   */
+  protected _performAction(
     action: string,
-    entry: IEntry,
-    actionOptions: IActionOptions = {}
+    entry: IEntry
   ): Promise<IActionReply> {
-    const bodyJson: Record<string, string> = {
-      cmd: action,
-      extension_name: entry.name
+    const url = new URL(
+      EXTENSION_API_PATH,
+      this.serverConnectionSettings.baseUrl
+    );
+    const request: RequestInit = {
+      method: 'POST',
+      body: JSON.stringify({
+        cmd: action,
+        extension_name: entry.name
+      })
     };
-
-    if (actionOptions.useVersion) {
-      bodyJson['extension_version'] = actionOptions.useVersion;
-    }
-
-    const actionRequest = Private.requestAPI<IActionReply>(
-      {},
-      {
-        method: 'POST',
-        body: JSON.stringify(bodyJson)
-      }
-    );
-
-    actionRequest.then(
-      ([reply]) => {
-        const trans = this.translator.load('jupyterlab');
-        if (reply.needs_restart.includes('server')) {
-          void showDialog({
-            title: trans.__('Information'),
-            body: trans.__(
-              'You will need to restart JupyterLab to apply the changes.'
-            ),
-            buttons: [Dialog.okButton({ label: trans.__('Ok') })]
-          });
-        } else {
-          const followUps: string[] = [];
-          if (reply.needs_restart.includes('frontend')) {
-            followUps.push(
-              // @ts-expect-error isElectron is not a standard attribute
-              window.isElectron
-                ? trans.__('reload JupyterLab')
-                : trans.__('refresh the web page')
-            );
-          }
-          if (reply.needs_restart.includes('kernel')) {
-            followUps.push(
-              trans.__('install the extension in all kernels and restart them')
-            );
-          }
-          void showDialog({
-            title: trans.__('Information'),
-            body: trans.__(
-              'You will need to %1 to apply the changes.',
-              followUps.join(trans.__(' and '))
-            ),
-            buttons: [Dialog.okButton({ label: trans.__('Ok') })]
-          });
-        }
-        this.actionError = null;
+    const completed = ServerConnection.makeRequest(
+      url.toString(),
+      request,
+      this.serverConnectionSettings
+    ).then(response => {
+      Private.handleError(response);
+      this.triggerBuildCheck();
+      return response.json() as Promise<IActionReply>;
+    });
+    completed.then(
+      () => {
+        this.serverConnectionError = null;
       },
       reason => {
-        this.actionError = reason.toString();
+        this.serverConnectionError = reason.toString();
       }
     );
-    this.addPendingAction(actionRequest);
-    return actionRequest.then(([reply]) => reply);
+    this._addPendingAction(completed);
+    return completed;
   }
 
   /**
@@ -571,7 +832,7 @@
    *
    * @param pending A promise that resolves when the action is completed.
    */
-  protected addPendingAction(pending: Promise<any>): void {
+  protected _addPendingAction(pending: Promise<any>): void {
     // Add to pending actions collection
     this._pendingActions.push(pending);
 
@@ -587,8 +848,6 @@
     this.stateChanged.emit(undefined);
   }
 
-  actionError: string | null = null;
-
   /**
    * Contains an error message if an error occurred when querying installed extensions.
    */
@@ -600,32 +859,67 @@
   searchError: string | null = null;
 
   /**
-   * Whether a reload should be considered due to actions taken.
-   */
-  promptReload = false;
+   * Contains an error message if an error occurred when searching for lists.
+   */
+  blockedExtensionsError: string | null = null;
+
+  /**
+   * Contains an error message if an error occurred when querying the server extension.
+   */
+  serverConnectionError: string | null = null;
+
+  /**
+   * Contains an error message if the server has unfulfilled requirements.
+   */
+  serverRequirementsError: string | null = null;
+
+  /**
+   * Whether the model has finished async initialization.
+   */
+  initialized: boolean = false;
+
+  /**
+   * Whether a fresh build should be considered due to actions taken.
+   */
+  promptBuild: boolean = false;
+
+  /**
+   * Settings for connecting to the notebook server.
+   */
+  protected serverConnectionSettings: ServerConnection.ISettings;
+
+  /**
+   * A helper for performing searches of jupyterlab extensions on the NPM repository.
+   */
+  protected searcher: Searcher;
+
+  protected lister = new Lister();
 
   /**
    * The service manager to use for building.
    */
-  protected serviceManager: ServiceManager.IManager;
+  protected serviceManager: ServiceManager;
 
   protected translator: ITranslator;
-
-  private _isDisclaimed = false;
-  private _isEnabled = false;
-  private _isLoadingInstalledExtensions = false;
-  private _isSearching = false;
-
-  private _query: string = '';
-  private _page: number = 1;
-  private _pagination: number = 30;
-  private _lastPage: number = 1;
+  private _app: JupyterFrontEnd;
+  private _query: string | null = ''; // TODO: we may not need the null case?
+  private _page: number = 0;
+  private _pagination: number = 250;
+  private _totalEntries: number = 0;
 
   private _installed: IEntry[];
-  private _lastSearchResult: IEntry[];
+  private _searchResult: IEntry[];
   private _pendingActions: Promise<any>[] = [];
-  private _debouncedSearch: Debouncer<void, void>;
+  private _debouncedUpdate: Debouncer<void, void>;
+
+  private _listMode: 'block' | 'allow' | 'default' | 'invalid';
+  private _blockedExtensionsArray: Array<IListEntry>;
+  private _allowedExtensionsArray: Array<IListEntry>;
+  private _totalblockedExtensionsFound: number = 0;
+  private _totalallowedExtensionsFound: number = 0;
 }
+
+let _isDisclaimed = false;
 
 /**
  * ListModel statics.
@@ -642,6 +936,14 @@
     }
     return semver.lt(entry.installed_version, entry.latest_version);
   }
+
+  export function isDisclaimed() {
+    return _isDisclaimed;
+  }
+
+  export function toogleDisclaimed() {
+    _isDisclaimed = !_isDisclaimed;
+  }
 }
 
 /**
@@ -654,63 +956,69 @@
   export function comparator(a: IEntry, b: IEntry): number {
     if (a.name === b.name) {
       return 0;
+    }
+
+    const testA = isJupyterOrg(a.name);
+    const testB = isJupyterOrg(b.name);
+
+    if (testA === testB) {
+      // Retain sort-order from API
+      return 0;
+    } else if (testA && !testB) {
+      return -1;
     } else {
-      return a.name > b.name ? 1 : -1;
-    }
-  }
-
-  const LINK_PARSER = /<([^>]+)>; rel="([^"]+)",?/g;
-
-  /**
-   * Call the API extension
-   *
-   * @param queryArgs Query arguments
-   * @param init Initial values for the request
-   * @returns The response body interpreted as JSON and the response link header
-   */
-  export async function requestAPI<T>(
-    queryArgs: { [k: string]: any } = {},
-    init: RequestInit = {}
-  ): Promise<[T, { [key: string]: string }]> {
-    // Make request to Jupyter API
-    const settings = ServerConnection.makeSettings();
-    const requestUrl = URLExt.join(
-      settings.baseUrl,
-      EXTENSION_API_PATH // API Namespace
-    );
-
-    let response: Response;
-    try {
-      response = await ServerConnection.makeRequest(
-        requestUrl + URLExt.objectToQueryString(queryArgs),
-        init,
-        settings
-      );
-    } catch (error) {
-      throw new ServerConnection.NetworkError(error);
-    }
-
-    let data: any = await response.text();
-
-    if (data.length > 0) {
-      try {
-        data = JSON.parse(data);
-      } catch (error) {
-        console.log('Not a JSON response body.', response);
-      }
-    }
-
+      return 1;
+    }
+  }
+
+  /**
+   * Match kernel specs against kernel spec regexps
+   *
+   * @param kernelInfo The info containing the regexp patterns
+   * @param specs The available kernel specs.
+   */
+  export function matchSpecs(
+    kernelInfo: IKernelInstallInfo,
+    specs: KernelSpec.ISpecModels | null
+  ): KernelSpec.ISpecModel[] {
+    if (!specs) {
+      return [];
+    }
+    const matches: KernelSpec.ISpecModel[] = [];
+    let reLang: RegExp | null = null;
+    let reName: RegExp | null = null;
+    if (kernelInfo.kernel_spec.language) {
+      reLang = new RegExp(kernelInfo.kernel_spec.language);
+    }
+    if (kernelInfo.kernel_spec.display_name) {
+      reName = new RegExp(kernelInfo.kernel_spec.display_name);
+    }
+    for (const key of Object.keys(specs.kernelspecs)) {
+      const spec = specs.kernelspecs[key]!;
+      let match = false;
+      if (reLang) {
+        match = reLang.test(spec.language);
+      }
+      if (!match && reName) {
+        match = reName.test(spec.display_name);
+      }
+      if (match) {
+        matches.push(spec);
+        continue;
+      }
+    }
+    return matches;
+  }
+
+  /**
+   * Convert a response to an exception on error.
+   *
+   * @param response The response to inspect.
+   */
+  export function handleError(response: Response): Response {
     if (!response.ok) {
-      throw new ServerConnection.ResponseError(response, data.message || data);
-    }
-
-    const link = response.headers.get('Link') ?? '';
-
-    const links: { [key: string]: string } = {};
-    let match: RegExpExecArray | null = null;
-    while ((match = LINK_PARSER.exec(link)) !== null) {
-      links[match[2]] = match[1];
-    }
-    return [data, links];
+      throw new Error(`${response.status} (${response.statusText})`);
+    }
+    return response;
   }
 }