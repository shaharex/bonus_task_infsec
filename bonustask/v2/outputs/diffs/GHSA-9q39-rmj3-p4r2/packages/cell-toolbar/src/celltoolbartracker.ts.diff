--- packages\cell-toolbar\src\celltoolbartracker.ts (old)
+++ packages\cell-toolbar\src\celltoolbartracker.ts (new)
@@ -4,26 +4,18 @@
 |----------------------------------------------------------------------------*/
 import {
   createDefaultFactory,
-  setToolbar,
+  Toolbar,
   ToolbarRegistry
 } from '@jupyterlab/apputils';
-import {
-  Cell,
-  CellModel,
-  CodeCell,
-  ICellModel,
-  MarkdownCell
-} from '@jupyterlab/cells';
+import { Cell, CodeCell, ICellModel, MarkdownCell } from '@jupyterlab/cells';
 import { DocumentRegistry } from '@jupyterlab/docregistry';
 import { Notebook, NotebookPanel } from '@jupyterlab/notebook';
 import { IObservableList, ObservableList } from '@jupyterlab/observables';
-import { ReactWidget, Toolbar } from '@jupyterlab/ui-components';
-import { some } from '@lumino/algorithm';
+import { each, toArray } from '@lumino/algorithm';
 import { CommandRegistry } from '@lumino/commands';
 import { IDisposable } from '@lumino/disposable';
 import { Signal } from '@lumino/signaling';
 import { PanelLayout, Widget } from '@lumino/widgets';
-import { IMapChange } from '@jupyter/ydoc';
 
 /*
  * Text mime types
@@ -38,7 +30,6 @@
  * Widget cell toolbar classes
  */
 const CELL_TOOLBAR_CLASS = 'jp-cell-toolbar';
-// @deprecated to be removed
 const CELL_MENU_CLASS = 'jp-cell-menu';
 
 /**
@@ -50,102 +41,45 @@
  * Watch a notebook so that a cell toolbar appears on the active cell
  */
 export class CellToolbarTracker implements IDisposable {
-  /**
-   * CellToolbarTracker constructor
-   *
-   * @param panel The notebook panel
-   * @param toolbar The toolbar; deprecated use {@link toolbarFactory} instead
-   * @param toolbarFactory The toolbar factory
-   */
   constructor(
     panel: NotebookPanel,
-    toolbar?: IObservableList<ToolbarRegistry.IToolbarItem>,
-    toolbarFactory?: (
-      widget: Cell
-    ) => IObservableList<ToolbarRegistry.IToolbarItem>
+    toolbar: IObservableList<ToolbarRegistry.IToolbarItem>
   ) {
     this._panel = panel;
     this._previousActiveCell = this._panel.content.activeCell;
-    this._toolbarItems = toolbar ?? null;
-    this._toolbarFactory = toolbarFactory ?? null;
-
-    if (this._toolbarItems === null && this._toolbarFactory === null) {
-      throw Error('You must provide the toolbarFactory or the toolbar items.');
-    }
-
-    // deprecated to be removed when we remove toolbar from input arguments
-    if (!this._toolbarFactory && this._toolbarItems) {
-      this._onToolbarChanged();
-      this._toolbarItems.changed.connect(this._onToolbarChanged, this);
-    }
+    this._toolbar = toolbar;
+
+    this._onToolbarChanged();
+    this._toolbar.changed.connect(this._onToolbarChanged, this);
 
     // Only add the toolbar to the notebook's active cell (if any) once it has fully rendered and been revealed.
-    void panel.revealed.then(() => {
-      requestAnimationFrame(() => {
-        const notebook = panel.content;
-        this._onActiveCellChanged(notebook);
-        // Handle subsequent changes of active cell.
-        notebook.activeCellChanged.connect(this._onActiveCellChanged, this);
-
-        // Check whether the toolbar should be rendered upon a layout change
-        notebook.renderingLayoutChanged.connect(
-          this._onActiveCellChanged,
-          this
-        );
-
-        notebook.disposed.connect(() => {
-          notebook.activeCellChanged.disconnect(this._onActiveCellChanged);
-        });
-      });
-    });
-  }
-
-  /**
-   * @deprecated Will become protected in JupyterLab 5
-   */
-  _onMetadataChanged(model: CellModel, args: IMapChange) {
-    if (args.key === 'jupyter') {
-      if (
-        typeof args.newValue === 'object' &&
-        args.newValue.source_hidden === true &&
-        (args.type === 'add' || args.type === 'change')
-      ) {
-        // Cell just became hidden; remove toolbar
-        this._removeToolbar(model);
-      }
-      // Check whether input visibility changed
-      else if (
-        typeof args.oldValue === 'object' &&
-        args.oldValue.source_hidden === true
-      ) {
-        // Cell just became visible; add toolbar
-        this._addToolbar(model);
-      }
-    }
-  }
-
-  /**
-   * @deprecated Will become protected in JupyterLab 5
-   */
+    void panel.revealed.then(() => this._onActiveCellChanged(panel.content));
+
+    // Check whether the toolbar should be rendered upon a layout change
+    panel.content.renderingLayoutChanged.connect(
+      this._onActiveCellChanged,
+      this
+    );
+
+    // Handle subsequent changes of active cell.
+    panel.content.activeCellChanged.connect(this._onActiveCellChanged, this);
+  }
+
   _onActiveCellChanged(notebook: Notebook): void {
     if (this._previousActiveCell && !this._previousActiveCell.isDisposed) {
-      // Disposed cells do not have a model anymore.
+      // Disposed cells do not have model anymore.
       this._removeToolbar(this._previousActiveCell.model);
-      this._previousActiveCell.model.metadataChanged.disconnect(
-        this._onMetadataChanged
-      );
     }
 
     const activeCell = notebook.activeCell;
-    // Change previously active cell.
+    if (!activeCell) {
+      return;
+    }
+
+    this._addToolbar(activeCell.model);
     this._previousActiveCell = activeCell;
-    if (activeCell === null || activeCell.inputHidden) {
-      return;
-    }
-
-    activeCell.model.metadataChanged.connect(this._onMetadataChanged, this);
-
-    this._addToolbar(activeCell.model);
+
+    this._updateCellForToolbarOverlap(activeCell);
   }
 
   get isDisposed(): boolean {
@@ -158,8 +92,12 @@
     }
     this._isDisposed = true;
 
-    this._toolbarItems?.changed.disconnect(this._onToolbarChanged, this);
-    this._toolbar?.dispose();
+    this._toolbar.changed.disconnect(this._onToolbarChanged, this);
+
+    const cells = this._panel?.context.model.cells;
+    if (cells) {
+      each(cells.iter(), model => this._removeToolbar(model));
+    }
 
     this._panel = null;
 
@@ -169,60 +107,22 @@
   private _addToolbar(model: ICellModel): void {
     const cell = this._getCell(model);
 
-    if (cell && !cell.isDisposed) {
-      const toolbarWidget = (this._toolbar = new Toolbar());
-      // Note: CELL_MENU_CLASS is deprecated.
+    if (cell) {
+      const toolbarWidget = new Toolbar();
       toolbarWidget.addClass(CELL_MENU_CLASS);
+
+      toArray(this._toolbar).forEach(({ name, widget }) => {
+        toolbarWidget.addItem(name, widget);
+      });
+
       toolbarWidget.addClass(CELL_TOOLBAR_CLASS);
-      const promises: Promise<void>[] = [cell.ready];
-      if (this._toolbarFactory) {
-        setToolbar(cell, this._toolbarFactory, toolbarWidget);
-        // FIXME toolbarWidget.update() - strangely this does not work
-        (toolbarWidget.layout as PanelLayout).widgets.forEach(w => {
-          w.update();
-        });
-      } else {
-        for (const { name, widget } of this._toolbarItems!) {
-          toolbarWidget.addItem(name, widget);
-          if (
-            widget instanceof ReactWidget &&
-            (widget as ReactWidget).renderPromise !== undefined
-          ) {
-            (widget as ReactWidget).update();
-            promises.push((widget as ReactWidget).renderPromise!);
-          }
-        }
-      }
-      promises.push(cell.ready);
-
-      // Wait for all the buttons to be rendered before attaching the toolbar.
-      Promise.all(promises)
-        .then(() => {
-          if (cell.isDisposed || this._panel?.content.activeCell !== cell) {
-            toolbarWidget.dispose();
-            return;
-          }
-
-          // Hide the toolbar by default, to avoid temporary overlapping.
-          cell.node.classList.add(TOOLBAR_OVERLAP_CLASS);
-
-          (cell.inputArea!.layout as PanelLayout).insertWidget(
-            0,
-            toolbarWidget
-          );
-
-          // For rendered markdown, watch for resize events.
-          cell.displayChanged.connect(this._resizeEventCallback, this);
-
-          // Watch for changes in the cell's contents.
-          cell.model.contentChanged.connect(this._changedEventCallback, this);
-
-          // Hide the cell toolbar if it overlaps with cell contents
-          this._updateCellForToolbarOverlap(cell);
-        })
-        .catch(e => {
-          console.error('Error rendering buttons of the cell toolbar: ', e);
-        });
+      (cell.layout as PanelLayout).insertWidget(0, toolbarWidget);
+
+      // For rendered markdown, watch for resize events.
+      cell.displayChanged.connect(this._resizeEventCallback, this);
+
+      // Watch for changes in the cell's contents.
+      cell.model.contentChanged.connect(this._changedEventCallback, this);
     }
   }
 
@@ -230,30 +130,30 @@
     return this._panel?.content.widgets.find(widget => widget.model === model);
   }
 
+  private _findToolbarWidgets(cell: Cell): Widget[] {
+    const widgets = (cell.layout as PanelLayout).widgets;
+
+    // Search for header using the CSS class or use the first one if not found.
+    return widgets.filter(widget => widget.hasClass(CELL_TOOLBAR_CLASS)) || [];
+  }
+
   private _removeToolbar(model: ICellModel): void {
     const cell = this._getCell(model);
-    if (cell && !cell.isDisposed) {
+    if (cell) {
+      this._findToolbarWidgets(cell).forEach(widget => widget.dispose());
       // Attempt to remove the resize and changed event handlers.
       cell.displayChanged.disconnect(this._resizeEventCallback, this);
     }
     model.contentChanged.disconnect(this._changedEventCallback, this);
-    if (
-      this._toolbar?.parent === cell?.inputArea &&
-      this._toolbar?.isDisposed === false
-    ) {
-      this._toolbar.dispose();
-    }
   }
 
   /**
    * Call back on settings changes
-   *
-   * @deprecated To remove when toolbar can not be provided directly to the tracker
    */
   private _onToolbarChanged(): void {
     // Reset toolbar when settings changes
-    const activeCell: Cell<ICellModel> | null | undefined =
-      this._panel?.content.activeCell;
+    const activeCell: Cell<ICellModel> | null | undefined = this._panel?.content
+      .activeCell;
     if (activeCell) {
       this._removeToolbar(activeCell.model);
       this._addToolbar(activeCell.model);
@@ -279,31 +179,23 @@
   }
 
   private _updateCellForToolbarOverlap(activeCell: Cell<ICellModel>) {
-    // When we do change in cell, the browser might not have completed the layout
-    // update if we don't wait, resulting in the previous width being returned
-    // using `getBoundingClientRect().width` in later functions. This also wait for
-    // the toolbar to be rendered the first time (on page reload), allowing us to
-    // retrieve the right widgets width.
-    requestIdleCallback(() => {
-      // Remove the "toolbar overlap" class from the cell, rendering the cell's toolbar
-      const activeCellElement = activeCell.node;
-      activeCellElement.classList.remove(TOOLBAR_OVERLAP_CLASS);
-      if (this._cellToolbarOverlapsContents(activeCell)) {
-        // Add the "toolbar overlap" class to the cell, completely concealing the toolbar,
-        // if the first line of the content overlaps with it at all
-        activeCellElement.classList.add(TOOLBAR_OVERLAP_CLASS);
-      }
-    });
+    // Remove the "toolbar overlap" class from the cell, rendering the cell's toolbar
+    const activeCellElement = activeCell.node;
+    activeCellElement.classList.remove(TOOLBAR_OVERLAP_CLASS);
+
+    if (this._cellToolbarOverlapsContents(activeCell)) {
+      // Add the "toolbar overlap" class to the cell, completely concealing the toolbar,
+      // if the first line of the content overlaps with it at all
+      activeCellElement.classList.add(TOOLBAR_OVERLAP_CLASS);
+    }
   }
 
   private _cellToolbarOverlapsContents(activeCell: Cell<ICellModel>): boolean {
     const cellType = activeCell.model.type;
 
     // If the toolbar is too large for the current cell, hide it.
-
-    const editorRect = activeCell.editorWidget?.node.getBoundingClientRect();
-    const cellLeft = editorRect?.left ?? 0;
-    const cellRight = editorRect?.right ?? 0;
+    const cellLeft = this._cellEditorWidgetLeft(activeCell);
+    const cellRight = this._cellEditorWidgetRight(activeCell);
     const toolbarLeft = this._cellToolbarLeft(activeCell);
 
     if (toolbarLeft === null) {
@@ -336,16 +228,12 @@
    */
   private _markdownOverlapsToolbar(activeCell: MarkdownCell): boolean {
     const markdownOutput = activeCell.inputArea; // Rendered markdown appears in the input area
-    if (!markdownOutput) {
-      return false;
-    }
 
     // Get the rendered markdown as a widget.
     const markdownOutputWidget = markdownOutput.renderedInput;
     const markdownOutputElement = markdownOutputWidget.node;
 
-    const firstOutputElementChild =
-      markdownOutputElement.firstElementChild as HTMLElement;
+    const firstOutputElementChild = markdownOutputElement.firstElementChild as HTMLElement;
     if (firstOutputElementChild === null) {
       return false;
     }
@@ -371,7 +259,7 @@
       const toolbarRect = this._cellToolbarRect(activeCell);
       if (toolbarRect) {
         const { left: toolbarLeft, bottom: toolbarBottom } = toolbarRect;
-        return some(outputs, output => {
+        return Array.from(outputs).some(output => {
           const node = output.firstElementChild;
           if (node) {
             const range = new Range();
@@ -386,8 +274,10 @@
             } else {
               range.selectNode(node);
             }
-            const { right: nodeRight, top: nodeTop } =
-              range.getBoundingClientRect();
+            const {
+              right: nodeRight,
+              top: nodeTop
+            } = range.getBoundingClientRect();
 
             // Note: y-coordinate increases toward the bottom of page
             return nodeRight > toolbarLeft && nodeTop < toolbarBottom;
@@ -402,34 +292,38 @@
   private _codeOverlapsToolbar(activeCell: Cell<ICellModel>): boolean {
     const editorWidget = activeCell.editorWidget;
     const editor = activeCell.editor;
-    if (!editorWidget || !editor) {
-      return false;
-    }
-
     if (editor.lineCount < 1) {
       return false; // Nothing in the editor
     }
 
-    const codeMirrorLines = editorWidget.node.getElementsByClassName('cm-line');
+    const codeMirrorLines = editorWidget.node.getElementsByClassName(
+      'CodeMirror-line'
+    );
     if (codeMirrorLines.length < 1) {
       return false; // No lines present
     }
-
-    let lineRight = codeMirrorLines[0].getBoundingClientRect().left;
-    const range = document.createRange();
-    range.selectNodeContents(codeMirrorLines[0]);
-    lineRight += range.getBoundingClientRect().width;
+    const lineRight = codeMirrorLines[0].children[0] // First span under first pre
+      .getBoundingClientRect().right;
 
     const toolbarLeft = this._cellToolbarLeft(activeCell);
 
     return toolbarLeft === null ? false : lineRight > toolbarLeft;
   }
 
+  private _cellEditorWidgetLeft(activeCell: Cell<ICellModel>): number {
+    return activeCell.editorWidget.node.getBoundingClientRect().left;
+  }
+
+  private _cellEditorWidgetRight(activeCell: Cell<ICellModel>): number {
+    return activeCell.editorWidget.node.getBoundingClientRect().right;
+  }
+
   private _cellToolbarRect(activeCell: Cell<ICellModel>): DOMRect | null {
-    if (this._toolbar?.parent !== activeCell.inputArea) {
+    const toolbarWidgets = this._findToolbarWidgets(activeCell);
+    if (toolbarWidgets.length < 1) {
       return null;
     }
-    const activeCellToolbar = this._toolbar.node;
+    const activeCellToolbar = toolbarWidgets[0].node;
 
     return activeCellToolbar.getBoundingClientRect();
   }
@@ -441,12 +335,7 @@
   private _isDisposed = false;
   private _panel: NotebookPanel | null;
   private _previousActiveCell: Cell<ICellModel> | null;
-  private _toolbar: Widget | null = null;
-  private _toolbarItems: IObservableList<ToolbarRegistry.IToolbarItem> | null =
-    null;
-  private _toolbarFactory:
-    | ((widget: Cell) => IObservableList<ToolbarRegistry.IToolbarItem>)
-    | null = null;
+  private _toolbar: IObservableList<ToolbarRegistry.IToolbarItem>;
 }
 
 const defaultToolbarItems: ToolbarRegistry.IWidget[] = [
@@ -481,7 +370,7 @@
  * created.
  */
 export class CellBarExtension implements DocumentRegistry.WidgetExtension {
-  static readonly FACTORY_NAME = 'Cell';
+  static FACTORY_NAME = 'Cell';
 
   constructor(
     commands: CommandRegistry,
@@ -509,7 +398,7 @@
   }
 
   createNew(panel: NotebookPanel): IDisposable {
-    return new CellToolbarTracker(panel, undefined, this._toolbarFactory);
+    return new CellToolbarTracker(panel, this._toolbarFactory(panel));
   }
 
   private _commands: CommandRegistry;