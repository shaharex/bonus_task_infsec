--- packages\rendermime\src\renderers.ts (old)
+++ packages\rendermime\src\renderers.ts (new)
@@ -3,16 +3,20 @@
 | Distributed under the terms of the Modified BSD License.
 |----------------------------------------------------------------------------*/
 
+import { ISanitizer } from '@jupyterlab/apputils';
+import { CodeMirrorEditor, Mode } from '@jupyterlab/codemirror';
 import { URLExt } from '@jupyterlab/coreutils';
 import { IRenderMime } from '@jupyterlab/rendermime-interfaces';
 import { ITranslator, nullTranslator } from '@jupyterlab/translation';
+import { toArray } from '@lumino/algorithm';
 import escape from 'lodash.escape';
+import { marked } from 'marked';
 import { removeMath, replaceMath } from './latex';
 
 /**
  * Render HTML into a host node.
  *
- * @param options - The options for rendering.
+ * @params options - The options for rendering.
  *
  * @returns A promise which resolves when rendering is complete.
  */
@@ -122,7 +126,7 @@
     /**
      * The html sanitizer for untrusted source.
      */
-    sanitizer: IRenderMime.ISanitizer;
+    sanitizer: ISanitizer;
 
     /**
      * An optional url resolver.
@@ -154,7 +158,7 @@
 /**
  * Render an image into a host node.
  *
- * @param options - The options for rendering.
+ * @params options - The options for rendering.
  *
  * @returns A promise which resolves when rendering is complete.
  */
@@ -162,8 +166,15 @@
   options: renderImage.IRenderOptions
 ): Promise<void> {
   // Unpack the options.
-  const { host, mimeType, source, width, height, needsBackground, unconfined } =
-    options;
+  const {
+    host,
+    mimeType,
+    source,
+    width,
+    height,
+    needsBackground,
+    unconfined
+  } = options;
 
   // Clear the content in the host.
   host.textContent = '';
@@ -247,7 +258,7 @@
 /**
  * Render LaTeX into a host node.
  *
- * @param options - The options for rendering.
+ * @params options - The options for rendering.
  *
  * @returns A promise which resolves when rendering is complete.
  */
@@ -302,7 +313,7 @@
 /**
  * Render Markdown into a host node.
  *
- * @param options - The options for rendering.
+ * @params options - The options for rendering.
  *
  * @returns A promise which resolves when rendering is complete.
  */
@@ -310,7 +321,7 @@
   options: renderMarkdown.IRenderOptions
 ): Promise<void> {
   // Unpack the options.
-  const { host, source, markdownParser, ...others } = options;
+  const { host, source, ...others } = options;
 
   // Clear the content if there is no source.
   if (!source) {
@@ -318,20 +329,14 @@
     return;
   }
 
-  let html = '';
-  if (markdownParser) {
-    // Separate math from normal markdown text.
-    const parts = removeMath(source);
-
-    // Convert the markdown to HTML.
-    html = await markdownParser.render(parts['text']);
-
-    // Replace math.
-    html = replaceMath(html, parts['math']);
-  } else {
-    // Fallback if the application does not have any markdown parser.
-    html = `<pre>${source}</pre>`;
-  }
+  // Separate math from normal markdown text.
+  const parts = removeMath(source);
+
+  // Convert the markdown to HTML.
+  let html = await renderMarkdown.renderMarked(parts['text']);
+
+  // Replace math.
+  html = replaceMath(html, parts['math']);
 
   // Render HTML.
   await renderHTML({
@@ -370,7 +375,7 @@
     /**
      * The html sanitizer for untrusted source.
      */
-    sanitizer: IRenderMime.ISanitizer;
+    sanitizer: ISanitizer;
 
     /**
      * An optional url resolver.
@@ -393,31 +398,39 @@
     latexTypesetter: IRenderMime.ILatexTypesetter | null;
 
     /**
-     * The Markdown parser.
-     */
-    markdownParser: IRenderMime.IMarkdownParser | null;
-
-    /**
      * The application language translator.
      */
     translator?: ITranslator;
   }
 
   /**
-   * Create a normalized id for a header element.
+   * Render markdown for the specified content.
    *
-   * @param header Header element
-   * @returns Normalized id
-   */
-  export function createHeaderId(header: Element): string {
-    return (header.textContent ?? '').replace(/ /g, '-');
+   * @param content - The string of markdown to render.
+   *
+   * @return A promise which resolves with the rendered content.
+   *
+   * @deprecated This will be remove in 4.0.0 as a new plugin `'@jupyterlab/markedparser-extension:plugin'`
+   * will be exporting `IMarkdownParser` token for customization and reuse by other plugins.
+   */
+  export function renderMarked(content: string): Promise<string> {
+    Private.initializeMarked();
+    return new Promise<string>((resolve, reject) => {
+      marked(content, (err: any, content: string) => {
+        if (err) {
+          reject(err);
+        } else {
+          resolve(content);
+        }
+      });
+    });
   }
 }
 
 /**
  * Render SVG into a host node.
  *
- * @param options - The options for rendering.
+ * @params options - The options for rendering.
  *
  * @returns A promise which resolves when rendering is complete.
  */
@@ -491,178 +504,54 @@
 }
 
 /**
- * Options for auto linker.
- */
-interface IAutoLinkOptions {
-  /**
-   * Whether to look for web URLs e.g. indicated by http schema or www prefix.
-   */
-  checkWeb: boolean;
-  /**
-   * Whether to look for path URIs.
-   */
-  checkPaths: boolean;
-}
-
-interface ILinker {
-  /**
-   * Regular expression capturing links in the group named `path`.
-   *
-   * Full match extend will be used as label for the link.
-   * Additional named groups represent locator fragments.
-   */
-  regex: RegExp;
-  /**
-   * Create the anchor element.
-   */
-  createAnchor: (
-    text: string,
-    label: string,
-    attributes?: Record<string, string>
-  ) => HTMLAnchorElement;
-  /**
-   * Modify the path value if needed.
-   */
-  processPath?: (text: string) => string;
-  /**
-   * Modify the label if needed.
-   */
-  processLabel?: (text: string) => string;
-}
-
-namespace ILinker {
+ * Replace URLs with links.
+ *
+ * @param content - The text content of a node.
+ *
+ * @returns A list of text nodes and anchor elements.
+ */
+function autolink(content: string): Array<HTMLAnchorElement | Text> {
   // Taken from Visual Studio Code:
   // https://github.com/microsoft/vscode/blob/9f709d170b06e991502153f281ec3c012add2e42/src/vs/workbench/contrib/debug/browser/linkDetector.ts#L17-L18
   const controlCodes = '\\u0000-\\u0020\\u007f-\\u009f';
-  export const webLinkRegex = new RegExp(
-    '(?<path>(?:[a-zA-Z][a-zA-Z0-9+.-]{2,}:\\/\\/|data:|www\\.)[^\\s' +
+  const webLinkRegex = new RegExp(
+    '(?:[a-zA-Z][a-zA-Z0-9+.-]{2,}:\\/\\/|data:|www\\.)[^\\s' +
       controlCodes +
       '"]{2,}[^\\s' +
       controlCodes +
-      '"\'(){}\\[\\],:;.!?])',
+      '"\'(){}\\[\\],:;.!?]',
     'ug'
   );
-  // Taken from Visual Studio Code:
-  // https://github.com/microsoft/vscode/blob/3e407526a1e2ff22cacb69c7e353e81a12f41029/extensions/notebook-renderers/src/linkify.ts#L9
-  const winAbsPathRegex = /(?:[a-zA-Z]:(?:(?:\\|\/)[\w\.-]*)+)/;
-  const winRelPathRegex = /(?:(?:\~|\.)(?:(?:\\|\/)[\w\.-]*)+)/;
-  const winPathRegex = new RegExp(
-    `(${winAbsPathRegex.source}|${winRelPathRegex.source})`
-  );
-  const posixPathRegex = /((?:\~|\.)?(?:\/[\w\.-]*)+)/;
-  const lineColumnRegex =
-    /(?:(?:\:|", line )(?<line>[\d]+))?(?:\:(?<column>[\d]+))?/;
-  // TODO: this ought to come from kernel (browser may be on a different OS).
-  const isWindows = navigator.userAgent.indexOf('Windows') >= 0;
-  export const pathLinkRegex = new RegExp(
-    `(?<path>${isWindows ? winPathRegex.source : posixPathRegex.source})${
-      lineColumnRegex.source
-    }`,
-    'g'
-  );
-}
-
-/**
- * Linker for web URLs.
- */
-class WebLinker implements ILinker {
-  regex = ILinker.webLinkRegex;
-  createAnchor(url: string, label: string) {
-    const anchor = document.createElement('a');
-    anchor.href = url.startsWith('www.') ? 'https://' + url : url;
-    anchor.rel = 'noopener';
-    anchor.target = '_blank';
-    anchor.appendChild(document.createTextNode(label));
-    return anchor;
-  }
-  processPath(url: string) {
+
+  const nodes = [];
+  let lastIndex = 0;
+
+  let match: RegExpExecArray | null;
+  while (null != (match = webLinkRegex.exec(content))) {
+    if (match.index !== lastIndex) {
+      nodes.push(
+        document.createTextNode(content.slice(lastIndex, match.index))
+      );
+    }
+    let url = match[0];
     // Special case when the URL ends with ">" or "<"
     const lastChars = url.slice(-1);
     const endsWithGtLt = ['>', '<'].indexOf(lastChars) !== -1;
     const len = endsWithGtLt ? url.length - 1 : url.length;
+    const anchor = document.createElement('a');
     url = url.slice(0, len);
-    return url;
-  }
-  processLabel(url: string) {
-    return this.processPath(url);
-  }
-}
-
-/**
- * Linker for path URIs.
- */
-class PathLinker implements ILinker {
-  regex = ILinker.pathLinkRegex;
-  createAnchor(path: string, label: string, locators: Record<string, string>) {
-    const anchor = document.createElement('a');
-
-    // Store the path in dataset.
-    // Do not set `href` - at this point we do not know if the path is valid and
-    // accessible for application (and we want rendering those as links).
-    anchor.dataset.path = path;
-
-    // Store line using RFC 5147 fragment locator for text/plain files.
-    // It could be expanded to other formats, e.g. based on file extension.
-    const line = parseInt(locators['line'], 10);
-    let locator: string = !isNaN(line) ? `line=${line - 1}` : '';
-    anchor.dataset.locator = locator;
-
-    anchor.appendChild(document.createTextNode(label));
-    return anchor;
-  }
-}
-
-function autolink(
-  content: string,
-  options: IAutoLinkOptions
-): Array<HTMLAnchorElement | Text> {
-  const linkers: ILinker[] = [];
-  if (options.checkWeb) {
-    linkers.push(new WebLinker());
-  }
-  if (options.checkPaths) {
-    linkers.push(new PathLinker());
-  }
-  const nodes: Array<HTMLAnchorElement | Text> = [];
-
-  // There are two ways to implement competitive regexes:
-  // - two heads (which would need to resolve overlaps), or
-  // - (simpler) divide and recurse (implemented below)
-  const linkify = (content: string, regexIndex: number) => {
-    if (regexIndex >= linkers.length) {
-      nodes.push(document.createTextNode(content));
-      return;
-    }
-
-    const linker = linkers[regexIndex];
-
-    let match: RegExpExecArray | null;
-    let currentIndex = 0;
-    const regex = linker.regex;
-    // Reset regex
-    regex.lastIndex = 0;
-
-    while (null != (match = regex.exec(content))) {
-      const stringBeforeMatch = content.substring(currentIndex, match.index);
-      if (stringBeforeMatch) {
-        linkify(stringBeforeMatch, regexIndex + 1);
-      }
-
-      const { path, ...locators } = match.groups!;
-      const value = linker.processPath ? linker.processPath(path) : path;
-      const label = linker.processLabel
-        ? linker.processLabel(match[0])
-        : match[0];
-      nodes.push(linker.createAnchor(value, label, locators));
-      currentIndex = match.index + label.length;
-    }
-    const stringAfterMatches = content.substring(currentIndex);
-    if (stringAfterMatches) {
-      linkify(stringAfterMatches, regexIndex + 1);
-    }
-  };
-
-  linkify(content, 0);
+    anchor.href = url.startsWith('www.') ? 'https://' + url : url;
+    anchor.rel = 'noopener';
+    anchor.target = '_blank';
+    anchor.appendChild(document.createTextNode(url.slice(0, len)));
+    nodes.push(anchor);
+    lastIndex = match.index + len;
+  }
+  if (lastIndex !== content.length) {
+    nodes.push(
+      document.createTextNode(content.slice(lastIndex, content.length))
+    );
+  }
   return nodes;
 }
 
@@ -782,7 +671,7 @@
 /**
  * Render text into a host node.
  *
- * @param options - The options for rendering.
+ * @params options - The options for rendering.
  *
  * @returns A promise which resolves when rendering is complete.
  */
@@ -796,26 +685,65 @@
   });
 
   // Set the sanitized content for the host node.
+  const ret = document.createElement('pre');
   const pre = document.createElement('pre');
   pre.innerHTML = content;
 
   const preTextContent = pre.textContent;
 
-  let ret: HTMLPreElement;
   if (preTextContent) {
     // Note: only text nodes and span elements should be present after sanitization in the `<pre>` element.
-    const linkedNodes =
-      sanitizer.getAutolink?.() ?? true
-        ? autolink(preTextContent, {
-            checkWeb: true,
-            checkPaths: false
-          })
-        : [document.createTextNode(content)];
-
+    const linkedNodes = autolink(preTextContent);
+    let inAnchorElement = false;
+
+    const combinedNodes: (HTMLAnchorElement | Text | HTMLSpanElement)[] = [];
     const preNodes = Array.from(pre.childNodes) as (Text | HTMLSpanElement)[];
-    ret = mergeNodes(preNodes, linkedNodes);
-  } else {
-    ret = document.createElement('pre');
+
+    for (let nodes of alignedNodes(preNodes, linkedNodes)) {
+      if (!nodes[0]) {
+        combinedNodes.push(nodes[1]);
+        inAnchorElement = nodes[1].nodeType !== Node.TEXT_NODE;
+        continue;
+      } else if (!nodes[1]) {
+        combinedNodes.push(nodes[0]);
+        inAnchorElement = false;
+        continue;
+      }
+      let [preNode, linkNode] = nodes;
+
+      const lastCombined = combinedNodes[combinedNodes.length - 1];
+
+      // If we are already in an anchor element and the anchor element did not change,
+      // we should insert the node from <pre> which is either Text node or coloured span Element
+      // into the anchor content as a child
+      if (
+        inAnchorElement &&
+        (linkNode as HTMLAnchorElement).href ===
+          (lastCombined as HTMLAnchorElement).href
+      ) {
+        lastCombined.appendChild(preNode);
+      } else {
+        // the `linkNode` is either Text or AnchorElement;
+        const isAnchor = linkNode.nodeType !== Node.TEXT_NODE;
+        // if we are NOT about to start an anchor element, just add the pre Node
+        if (!isAnchor) {
+          combinedNodes.push(preNode);
+          inAnchorElement = false;
+        } else {
+          // otherwise start a new anchor; the contents of the `linkNode` and `preNode` should be the same,
+          // so we just put the neatly formatted `preNode` inside the anchor node (`linkNode`)
+          // and append that to combined nodes.
+          linkNode.textContent = '';
+          linkNode.appendChild(preNode);
+          combinedNodes.push(linkNode);
+          inAnchorElement = true;
+        }
+      }
+    }
+    // Do not reuse `pre` element. Clearing out previous children is too slow...
+    for (const child of combinedNodes) {
+      ret.appendChild(child);
+    }
   }
 
   host.appendChild(ret);
@@ -840,166 +768,12 @@
     /**
      * The html sanitizer for untrusted source.
      */
-    sanitizer: IRenderMime.ISanitizer;
+    sanitizer: ISanitizer;
 
     /**
      * The source text to render.
      */
     source: string;
-
-    /**
-     * The application language translator.
-     */
-    translator?: ITranslator;
-  }
-}
-
-/**
- * Render error into a host node.
- *
- * @param options - The options for rendering.
- *
- * @returns A promise which resolves when rendering is complete.
- */
-export function renderError(
-  options: renderError.IRenderOptions
-): Promise<void> {
-  // Unpack the options.
-  const { host, linkHandler, sanitizer, resolver, source } = options;
-
-  // Create the HTML content.
-  const content = sanitizer.sanitize(Private.ansiSpan(source), {
-    allowedTags: ['span']
-  });
-
-  // Set the sanitized content for the host node.
-  const pre = document.createElement('pre');
-  pre.innerHTML = content;
-
-  const preTextContent = pre.textContent;
-
-  let ret: HTMLPreElement;
-  if (preTextContent) {
-    // Note: only text nodes and span elements should be present after sanitization in the `<pre>` element.
-    const linkedNodes =
-      sanitizer.getAutolink?.() ?? true
-        ? autolink(preTextContent, {
-            checkWeb: true,
-            checkPaths: true
-          })
-        : [document.createTextNode(content)];
-
-    const preNodes = Array.from(pre.childNodes) as (Text | HTMLSpanElement)[];
-    ret = mergeNodes(preNodes, linkedNodes);
-  } else {
-    ret = document.createElement('pre');
-  }
-  host.appendChild(ret);
-
-  // Patch the paths if a resolver is available.
-  let promise: Promise<void>;
-  if (resolver) {
-    promise = Private.handlePaths(host, resolver, linkHandler);
-  } else {
-    promise = Promise.resolve(undefined);
-  }
-
-  // Return the rendered promise.
-  return promise;
-}
-
-/**
- * Merge `<span>` nodes from a `<pre>` element with `<a>` nodes from linker.
- */
-function mergeNodes(
-  preNodes: (Text | HTMLSpanElement)[],
-  linkedNodes: (Text | HTMLAnchorElement)[]
-): HTMLPreElement {
-  const ret = document.createElement('pre');
-  let inAnchorElement = false;
-
-  const combinedNodes: (HTMLAnchorElement | Text | HTMLSpanElement)[] = [];
-
-  for (let nodes of alignedNodes(preNodes, linkedNodes)) {
-    if (!nodes[0]) {
-      combinedNodes.push(nodes[1]);
-      inAnchorElement = nodes[1].nodeType !== Node.TEXT_NODE;
-      continue;
-    } else if (!nodes[1]) {
-      combinedNodes.push(nodes[0]);
-      inAnchorElement = false;
-      continue;
-    }
-    let [preNode, linkNode] = nodes;
-
-    const lastCombined = combinedNodes[combinedNodes.length - 1];
-
-    // If we are already in an anchor element and the anchor element did not change,
-    // we should insert the node from <pre> which is either Text node or coloured span Element
-    // into the anchor content as a child
-    if (
-      inAnchorElement &&
-      (linkNode as HTMLAnchorElement).href ===
-        (lastCombined as HTMLAnchorElement).href
-    ) {
-      lastCombined.appendChild(preNode);
-    } else {
-      // the `linkNode` is either Text or AnchorElement;
-      const isAnchor = linkNode.nodeType !== Node.TEXT_NODE;
-      // if we are NOT about to start an anchor element, just add the pre Node
-      if (!isAnchor) {
-        combinedNodes.push(preNode);
-        inAnchorElement = false;
-      } else {
-        // otherwise start a new anchor; the contents of the `linkNode` and `preNode` should be the same,
-        // so we just put the neatly formatted `preNode` inside the anchor node (`linkNode`)
-        // and append that to combined nodes.
-        linkNode.textContent = '';
-        linkNode.appendChild(preNode);
-        combinedNodes.push(linkNode);
-        inAnchorElement = true;
-      }
-    }
-  }
-  // Do not reuse `pre` element. Clearing out previous children is too slow...
-  for (const child of combinedNodes) {
-    ret.appendChild(child);
-  }
-  return ret;
-}
-
-/**
- * The namespace for the `renderError` function statics.
- */
-export namespace renderError {
-  /**
-   * The options for the `renderError` function.
-   */
-  export interface IRenderOptions {
-    /**
-     * The host node for the error content.
-     */
-    host: HTMLElement;
-
-    /**
-     * The html sanitizer for untrusted source.
-     */
-    sanitizer: IRenderMime.ISanitizer;
-
-    /**
-     * The source error to render.
-     */
-    source: string;
-
-    /**
-     * An optional url resolver.
-     */
-    resolver: IRenderMime.IResolver | null;
-
-    /**
-     * An optional link handler.
-     */
-    linkHandler: IRenderMime.ILinkHandler | null;
 
     /**
      * The application language translator.
@@ -1022,7 +796,7 @@
    */
   export function evalInnerHTMLScriptTags(host: HTMLElement): void {
     // Create a snapshot of the current script nodes.
-    const scripts = Array.from(host.getElementsByTagName('script'));
+    const scripts = toArray(host.getElementsByTagName('script'));
 
     // Loop over each script node.
     for (const script of scripts) {
@@ -1131,29 +905,6 @@
   }
 
   /**
-   * Resolve the paths in `<a>` elements `data` attributes.
-   *
-   * @param node - The head html element.
-   *
-   * @param resolver - A url resolver.
-   *
-   * @param linkHandler - An optional link handler for nodes.
-   *
-   * @returns a promise fulfilled when the relative urls have been resolved.
-   */
-  export async function handlePaths(
-    node: HTMLElement,
-    resolver: IRenderMime.IResolver,
-    linkHandler: IRenderMime.ILinkHandler | null
-  ): Promise<void> {
-    // Handle anchor elements.
-    const anchors = node.getElementsByTagName('a');
-    for (let i = 0; i < anchors.length; i++) {
-      await handlePathAnchor(anchors[i], resolver, linkHandler);
-    }
-  }
-
-  /**
    * Apply ids to headers.
    */
   export function headerAnchors(node: HTMLElement): void {
@@ -1162,7 +913,7 @@
       const headers = node.getElementsByTagName(headerType);
       for (let i = 0; i < headers.length; i++) {
         const header = headers[i];
-        header.id = renderMarkdown.createHeaderId(header);
+        header.id = (header.textContent ?? '').replace(/ /g, '-');
         const anchor = document.createElement('a');
         anchor.target = '_self';
         anchor.textContent = 'Â¶';
@@ -1258,65 +1009,57 @@
       });
   }
 
-  /**
-   * Handle an anchor node.
-   */
-  async function handlePathAnchor(
-    anchor: HTMLAnchorElement,
-    resolver: IRenderMime.IResolver,
-    linkHandler: IRenderMime.ILinkHandler | null
-  ): Promise<void> {
-    let path = anchor.dataset.path || '';
-    let locator = anchor.dataset.locator ? '#' + anchor.dataset.locator : '';
-    delete anchor.dataset.path;
-    delete anchor.dataset.locator;
-    const allowRoot = true;
-
-    const isLocal = resolver.isLocal
-      ? resolver.isLocal(path, allowRoot)
-      : URLExt.isLocal(path, allowRoot);
-
-    // Bail if:
-    // - it is not a file-like url,
-    // - the resolver does not support paths
-    // - there is no link handler, or if it does not support paths
-    if (
-      !path ||
-      !isLocal ||
-      !resolver.resolvePath ||
-      !linkHandler ||
-      !linkHandler.handlePath
-    ) {
-      anchor.replaceWith(...anchor.childNodes);
-      return Promise.resolve(undefined);
-    }
-    try {
-      // Find given path
-      const resolution = await resolver.resolvePath(path);
-
-      if (!resolution) {
-        // Bail if the file does not exist
-        console.log('Path resolution bailing: does not exist');
-        return Promise.resolve(undefined);
-      }
-
-      // Handle the click override.
-      linkHandler.handlePath(
-        anchor,
-        resolution.path,
-        resolution.scope,
-        locator
-      );
-
-      // Set the visible anchor.
-      anchor.href = resolution.path + locator;
-    } catch (err) {
-      // If there was an error getting the url,
-      // just make it an empty link.
-      console.warn('Path anchor error:', err);
-      anchor.href = '#linking-failed-see-console';
-    }
-  }
+  let markedInitialized = false;
+
+  /**
+   * Support GitHub flavored Markdown, leave sanitizing to external library.
+   */
+  export function initializeMarked(): void {
+    if (markedInitialized) {
+      return;
+    }
+    markedInitialized = true;
+    marked.setOptions({
+      gfm: true,
+      sanitize: false,
+      // breaks: true; We can't use GFM breaks as it causes problems with tables
+      langPrefix: `cm-s-${CodeMirrorEditor.defaultConfig.theme} language-`,
+      highlight: (code, lang, callback) => {
+        const cb = (err: Error | null, code: string) => {
+          if (callback) {
+            callback(err, code);
+          }
+          return code;
+        };
+        if (!lang) {
+          // no language, no highlight
+          return cb(null, code);
+        }
+        Mode.ensure(lang)
+          .then(spec => {
+            const el = document.createElement('div');
+            if (!spec) {
+              console.error(`No CodeMirror mode: ${lang}`);
+              return cb(null, code);
+            }
+            try {
+              Mode.run(code, spec.mime, el);
+              return cb(null, el.innerHTML);
+            } catch (err) {
+              console.error(`Failed to highlight ${lang} code`, err);
+              return cb(err, code);
+            }
+          })
+          .catch(err => {
+            console.error(`No CodeMirror mode: ${lang}`);
+            console.error(`Require CodeMirror mode error: ${err}`);
+            return cb(null, code);
+          });
+        return code;
+      }
+    });
+  }
+
   const ANSI_COLORS = [
     'ansi-black',
     'ansi-red',