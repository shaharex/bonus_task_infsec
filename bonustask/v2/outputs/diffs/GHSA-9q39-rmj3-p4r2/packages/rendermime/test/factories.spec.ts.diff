--- packages\rendermime\test\factories.spec.ts (old)
+++ packages\rendermime\test\factories.spec.ts (new)
@@ -1,21 +1,81 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
+const sampleData = `# Title first level
+
+## Title second Level
+
+### Title third level
+
+#### Title fourth level
+
+##### Title fifth level
+
+###### Title sixth level
+
+# h1
+
+## h2
+
+### h3
+
+#### h4
+
+##### h6
+
+This is just a sample paragraph
+You can look at different level of nested unordered list ljbakjn arsvlasc asc asc awsc asc ascd ascd ascd asdc asc
+
+- level 1
+  - level 2
+  - level 2
+  - level 2
+    - level 3
+    - level 3
+      - level 4
+        - level 5
+          - level 6
+  - level 2
+- level 1
+- level 1
+- level 1
+  Ordered list
+
+1.  level 1 2. level 1 3. level 1 4. level 1 1. level 1 1. level 1 2. level 1 3. level 1 4. level 1 1. level 1 1. level 1
+2.  level 1
+3.  level 1
+    some Horizontal line
+
+---
+
+## and another one
+
+Colons can be used to align columns.
+
+| Tables        |      Are      | Cool |
+| ------------- | :-----------: | ---: |
+| col 3 is      | right-aligned | 1600 |
+| col 2 is      |   centered    |   12 |
+| zebra stripes |   are neat    |    1 |
+
+There must be at least 3 dashes separating each header cell.
+The outer pipes (|) are optional, and you don't need to make the
+raw Markdown line up prettily. You can also use inline Markdown.
+`;
+
 import { Sanitizer } from '@jupyterlab/apputils';
+import { JSONObject, JSONValue } from '@lumino/coreutils';
+import { Widget } from '@lumino/widgets';
 import {
-  errorRendererFactory,
   htmlRendererFactory,
   imageRendererFactory,
-  IMarkdownParser,
   IRenderMime,
   latexRendererFactory,
   markdownRendererFactory,
   MimeModel,
   svgRendererFactory,
   textRendererFactory
-} from '@jupyterlab/rendermime';
-import { JSONObject, JSONValue } from '@lumino/coreutils';
-import { Widget } from '@lumino/widgets';
+} from '../src';
 
 function createModel(
   mimeType: string,
@@ -42,7 +102,11 @@
   describe('textRendererFactory', () => {
     describe('#mimeTypes', () => {
       it('should have text related mimeTypes', () => {
-        const mimeTypes = ['text/plain', 'application/vnd.jupyter.stdout'];
+        const mimeTypes = [
+          'text/plain',
+          'application/vnd.jupyter.stdout',
+          'application/vnd.jupyter.stderr'
+        ];
         expect(textRendererFactory.mimeTypes).toEqual(mimeTypes);
       });
     });
@@ -169,32 +233,6 @@
         );
       });
 
-      it('should not skip autolink', async () => {
-        const source = 'www.example.com';
-        const expected =
-          '<pre><a href="https://www.example.com" rel="noopener" target="_blank">www.example.com</a></pre>';
-        const f = textRendererFactory;
-        const mimeType = 'text/plain';
-        const model = createModel(mimeType, source);
-        sanitizer.setAutolink(true);
-        const w = f.createRenderer({ mimeType, ...defaultOptions });
-        await w.renderModel(model);
-        expect(w.node.innerHTML).toBe(expected);
-      });
-
-      it('should skip autolink', async () => {
-        const source = 'www.example.com';
-        const expected = '<pre>www.example.com</pre>';
-        const f = textRendererFactory;
-        const mimeType = 'text/plain';
-        const model = createModel(mimeType, source);
-        sanitizer.setAutolink(false);
-        const w = f.createRenderer({ mimeType, ...defaultOptions });
-        await w.renderModel(model);
-        expect(w.node.innerHTML).toBe(expected);
-        sanitizer.setAutolink(true);
-      });
-
       it('should autolink multiple URLs', async () => {
         const source = 'www.example.com\nwww.python.org';
         const expected =
@@ -289,34 +327,12 @@
     });
 
     describe('#createRenderer()', () => {
-      let markdownParser: IMarkdownParser;
-
-      beforeAll(() => {
-        markdownParser = {
-          render: (content: string): Promise<string> => Promise.resolve(content)
-        };
-      });
-
-      it('should set the inner html with no parser', async () => {
+      it('should set the inner html', async () => {
         const f = markdownRendererFactory;
         const source = '<p>hello</p>';
         const mimeType = 'text/markdown';
         const model = createModel(mimeType, source);
         const w = f.createRenderer({ mimeType, ...defaultOptions });
-        await w.renderModel(model);
-        expect(w.node.innerHTML).toBe(`<pre>${source}</pre>`);
-      });
-
-      it('should set the inner html with md parser', async () => {
-        const f = markdownRendererFactory;
-        const source = '<p>hello</p>';
-        const mimeType = 'text/markdown';
-        const model = createModel(mimeType, source);
-        const w = f.createRenderer({
-          mimeType,
-          ...defaultOptions,
-          markdownParser
-        });
         await w.renderModel(model);
         expect(w.node.innerHTML).toBe(source);
       });
@@ -326,30 +342,19 @@
         const source = '<p>hello</p>';
         const mimeType = 'text/markdown';
         const model = createModel(mimeType, source);
-        const w = f.createRenderer({
-          mimeType,
-          ...defaultOptions,
-          markdownParser
-        });
-        await w.renderModel(model);
-        await w.renderModel(model);
-        expect(w.node.innerHTML).toBe(`${source}`);
+        const w = f.createRenderer({ mimeType, ...defaultOptions });
+        await w.renderModel(model);
+        await w.renderModel(model);
+        expect(w.node.innerHTML).toBe(source);
       });
 
       it('should add header anchors', async () => {
         const f = markdownRendererFactory;
         const mimeType = 'text/markdown';
-        const sampleData = '### Title third level';
-
         const model = createModel(mimeType, sampleData);
-        const w = f.createRenderer({
-          mimeType,
-          ...defaultOptions,
-          markdownParser: { render: content => '<h3>Title third level</h3>' }
-        });
+        const w = f.createRenderer({ mimeType, ...defaultOptions });
         await w.renderModel(model);
         Widget.attach(w, document.body);
-
         const node = document.getElementById('Title-third-level')!;
         expect(node.localName).toBe('h3');
         const anchor = node.firstChild!.nextSibling as HTMLAnchorElement;
@@ -493,162 +498,4 @@
       });
     });
   });
-
-  describe('errorRendererFactory', () => {
-    describe('#mimeTypes', () => {
-      it('should support application/vnd.jupyter.stderr mime types', () => {
-        expect(errorRendererFactory.mimeTypes).toEqual([
-          'application/vnd.jupyter.stderr'
-        ]);
-      });
-    });
-
-    const knownPaths = [
-      '/usr/local/lib/message.py',
-      '/tmp/ipykernel_361344/2220647380.py',
-      '~/jupyterlab/a_file.py',
-      '~/jupyterlab/b_file.py',
-      '/home/user/jupyterlab/a_file.py'
-    ];
-    const options = {
-      ...defaultOptions,
-      resolver: {
-        resolvePath: (url: string) => {
-          if (knownPaths.includes(url)) {
-            return Promise.resolve({
-              path: url,
-              scope: 'server'
-            });
-          }
-          return Promise.resolve(null);
-        },
-        isLocal: (url: string) => {
-          return knownPaths.includes(url);
-        },
-        exists: () => {
-          return false;
-        }
-      },
-      linkHandler: {
-        handlePath: (...args: any[]) => {
-          // no-op
-          return null;
-        }
-      }
-    };
-
-    describe('#createRenderer()', () => {
-      it('should output the correct HTML', async () => {
-        const f = errorRendererFactory;
-        const mimeType = 'application/vnd.jupyter.stderr';
-        const model = createModel(mimeType, 'x = 2 ** a');
-        const w = f.createRenderer({ mimeType, ...options });
-        await w.renderModel(model);
-        expect(w.node.innerHTML).toBe('<pre>x = 2 ** a</pre>');
-      });
-
-      it('should be re-renderable', async () => {
-        const f = errorRendererFactory;
-        const mimeType = 'application/vnd.jupyter.stderr';
-        const model = createModel(mimeType, 'x = 2 ** a');
-        const w = f.createRenderer({ mimeType, ...options });
-        await w.renderModel(model);
-        await w.renderModel(model);
-        expect(w.node.innerHTML).toBe('<pre>x = 2 ** a</pre>');
-      });
-
-      it('should escape inline html', async () => {
-        const f = errorRendererFactory;
-        const source =
-          'There is no text <script>window.x=1</script> but \x1b[01;41;32mtext\x1b[00m.\nWoo.';
-        const mimeType = 'application/vnd.jupyter.stderr';
-        const model = createModel(mimeType, source);
-        const w = f.createRenderer({ mimeType, ...options });
-        await w.renderModel(model);
-        expect(w.node.innerHTML).toBe(
-          '<pre>There is no text &lt;script&gt;window.x=1&lt;/script&gt; but <span class="ansi-green-intense-fg ansi-red-bg ansi-bold">text</span>.\nWoo.</pre>'
-        );
-      });
-
-      it('should autolink a single known file path', async () => {
-        const f = errorRendererFactory;
-        const urls = [
-          ['/usr/local/lib/message.py', '', ''],
-          ['/usr/local/lib/message.py', '"', '"'],
-          ['/tmp/ipykernel_361344/2220647380.py', '', '']
-        ];
-        await Promise.all(
-          urls.map(async u => {
-            const [url, before, after] = u;
-            const source = `Text with the URL ${before}${url}${after} inside.`;
-            const mimeType = 'application/vnd.jupyter.stderr';
-            const model = createModel(mimeType, source);
-            const w = f.createRenderer({ mimeType, ...options });
-            const [urlEncoded, beforeEncoded, afterEncoded] = [
-              url,
-              before,
-              after
-            ].map(encodeChars);
-            const prefixedUrl = urlEncoded.startsWith('www.')
-              ? 'https://' + urlEncoded
-              : urlEncoded;
-            await w.renderModel(model);
-            expect(w.node.innerHTML).toBe(
-              `<pre>Text with the URL ${beforeEncoded}<a href="${prefixedUrl}">${urlEncoded}</a>${afterEncoded} inside.</pre>`
-            );
-          })
-        );
-      });
-
-      it('should autolink multiple links', async () => {
-        const f = errorRendererFactory;
-        const source =
-          'prefix ~/jupyterlab/a_file.py:1 suffix\nprefix ~/jupyterlab/b_file.py:1 suffix';
-        const mimeType = 'application/vnd.jupyter.stderr';
-        const model = createModel(mimeType, source);
-        const w = f.createRenderer({ mimeType, ...options });
-        await w.renderModel(model);
-        expect(w.node.innerHTML).toBe(
-          '<pre>prefix <a href="~/jupyterlab/a_file.py#line=0">~/jupyterlab/a_file.py:1</a> suffix\nprefix <a href="~/jupyterlab/b_file.py#line=0">~/jupyterlab/b_file.py:1</a> suffix</pre>'
-        );
-      });
-
-      it('should autolink to a specific line (Python style)', async () => {
-        const f = errorRendererFactory;
-        const source =
-          'File "/home/user/jupyterlab/a_file.py", line 1, in <module>';
-        const mimeType = 'application/vnd.jupyter.stderr';
-        const model = createModel(mimeType, source);
-        const w = f.createRenderer({ mimeType, ...options });
-        await w.renderModel(model);
-        expect(w.node.innerHTML).toBe(
-          '<pre>File "<a href="/home/user/jupyterlab/a_file.py#line=0">/home/user/jupyterlab/a_file.py", line 1</a>, in &lt;module&gt;</pre>'
-        );
-      });
-
-      it('should autolink to a specific line (IPython style)', async () => {
-        const f = errorRendererFactory;
-        const source = 'File ~/jupyterlab/a_file.py:1';
-        const mimeType = 'application/vnd.jupyter.stderr';
-        const model = createModel(mimeType, source);
-        const w = f.createRenderer({ mimeType, ...options });
-        await w.renderModel(model);
-        expect(w.node.innerHTML).toBe(
-          '<pre>File <a href="~/jupyterlab/a_file.py#line=0">~/jupyterlab/a_file.py:1</a></pre>'
-        );
-      });
-
-      it('should autolink URLs', async () => {
-        const source = 'www.example.com';
-        const expected =
-          '<pre><a href="https://www.example.com" rel="noopener" target="_blank">www.example.com</a></pre>';
-        const f = textRendererFactory;
-        const mimeType = 'application/vnd.jupyter.stderr';
-        const model = createModel(mimeType, source);
-        const w = f.createRenderer({ mimeType, ...options });
-        await w.renderModel(model);
-        expect(w.node.innerHTML).toBe(expected);
-      });
-    });
-  });
 });