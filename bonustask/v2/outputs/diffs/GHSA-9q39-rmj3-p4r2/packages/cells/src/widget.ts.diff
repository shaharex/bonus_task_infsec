--- packages\cells\src\widget.ts (old)
+++ packages\cells\src\widget.ts (new)
@@ -3,15 +3,11 @@
 | Distributed under the terms of the Modified BSD License.
 |----------------------------------------------------------------------------*/
 
-import { Extension } from '@codemirror/state';
-
-import { EditorView } from '@codemirror/view';
-
-import { ElementExt } from '@lumino/domutils';
+import { marked } from 'marked';
 
 import { AttachmentsResolver } from '@jupyterlab/attachments';
 
-import { DOMUtils, ISessionContext } from '@jupyterlab/apputils';
+import { ISessionContext } from '@jupyterlab/apputils';
 
 import { ActivityMonitor, IChangedArgs, URLExt } from '@jupyterlab/coreutils';
 
@@ -20,6 +16,8 @@
 import { DirListing } from '@jupyterlab/filebrowser';
 
 import * as nbformat from '@jupyterlab/nbformat';
+
+import { IObservableJSON, IObservableMap } from '@jupyterlab/observables';
 
 import {
   IOutputPrompt,
@@ -39,21 +37,21 @@
 
 import { Kernel, KernelMessage } from '@jupyterlab/services';
 
-import { IMapChange } from '@jupyter/ydoc';
-
-import { TableOfContentsUtils } from '@jupyterlab/toc';
-
-import { ITranslator, nullTranslator } from '@jupyterlab/translation';
-
-import { addIcon, collapseIcon, expandIcon } from '@jupyterlab/ui-components';
-
-import { JSONObject, PromiseDelegate, UUID } from '@lumino/coreutils';
-
-import { some } from '@lumino/algorithm';
-
-import { Drag } from '@lumino/dragdrop';
-
-import { Message, MessageLoop } from '@lumino/messaging';
+import { addIcon } from '@jupyterlab/ui-components';
+
+import {
+  JSONObject,
+  JSONValue,
+  PartialJSONValue,
+  PromiseDelegate,
+  UUID
+} from '@lumino/coreutils';
+
+import { filter, some, toArray } from '@lumino/algorithm';
+
+import { IDragEvent } from '@lumino/dragdrop';
+
+import { Message } from '@lumino/messaging';
 
 import { Debouncer } from '@lumino/polling';
 
@@ -73,7 +71,6 @@
 import { IInputPrompt, InputArea, InputPrompt } from './inputarea';
 
 import {
-  CellModel,
   IAttachmentsCellModel,
   ICellModel,
   ICodeCellModel,
@@ -131,6 +128,11 @@
 const CELL_OUTPUT_COLLAPSER_CLASS = 'jp-Cell-outputCollapser';
 
 /**
+ * The class name added to the cell when readonly.
+ */
+const READONLY_CLASS = 'jp-mod-readOnly';
+
+/**
  * The class name added to the cell when dirty.
  */
 const DIRTY_CLASS = 'jp-mod-dirty';
@@ -150,7 +152,7 @@
  */
 const MARKDOWN_OUTPUT_CLASS = 'jp-MarkdownOutput';
 
-const MARKDOWN_HEADING_COLLAPSED = 'jp-MarkdownHeadingCollapsed';
+export const MARKDOWN_HEADING_COLLAPSED = 'jp-MarkdownHeadingCollapsed';
 
 const HEADING_COLLAPSER_CLASS = 'jp-collapseHeadingButton';
 
@@ -198,385 +200,9 @@
     super();
     this.addClass(CELL_CLASS);
     const model = (this._model = options.model);
-
-    this.contentFactory = options.contentFactory;
-    this.layout = options.layout ?? new PanelLayout();
-    // Set up translator for aria labels
-    this.translator = options.translator ?? nullTranslator;
-
-    // For cells disable searching with CodeMirror search panel.
-    this._editorConfig = { searchWithCM: false, ...options.editorConfig };
-    this._editorExtensions = options.editorExtensions ?? [];
-    this._editorExtensions.push(this._scrollHandlerExtension);
-    this._placeholder = true;
-    this._inViewport = null;
-    this.placeholder = options.placeholder ?? true;
-
-    model.metadataChanged.connect(this.onMetadataChanged, this);
-  }
-
-  /**
-   * Initialize view state from model.
-   *
-   * #### Notes
-   * Should be called after construction. For convenience, returns this, so it
-   * can be chained in the construction, like `new Foo().initializeState();`
-   */
-  initializeState(): this {
-    this.loadCollapseState();
-    this.loadEditableState();
-    return this;
-  }
-
-  /**
-   * The content factory used by the widget.
-   */
-  readonly contentFactory: Cell.IContentFactory;
-
-  /**
-   * Signal to indicate that widget has changed visibly (in size, in type, etc)
-   */
-  get displayChanged(): ISignal<this, void> {
-    return this._displayChanged;
-  }
-
-  /**
-   * Whether the cell is in viewport or not.
-   *
-   * #### Notes
-   * This property is managed by the windowed container which holds the cell.
-   * When a cell is not in a windowed container, it always returns `false`,
-   * but this may change in the future major version.
-   */
-  get inViewport(): boolean {
-    return this._inViewport ?? false;
-  }
-  set inViewport(v: boolean) {
-    if (this._inViewport !== v) {
-      this._inViewport = v;
-      this._inViewportChanged.emit(this._inViewport);
-    }
-  }
-
-  /**
-   * Will emit true just after the node is attached to the DOM
-   * Will emit false just before the node is detached of the DOM
-   */
-  get inViewportChanged(): ISignal<Cell, boolean> {
-    return this._inViewportChanged;
-  }
-
-  /**
-   * Whether the cell is a placeholder not yet fully rendered or not.
-   */
-  protected get placeholder(): boolean {
-    return this._placeholder;
-  }
-  protected set placeholder(v: boolean) {
-    if (this._placeholder !== v && v === false) {
-      this.initializeDOM();
-      this._placeholder = v;
-      this._ready.resolve();
-    }
-  }
-
-  /**
-   * Get the prompt node used by the cell.
-   */
-  get promptNode(): HTMLElement | null {
-    if (this.placeholder) {
-      return null;
-    }
-
-    if (!this._inputHidden) {
-      return this._input!.promptNode;
-    } else {
-      return (this._inputPlaceholder!.node as HTMLElement)
-        .firstElementChild as HTMLElement;
-    }
-  }
-
-  /**
-   * Get the CodeEditorWrapper used by the cell.
-   */
-  get editorWidget(): CodeEditorWrapper | null {
-    return this._input?.editorWidget ?? null;
-  }
-
-  /**
-   * Get the CodeEditor used by the cell.
-   */
-  get editor(): CodeEditor.IEditor | null {
-    return this._input?.editor ?? null;
-  }
-
-  /**
-   * Editor configuration
-   */
-  get editorConfig(): Record<string, any> {
-    return this._editorConfig;
-  }
-
-  /**
-   * Cell headings
-   */
-  get headings(): Cell.IHeading[] {
-    return new Array<Cell.IHeading>();
-  }
-
-  /**
-   * Get the model used by the cell.
-   */
-  get model(): T {
-    return this._model;
-  }
-
-  /**
-   * Get the input area for the cell.
-   */
-  get inputArea(): InputArea | null {
-    return this._input;
-  }
-
-  /**
-   * The read only state of the cell.
-   */
-  get readOnly(): boolean {
-    return this._readOnly;
-  }
-  set readOnly(value: boolean) {
-    if (value === this._readOnly) {
-      return;
-    }
-    this._readOnly = value;
-    if (this.syncEditable) {
-      this.saveEditableState();
-    }
-    this.update();
-  }
-
-  /**
-   * Whether the cell is a placeholder that defer rendering
-   *
-   * #### Notes
-   * You can wait for the promise `Cell.ready` to wait for the
-   * cell to be rendered.
-   */
-  isPlaceholder(): boolean {
-    return this.placeholder;
-  }
-
-  /**
-   * Save view editable state to model
-   */
-  saveEditableState(): void {
-    const { sharedModel } = this.model;
-    const current = sharedModel.getMetadata('editable') as unknown as boolean;
-
-    if (
-      (this.readOnly && current === false) ||
-      (!this.readOnly && current === undefined)
-    ) {
-      return;
-    }
-    if (this.readOnly) {
-      sharedModel.setMetadata('editable', false);
-    } else {
-      sharedModel.deleteMetadata('editable');
-    }
-  }
-
-  /**
-   * Load view editable state from model.
-   */
-  loadEditableState(): void {
-    this.readOnly =
-      (this.model.sharedModel.getMetadata('editable') as unknown as boolean) ===
-      false;
-  }
-
-  /**
-   * A promise that resolves when the widget renders for the first time.
-   */
-  get ready(): Promise<void> {
-    return this._ready.promise;
-  }
-
-  /**
-   * Set the prompt for the widget.
-   */
-  setPrompt(value: string): void {
-    this.prompt = value;
-    this._input?.setPrompt(value);
-  }
-
-  /**
-   * The view state of input being hidden.
-   */
-  get inputHidden(): boolean {
-    return this._inputHidden;
-  }
-  set inputHidden(value: boolean) {
-    if (this._inputHidden === value) {
-      return;
-    }
-    if (!this.placeholder) {
-      const layout = this._inputWrapper!.layout as PanelLayout;
-      if (value) {
-        this._input!.parent = null;
-        if (this._inputPlaceholder) {
-          this._inputPlaceholder.text = this.model.sharedModel
-            .getSource()
-            .split('\n')?.[0];
-        }
-        layout.addWidget(this._inputPlaceholder!);
-      } else {
-        this._inputPlaceholder!.parent = null;
-        layout.addWidget(this._input!);
-      }
-    }
-    this._inputHidden = value;
-    if (this.syncCollapse) {
-      this.saveCollapseState();
-    }
-    this.handleInputHidden(value);
-  }
-
-  /**
-   * Save view collapse state to model
-   */
-  saveCollapseState(): void {
-    const jupyter = { ...(this.model.getMetadata('jupyter') as any) };
-
-    if (
-      (this.inputHidden && jupyter.source_hidden === true) ||
-      (!this.inputHidden && jupyter.source_hidden === undefined)
-    ) {
-      return;
-    }
-
-    if (this.inputHidden) {
-      jupyter.source_hidden = true;
-    } else {
-      delete jupyter.source_hidden;
-    }
-    if (Object.keys(jupyter).length === 0) {
-      this.model.deleteMetadata('jupyter');
-    } else {
-      this.model.setMetadata('jupyter', jupyter);
-    }
-  }
-
-  /**
-   * Revert view collapse state from model.
-   */
-  loadCollapseState(): void {
-    const jupyter = (this.model.getMetadata('jupyter') as any) ?? {};
-    this.inputHidden = !!jupyter.source_hidden;
-  }
-
-  /**
-   * Handle the input being hidden.
-   *
-   * #### Notes
-   * This is called by the `inputHidden` setter so that subclasses
-   * can perform actions upon the input being hidden without accessing
-   * private state.
-   */
-  protected handleInputHidden(value: boolean): void {
-    return;
-  }
-
-  /**
-   * Whether to sync the collapse state to the cell model.
-   */
-  get syncCollapse(): boolean {
-    return this._syncCollapse;
-  }
-  set syncCollapse(value: boolean) {
-    if (this._syncCollapse === value) {
-      return;
-    }
-    this._syncCollapse = value;
-    if (value) {
-      this.loadCollapseState();
-    }
-  }
-
-  /**
-   * Whether to sync the editable state to the cell model.
-   */
-  get syncEditable(): boolean {
-    return this._syncEditable;
-  }
-  set syncEditable(value: boolean) {
-    if (this._syncEditable === value) {
-      return;
-    }
-    this._syncEditable = value;
-    if (value) {
-      this.loadEditableState();
-    }
-  }
-
-  /**
-   * Clone the cell, using the same model.
-   */
-  clone(): Cell<T> {
-    const constructor = this.constructor as typeof Cell;
-    return new constructor({
-      model: this.model,
-      contentFactory: this.contentFactory,
-      placeholder: false,
-      translator: this.translator
-    });
-  }
-
-  /**
-   * Dispose of the resources held by the widget.
-   */
-  dispose(): void {
-    // Do nothing if already disposed.
-    if (this.isDisposed) {
-      return;
-    }
-    this._resizeDebouncer.dispose();
-    this._input = null!;
-    this._model = null!;
-    this._inputWrapper = null!;
-    this._inputPlaceholder = null!;
-    super.dispose();
-  }
-
-  /**
-   * Update the editor configuration with the partial provided dictionary.
-   *
-   * @param v Partial editor configuration
-   */
-  updateEditorConfig(v: Record<string, any>): void {
-    this._editorConfig = { ...this._editorConfig, ...v };
-    if (this.editor) {
-      this.editor.setOptions(this._editorConfig);
-    }
-  }
-
-  /**
-   * Signal emitted when cell requests scrolling to its element.
-   */
-  get scrollRequested(): ISignal<Cell, Cell.IScrollRequest> {
-    return this._scrollRequested;
-  }
-
-  /**
-   * Create children widgets.
-   */
-  protected initializeDOM(): void {
-    if (!this.placeholder) {
-      return;
-    }
-
-    const contentFactory = this.contentFactory;
-    const model = this._model;
+    const contentFactory = (this.contentFactory =
+      options.contentFactory || Cell.defaultContentFactory);
+    this.layout = new PanelLayout();
 
     // Header
     const header = contentFactory.createCellHeader();
@@ -591,56 +217,283 @@
     const input = (this._input = new InputArea({
       model,
       contentFactory,
-      editorOptions: this.getEditorOptions()
+      updateOnShow: options.updateEditorOnShow,
+      placeholder: options.placeholder
     }));
     input.addClass(CELL_INPUT_AREA_CLASS);
     inputWrapper.addWidget(inputCollapser);
     inputWrapper.addWidget(input);
     (this.layout as PanelLayout).addWidget(inputWrapper);
 
-    this._inputPlaceholder = new InputPlaceholder({
-      callback: () => {
-        this.inputHidden = !this.inputHidden;
-      },
-      text: input.model.sharedModel.getSource().split('\n')[0],
-      translator: this.translator
+    this._inputPlaceholder = new InputPlaceholder(() => {
+      this.inputHidden = !this.inputHidden;
     });
-
-    input.model.contentChanged.connect((sender, args) => {
-      if (this._inputPlaceholder && this.inputHidden) {
-        this._inputPlaceholder.text = sender.sharedModel
-          .getSource()
-          .split('\n')?.[0];
-      }
-    });
-
-    if (this.inputHidden) {
-      input.parent = null;
-      (inputWrapper.layout as PanelLayout).addWidget(this._inputPlaceholder!);
-    }
 
     // Footer
     const footer = this.contentFactory.createCellFooter();
     footer.addClass(CELL_FOOTER_CLASS);
     (this.layout as PanelLayout).addWidget(footer);
-  }
-
-  /**
-   * Get the editor options at initialization.
+
+    // Editor settings
+    if (options.editorConfig) {
+      this.editor.setOptions({ ...options.editorConfig });
+    }
+
+    model.metadata.changed.connect(this.onMetadataChanged, this);
+  }
+
+  /**
+   * Initialize view state from model.
    *
-   * @returns Editor options
-   */
-  protected getEditorOptions(): InputArea.IOptions['editorOptions'] {
-    return { config: this.editorConfig, extensions: this._editorExtensions };
-  }
-
-  /**
-   * Handle `before-attach` messages.
-   */
-  protected onBeforeAttach(msg: Message): void {
-    if (this.placeholder) {
-      this.placeholder = false;
-    }
+   * #### Notes
+   * Should be called after construction. For convenience, returns this, so it
+   * can be chained in the construction, like `new Foo().initializeState();`
+   */
+  initializeState(): this {
+    this.loadCollapseState();
+    this.loadEditableState();
+    return this;
+  }
+
+  /**
+   * The content factory used by the widget.
+   */
+  readonly contentFactory: Cell.IContentFactory;
+
+  /**
+   * Signal to indicate that widget has changed visibly (in size, in type, etc)
+   */
+  get displayChanged(): ISignal<this, void> {
+    return this._displayChanged;
+  }
+
+  /**
+   * Get the prompt node used by the cell.
+   */
+  get promptNode(): HTMLElement {
+    if (!this._inputHidden) {
+      return this._input.promptNode;
+    } else {
+      return (this._inputPlaceholder!.node as HTMLElement)
+        .firstElementChild as HTMLElement;
+    }
+  }
+
+  /**
+   * Get the CodeEditorWrapper used by the cell.
+   */
+  get editorWidget(): CodeEditorWrapper {
+    return this._input.editorWidget;
+  }
+
+  /**
+   * Get the CodeEditor used by the cell.
+   */
+  get editor(): CodeEditor.IEditor {
+    return this._input.editor;
+  }
+
+  /**
+   * Get the model used by the cell.
+   */
+  get model(): T {
+    return this._model;
+  }
+
+  /**
+   * Get the input area for the cell.
+   */
+  get inputArea(): InputArea {
+    return this._input;
+  }
+
+  /**
+   * The read only state of the cell.
+   */
+  get readOnly(): boolean {
+    return this._readOnly;
+  }
+  set readOnly(value: boolean) {
+    if (value === this._readOnly) {
+      return;
+    }
+    this._readOnly = value;
+    if (this.syncEditable) {
+      this.saveEditableState();
+    }
+    this.update();
+  }
+
+  /**
+   * Save view editable state to model
+   */
+  saveEditableState() {
+    const { metadata } = this.model;
+    const current = metadata.get('editable');
+
+    if (
+      (this.readOnly && current === false) ||
+      (!this.readOnly && current === undefined)
+    ) {
+      return;
+    }
+
+    if (this.readOnly) {
+      this.model.metadata.set('editable', false);
+    } else {
+      this.model.metadata.delete('editable');
+    }
+  }
+
+  /**
+   * Load view editable state from model.
+   */
+  loadEditableState() {
+    this.readOnly = this.model.metadata.get('editable') === false;
+  }
+
+  /**
+   * A promise that resolves when the widget renders for the first time.
+   */
+  get ready(): Promise<void> {
+    return Promise.resolve(undefined);
+  }
+
+  /**
+   * Set the prompt for the widget.
+   */
+  setPrompt(value: string): void {
+    this._input.setPrompt(value);
+  }
+
+  /**
+   * The view state of input being hidden.
+   */
+  get inputHidden(): boolean {
+    return this._inputHidden;
+  }
+  set inputHidden(value: boolean) {
+    if (this._inputHidden === value) {
+      return;
+    }
+    const layout = this._inputWrapper.layout as PanelLayout;
+    if (value) {
+      this._input.parent = null;
+      layout.addWidget(this._inputPlaceholder);
+    } else {
+      this._inputPlaceholder.parent = null;
+      layout.addWidget(this._input);
+    }
+    this._inputHidden = value;
+    if (this.syncCollapse) {
+      this.saveCollapseState();
+    }
+    this.handleInputHidden(value);
+  }
+
+  /**
+   * Save view collapse state to model
+   */
+  saveCollapseState() {
+    const jupyter = { ...(this.model.metadata.get('jupyter') as any) };
+
+    if (
+      (this.inputHidden && jupyter.source_hidden === true) ||
+      (!this.inputHidden && jupyter.source_hidden === undefined)
+    ) {
+      return;
+    }
+
+    if (this.inputHidden) {
+      jupyter.source_hidden = true;
+    } else {
+      delete jupyter.source_hidden;
+    }
+    if (Object.keys(jupyter).length === 0) {
+      this.model.metadata.delete('jupyter');
+    } else {
+      this.model.metadata.set('jupyter', jupyter);
+    }
+  }
+
+  /**
+   * Revert view collapse state from model.
+   */
+  loadCollapseState() {
+    const jupyter = (this.model.metadata.get('jupyter') as any) || {};
+    this.inputHidden = !!jupyter.source_hidden;
+  }
+
+  /**
+   * Handle the input being hidden.
+   *
+   * #### Notes
+   * This is called by the `inputHidden` setter so that subclasses
+   * can perform actions upon the input being hidden without accessing
+   * private state.
+   */
+  protected handleInputHidden(value: boolean): void {
+    return;
+  }
+
+  /**
+   * Whether to sync the collapse state to the cell model.
+   */
+  get syncCollapse(): boolean {
+    return this._syncCollapse;
+  }
+  set syncCollapse(value: boolean) {
+    if (this._syncCollapse === value) {
+      return;
+    }
+    this._syncCollapse = value;
+    if (value) {
+      this.loadCollapseState();
+    }
+  }
+
+  /**
+   * Whether to sync the editable state to the cell model.
+   */
+  get syncEditable(): boolean {
+    return this._syncEditable;
+  }
+  set syncEditable(value: boolean) {
+    if (this._syncEditable === value) {
+      return;
+    }
+    this._syncEditable = value;
+    if (value) {
+      this.loadEditableState();
+    }
+  }
+
+  /**
+   * Clone the cell, using the same model.
+   */
+  clone(): Cell<T> {
+    const constructor = this.constructor as typeof Cell;
+    return new constructor({
+      model: this.model,
+      contentFactory: this.contentFactory,
+      placeholder: false
+    });
+  }
+
+  /**
+   * Dispose of the resources held by the widget.
+   */
+  dispose() {
+    // Do nothing if already disposed.
+    if (this.isDisposed) {
+      return;
+    }
+    this._resizeDebouncer.dispose();
+    this._input = null!;
+    this._model = null!;
+    this._inputWrapper = null!;
+    this._inputPlaceholder = null!;
+    super.dispose();
   }
 
   /**
@@ -654,7 +507,15 @@
    * Handle `'activate-request'` messages.
    */
   protected onActivateRequest(msg: Message): void {
-    this.editor?.focus();
+    this.editor.focus();
+  }
+
+  /**
+   * Handle `fit-request` messages.
+   */
+  protected onFitRequest(msg: Message): void {
+    // need this for for when a theme changes font size
+    this.editor.refresh();
   }
 
   /**
@@ -672,23 +533,19 @@
       return;
     }
     // Handle read only state.
-    if (this.editor?.getOption('readOnly') !== this._readOnly) {
-      this.editor?.setOption('readOnly', this._readOnly);
-    }
-  }
-
-  protected onContentChanged() {
-    if (this.inputHidden && this._inputPlaceholder) {
-      this._inputPlaceholder.text = this.model.sharedModel
-        .getSource()
-        .split('\n')?.[0];
+    if (this.editor.getOption('readOnly') !== this._readOnly) {
+      this.editor.setOption('readOnly', this._readOnly);
+      this.toggleClass(READONLY_CLASS, this._readOnly);
     }
   }
 
   /**
    * Handle changes in the metadata.
    */
-  protected onMetadataChanged(model: CellModel, args: IMapChange): void {
+  protected onMetadataChanged(
+    model: IObservableJSON,
+    args: IObservableMap.IChangedArgs<PartialJSONValue | undefined>
+  ): void {
     switch (args.key) {
       case 'jupyter':
         if (this.syncCollapse) {
@@ -705,58 +562,18 @@
     }
   }
 
-  protected prompt = '';
-  protected translator: ITranslator;
   protected _displayChanged = new Signal<this, void>(this);
-  protected _scrollRequested = new Signal<Cell, Cell.IScrollRequest>(this);
-  protected _inViewport: boolean | null;
-
-  /**
-   * Editor extension emitting `scrollRequested` signal on scroll.
-   *
-   * Scrolling within editor will be prevented when a cell is out out viewport.
-   * Windowed containers including cells should listen to the scroll request
-   * signal and invoke the `scrollWithinCell()` callback after scrolling the cell
-   * back into the view (and after updating the `inViewport` property).
-   */
-  private _scrollHandlerExtension = EditorView.scrollHandler.of(
-    (view, range, options) => {
-      // When cell is in the viewport we can scroll within the editor immediately.
-      // When cell is out of viewport, the windowed container needs to first
-      // scroll the cell into the viewport (otherwise CodeMirror is unable to
-      // calculate the correct scroll delta) before invoking scrolling in editor.
-      const inWindowedContainer = this._inViewport !== null;
-      const preventDefault = inWindowedContainer && !this._inViewport;
-      this._scrollRequested.emit({
-        defaultPrevented: preventDefault,
-        scrollWithinCell: () => {
-          view.dispatch({
-            effects: EditorView.scrollIntoView(range, options)
-          });
-        }
-      });
-      return preventDefault;
-    }
-  );
-
-  private _editorConfig: Record<string, any> = {};
-  private _editorExtensions: Extension[] = [];
-  private _input: InputArea | null;
+  private _readOnly = false;
+  private _model: T;
   private _inputHidden = false;
-  private _inputWrapper: Widget | null;
-  private _inputPlaceholder: InputPlaceholder | null;
-  private _inViewportChanged: Signal<Cell, boolean> = new Signal<Cell, boolean>(
-    this
-  );
-  private _model: T;
-  private _placeholder: boolean;
-  private _readOnly = false;
-  private _ready = new PromiseDelegate<void>();
+  private _input: InputArea;
+  private _inputWrapper: Widget;
+  private _inputPlaceholder: InputPlaceholder;
+  private _syncCollapse = false;
+  private _syncEditable = false;
   private _resizeDebouncer = new Debouncer(() => {
     this._displayChanged.emit();
   }, 0);
-  private _syncCollapse = false;
-  private _syncEditable = false;
 }
 
 /**
@@ -775,22 +592,17 @@
     /**
      * The factory object for customizable cell children.
      */
-    contentFactory: IContentFactory;
+    contentFactory?: IContentFactory;
 
     /**
      * The configuration options for the text editor widget.
      */
-    editorConfig?: Record<string, any>;
+    editorConfig?: Partial<CodeEditor.IConfig>;
 
     /**
-     * Editor extensions to be added.
+     * Whether to send an update request to the editor when it is shown.
      */
-    editorExtensions?: Extension[];
-
-    /**
-     * Cell widget layout.
-     */
-    layout?: PanelLayout;
+    updateEditorOnShow?: boolean;
 
     /**
      * The maximum number of output items to display in cell output.
@@ -798,58 +610,9 @@
     maxNumberOutputs?: number;
 
     /**
-     * Whether to split stdin line history by kernel session or keep globally accessible.
-     */
-    inputHistoryScope?: 'global' | 'session';
-
-    /**
      * Whether this cell is a placeholder for future rendering.
      */
     placeholder?: boolean;
-
-    /**
-     * The application language translator.
-     */
-    translator?: ITranslator;
-  }
-
-  /**
-   * Cell heading
-   */
-  export interface IHeading {
-    /**
-     * Heading text.
-     */
-    text: string;
-
-    /**
-     * HTML heading level.
-     */
-    level: number;
-
-    /**
-     * Index of the output containing the heading
-     */
-    outputIndex?: number;
-
-    /**
-     * Type of heading
-     */
-    type: HeadingType;
-  }
-
-  /**
-   * Type of headings
-   */
-  export enum HeadingType {
-    /**
-     * Heading from HTML output
-     */
-    HTML,
-    /**
-     * Heading from Markdown cell or Markdown output
-     */
-    Markdown
   }
 
   /**
@@ -884,8 +647,9 @@
     /**
      * Create a content factory for a cell.
      */
-    constructor(options: ContentFactory.IOptions) {
-      this._editorFactory = options.editorFactory;
+    constructor(options: ContentFactory.IOptions = {}) {
+      this._editorFactory =
+        options.editorFactory || InputArea.defaultEditorFactory;
     }
 
     /**
@@ -903,7 +667,7 @@
     }
 
     /**
-     * Create a new cell footer for the parent widget.
+     * Create a new cell header for the parent widget.
      */
     createCellFooter(): ICellFooter {
       return new CellFooter();
@@ -943,29 +707,18 @@
     export interface IOptions {
       /**
        * The editor factory used by the content factory.
+       *
+       * If this is not passed, a default CodeMirror editor factory
+       * will be used.
        */
-      editorFactory: CodeEditor.Factory;
-    }
-  }
-
-  /**
-   * Value of the signal emitted by cell on editor scroll request.
-   */
-  export interface IScrollRequest {
-    /**
-     * Scrolls to the target cell part, fulfilling the scroll request.
-     *
-     * ### Notes
-     * This method is intended for use by windowed containers that
-     * require the cell to be first scrolled into the viewport to
-     * then enable proper scrolling within cell.
-     */
-    scrollWithinCell: (options: { scroller: HTMLElement }) => void;
-    /**
-     * Whether the default scrolling was prevented due to the cell being out of viewport.
-     */
-    defaultPrevented: boolean;
-  }
+      editorFactory?: CodeEditor.Factory;
+    }
+  }
+
+  /**
+   * The default content factory for cells.
+   */
+  export const defaultContentFactory = new ContentFactory();
 }
 
 /** ****************************************************************************
@@ -973,82 +726,6 @@
  ******************************************************************************/
 
 /**
- * Code cell layout
- *
- * It will not detached the output area when the cell is detached.
- */
-export class CodeCellLayout extends PanelLayout {
-  /**
-   * A message handler invoked on a `'before-attach'` message.
-   *
-   * #### Notes
-   * The default implementation of this method forwards the message
-   * to all widgets. It assumes all widget nodes are attached to the
-   * parent widget node.
-   *
-   * This may be reimplemented by subclasses as needed.
-   */
-  protected onBeforeAttach(msg: Message): void {
-    let beforeOutputArea = true;
-    const outputAreaWrapper = this.parent!.node.firstElementChild;
-    for (const widget of this) {
-      if (outputAreaWrapper) {
-        if (widget.node === outputAreaWrapper) {
-          beforeOutputArea = false;
-        } else {
-          MessageLoop.sendMessage(widget, msg);
-
-          if (beforeOutputArea) {
-            this.parent!.node.insertBefore(widget.node, outputAreaWrapper);
-          } else {
-            this.parent!.node.appendChild(widget.node);
-          }
-
-          // Force setting isVisible to true as it requires the parent widget to be
-          // visible. But that flag will be set only during the `onAfterAttach` call.
-          if (!this.parent!.isHidden) {
-            widget.setFlag(Widget.Flag.IsVisible);
-          }
-
-          // Not called in NotebookWindowedLayout to avoid outputArea
-          // widgets unwanted update or reset.
-          MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);
-        }
-      }
-    }
-  }
-
-  /**
-   * A message handler invoked on an `'after-detach'` message.
-   *
-   * #### Notes
-   * The default implementation of this method forwards the message
-   * to all widgets. It assumes all widget nodes are attached to the
-   * parent widget node.
-   *
-   * This may be reimplemented by subclasses as needed.
-   */
-  protected onAfterDetach(msg: Message): void {
-    for (const widget of this) {
-      // TODO we could improve this further by removing outputs based
-      // on their mime type (for example plain/text or markdown could safely be detached)
-      // If the cell is out of the view port, its children are already detached -> skip detaching
-      if (
-        !widget.hasClass(CELL_OUTPUT_WRAPPER_CLASS) &&
-        widget.node.isConnected
-      ) {
-        // Not called in NotebookWindowedLayout for windowed notebook
-        MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);
-
-        this.parent!.node.removeChild(widget.node);
-
-        MessageLoop.sendMessage(widget, msg);
-      }
-    }
-  }
-}
-
-/**
  * A widget for a code cell.
  */
 export class CodeCell extends Cell<ICodeCellModel> {
@@ -1056,206 +733,48 @@
    * Construct a code cell widget.
    */
   constructor(options: CodeCell.IOptions) {
-    super({ layout: new CodeCellLayout(), ...options, placeholder: true });
+    super(options);
     this.addClass(CODE_CELL_CLASS);
-    const trans = this.translator.load('jupyterlab');
 
     // Only save options not handled by parent constructor.
     const rendermime = (this._rendermime = options.rendermime);
     const contentFactory = this.contentFactory;
     const model = this.model;
-    this.maxNumberOutputs = options.maxNumberOutputs;
-
-    // Note that modifying the below label warrants one to also modify
-    // the same in this._outputLengthHandler. Ideally, this label must
-    // have been a constant and used in both places but it is not done
-    // so because of limitations in the translation manager.
-    const ariaLabel =
-      model.outputs.length === 0
-        ? trans.__('Code Cell Content')
-        : trans.__('Code Cell Content with Output');
-    this.node.setAttribute('aria-label', ariaLabel);
-
-    const output = (this._output = new OutputArea({
-      model: this.model.outputs,
-      rendermime,
-      contentFactory: contentFactory,
-      maxNumberOutputs: this.maxNumberOutputs,
-      translator: this.translator,
-      promptOverlay: true,
-      inputHistoryScope: options.inputHistoryScope
-    }));
-    output.node.addEventListener('keydown', this._detectCaretMovementInOuput);
-
-    output.addClass(CELL_OUTPUT_AREA_CLASS);
-    output.toggleScrolling.connect(() => {
-      this.outputsScrolled = !this.outputsScrolled;
-    });
-    output.initialize.connect(() => {
-      this.updatePromptOverlayIcon();
-    });
-    // Defer setting placeholder as OutputArea must be instantiated before initializing the DOM
-    this.placeholder = options.placeholder ?? true;
-
-    model.outputs.changed.connect(this.onOutputChanged, this);
-    model.outputs.stateChanged.connect(this.onOutputChanged, this);
+
+    if (!options.placeholder) {
+      // Insert the output before the cell footer.
+      const outputWrapper = (this._outputWrapper = new Panel());
+      outputWrapper.addClass(CELL_OUTPUT_WRAPPER_CLASS);
+      const outputCollapser = new OutputCollapser();
+      outputCollapser.addClass(CELL_OUTPUT_COLLAPSER_CLASS);
+      const output = (this._output = new OutputArea({
+        model: model.outputs,
+        rendermime,
+        contentFactory: contentFactory,
+        maxNumberOutputs: options.maxNumberOutputs
+      }));
+      output.addClass(CELL_OUTPUT_AREA_CLASS);
+      // Set a CSS if there are no outputs, and connect a signal for future
+      // changes to the number of outputs. This is for conditional styling
+      // if there are no outputs.
+      if (model.outputs.length === 0) {
+        this.addClass(NO_OUTPUTS_CLASS);
+      }
+      output.outputLengthChanged.connect(this._outputLengthHandler, this);
+      outputWrapper.addWidget(outputCollapser);
+      outputWrapper.addWidget(output);
+      (this.layout as PanelLayout).insertWidget(2, new ResizeHandle(this.node));
+      (this.layout as PanelLayout).insertWidget(3, outputWrapper);
+
+      if (model.isDirty) {
+        this.addClass(DIRTY_CLASS);
+      }
+
+      this._outputPlaceholder = new OutputPlaceholder(() => {
+        this.outputHidden = !this.outputHidden;
+      });
+    }
     model.stateChanged.connect(this.onStateChanged, this);
-  }
-
-  /**
-   * Detect the movement of the caret in the output area.
-   *
-   * Emits scroll request if the caret moved.
-   */
-  private _detectCaretMovementInOuput = (e: KeyboardEvent) => {
-    const inWindowedContainer = this._inViewport !== null;
-    const defaultPrevented = inWindowedContainer && !this._inViewport;
-
-    // Because we do not want to scroll on any key, but only on keys which
-    // move the caret (this on keys which cause input and on keys like left,
-    // right, top, bottom arrow, home, end, page down/up - but only if the
-    // cursor is not at the respective end of the input) we need to listen
-    // to the `selectionchange` event on target inputs/textareas, etc.
-    const target = e.target;
-
-    if (!target || !(target instanceof HTMLElement)) {
-      return;
-    }
-
-    // Make sure the previous listener gets disconnected
-    if (this._lastTarget) {
-      this._lastTarget.removeEventListener(
-        'selectionchange',
-        this._lastOnCaretMovedHandler
-      );
-      document.removeEventListener(
-        'selectionchange',
-        this._lastOnCaretMovedHandler
-      );
-    }
-
-    const onCaretMoved = () => {
-      this._scrollRequested.emit({
-        scrollWithinCell: ({ scroller }) => {
-          ElementExt.scrollIntoViewIfNeeded(scroller, target);
-        },
-        defaultPrevented
-      });
-    };
-
-    // Remember the most recent target/handler to disconnect them next time.
-    this._lastTarget = target;
-    this._lastOnCaretMovedHandler = onCaretMoved;
-
-    // Firefox only supports `selectionchange` on the actual input element,
-    // all other browsers only support it on the top-level document.
-    target.addEventListener('selectionchange', onCaretMoved, { once: true });
-    document.addEventListener('selectionchange', onCaretMoved, {
-      once: true
-    });
-
-    // Schedule removal of the listener.
-    setTimeout(() => {
-      target.removeEventListener('selectionchange', onCaretMoved);
-      document.removeEventListener('selectionchange', onCaretMoved);
-    }, 250);
-  };
-
-  /**
-   * Maximum number of outputs to display.
-   */
-  protected maxNumberOutputs: number | undefined;
-
-  /**
-   * Create children widgets.
-   */
-  protected initializeDOM(): void {
-    if (!this.placeholder) {
-      return;
-    }
-
-    super.initializeDOM();
-
-    this.setPrompt(this.prompt);
-
-    // Insert the output before the cell footer.
-    const outputWrapper = (this._outputWrapper = new Panel());
-    outputWrapper.addClass(CELL_OUTPUT_WRAPPER_CLASS);
-    const outputCollapser = new OutputCollapser();
-    outputCollapser.addClass(CELL_OUTPUT_COLLAPSER_CLASS);
-    outputWrapper.addWidget(outputCollapser);
-    // Set a CSS if there are no outputs, and connect a signal for future
-    // changes to the number of outputs. This is for conditional styling
-    // if there are no outputs.
-    if (this.model.outputs.length === 0) {
-      this.addClass(NO_OUTPUTS_CLASS);
-    }
-    this._output.outputLengthChanged.connect(this._outputLengthHandler, this);
-    outputWrapper.addWidget(this._output);
-    const layout = this.layout as PanelLayout;
-    const resizeHandle = new ResizeHandle(this.node);
-    resizeHandle.sizeChanged.connect(this._sizeChangedHandler, this);
-    layout.insertWidget(layout.widgets.length - 1, resizeHandle);
-    layout.insertWidget(layout.widgets.length - 1, outputWrapper);
-
-    if (this.model.isDirty) {
-      this.addClass(DIRTY_CLASS);
-    }
-
-    this._outputPlaceholder = new OutputPlaceholder({
-      callback: () => {
-        this.outputHidden = !this.outputHidden;
-      },
-      text: this.getOutputPlaceholderText(),
-      translator: this.translator
-    });
-
-    const layoutWrapper = outputWrapper.layout as PanelLayout;
-    if (this.outputHidden) {
-      layoutWrapper.removeWidget(this._output);
-      layoutWrapper.addWidget(this._outputPlaceholder);
-      if (this.inputHidden && !outputWrapper.isHidden) {
-        this._outputWrapper!.hide();
-      }
-    }
-
-    const trans = this.translator.load('jupyterlab');
-    const ariaLabel =
-      this.model.outputs.length === 0
-        ? trans.__('Code Cell Content')
-        : trans.__('Code Cell Content with Output');
-    this.node.setAttribute('aria-label', ariaLabel);
-  }
-
-  protected getOutputPlaceholderText(): string | undefined {
-    const firstOutput = this.model.outputs.get(0);
-    const outputData = firstOutput?.data;
-    if (!outputData) {
-      return undefined;
-    }
-    const supportedOutputTypes = [
-      'text/html',
-      'image/svg+xml',
-      'application/pdf',
-      'text/markdown',
-      'text/plain',
-      'application/vnd.jupyter.stderr',
-      'application/vnd.jupyter.stdout',
-      'text'
-    ];
-    const preferredOutput = supportedOutputTypes.find(mt => {
-      const data = firstOutput.data[mt];
-      return (Array.isArray(data) ? typeof data[0] : typeof data) === 'string';
-    });
-    const dataToDisplay = firstOutput.data[preferredOutput ?? ''];
-    if (dataToDisplay !== undefined) {
-      return (
-        Array.isArray(dataToDisplay)
-          ? dataToDisplay
-          : (dataToDisplay as string)?.split('\n')
-      )?.find(part => part !== '');
-    }
-    return undefined;
   }
 
   /**
@@ -1273,60 +792,6 @@
     return this;
   }
 
-  get headings(): Cell.IHeading[] {
-    if (!this._headingsCache) {
-      const headings: Cell.IHeading[] = [];
-
-      // Iterate over the code cell outputs to check for Markdown or HTML from which we can generate ToC headings...
-      const outputs = this.model.outputs;
-      for (let j = 0; j < outputs.length; j++) {
-        const m = outputs.get(j);
-
-        let htmlType: string | null = null;
-        let mdType: string | null = null;
-
-        Object.keys(m.data).forEach(t => {
-          if (!mdType && TableOfContentsUtils.Markdown.isMarkdown(t)) {
-            mdType = t;
-          } else if (!htmlType && TableOfContentsUtils.isHTML(t)) {
-            htmlType = t;
-          }
-        });
-
-        // Parse HTML output
-        if (htmlType) {
-          headings.push(
-            ...TableOfContentsUtils.getHTMLHeadings(
-              this._rendermime.sanitizer.sanitize(m.data[htmlType] as string)
-            ).map(heading => {
-              return {
-                ...heading,
-                outputIndex: j,
-                type: Cell.HeadingType.HTML
-              };
-            })
-          );
-        } else if (mdType) {
-          headings.push(
-            ...TableOfContentsUtils.Markdown.getHeadings(
-              m.data[mdType] as string
-            ).map(heading => {
-              return {
-                ...heading,
-                outputIndex: j,
-                type: Cell.HeadingType.Markdown
-              };
-            })
-          );
-        }
-      }
-
-      this._headingsCache = headings;
-    }
-
-    return [...this._headingsCache!];
-  }
-
   /**
    * Get the output area for the cell.
    */
@@ -1344,25 +809,19 @@
     if (this._outputHidden === value) {
       return;
     }
-
-    if (!this.placeholder) {
-      const layout = this._outputWrapper!.layout as PanelLayout;
-      if (value) {
-        layout.removeWidget(this._output);
-        layout.addWidget(this._outputPlaceholder!);
-        if (this.inputHidden && !this._outputWrapper!.isHidden) {
-          this._outputWrapper!.hide();
-        }
-        if (this._outputPlaceholder) {
-          this._outputPlaceholder.text = this.getOutputPlaceholderText() ?? '';
-        }
-      } else {
-        if (this._outputWrapper!.isHidden) {
-          this._outputWrapper!.show();
-        }
-        layout.removeWidget(this._outputPlaceholder!);
-        layout.addWidget(this._output);
-      }
+    const layout = this._outputWrapper.layout as PanelLayout;
+    if (value) {
+      layout.removeWidget(this._output);
+      layout.addWidget(this._outputPlaceholder);
+      if (this.inputHidden && !this._outputWrapper.isHidden) {
+        this._outputWrapper.hide();
+      }
+    } else {
+      if (this._outputWrapper.isHidden) {
+        this._outputWrapper.show();
+      }
+      layout.removeWidget(this._outputPlaceholder);
+      layout.addWidget(this._output);
     }
     this._outputHidden = value;
     if (this.syncCollapse) {
@@ -1373,16 +832,19 @@
   /**
    * Save view collapse state to model
    */
-  saveCollapseState(): void {
+  saveCollapseState() {
     // Because collapse state for a code cell involves two different pieces of
     // metadata (the `collapsed` and `jupyter` metadata keys), we block reacting
     // to changes in metadata until we have fully committed our changes.
     // Otherwise setting one key can trigger a write to the other key to
     // maintain the synced consistency.
-    this.model.sharedModel.transact(() => {
+    this._savingMetadata = true;
+
+    try {
       super.saveCollapseState();
 
-      const collapsed = this.model.getMetadata('collapsed');
+      const metadata = this.model.metadata;
+      const collapsed = this.model.metadata.get('collapsed');
 
       if (
         (this.outputHidden && collapsed === true) ||
@@ -1394,11 +856,13 @@
       // Do not set jupyter.outputs_hidden since it is redundant. See
       // and https://github.com/jupyter/nbformat/issues/137
       if (this.outputHidden) {
-        this.model.setMetadata('collapsed', true);
+        metadata.set('collapsed', true);
       } else {
-        this.model.deleteMetadata('collapsed');
-      }
-    }, false);
+        metadata.delete('collapsed');
+      }
+    } finally {
+      this._savingMetadata = false;
+    }
   }
 
   /**
@@ -1407,9 +871,9 @@
    * We consider the `collapsed` metadata key as the source of truth for outputs
    * being hidden.
    */
-  loadCollapseState(): void {
+  loadCollapseState() {
     super.loadCollapseState();
-    this.outputHidden = !!this.model.getMetadata('collapsed');
+    this.outputHidden = !!this.model.metadata.get('collapsed');
   }
 
   /**
@@ -1424,46 +888,14 @@
     if (this.syncScrolled) {
       this.saveScrolledState();
     }
-    this.updatePromptOverlayIcon();
-  }
-
-  /**
-   * Update the Prompt Overlay Icon
-   */
-  updatePromptOverlayIcon(): void {
-    const overlay = DOMUtils.findElement(
-      this.node,
-      'jp-OutputArea-promptOverlay'
-    );
-    if (!overlay) {
-      return;
-    }
-    // If you are changing this, don't forget about svg.
-    const ICON_HEIGHT = 16 + 4 + 4; // 4px for padding
-    if (overlay.clientHeight <= ICON_HEIGHT) {
-      overlay.firstChild?.remove();
-      return;
-    }
-    let overlayTitle: string;
-    if (this._outputsScrolled) {
-      expandIcon.element({
-        container: overlay
-      });
-      overlayTitle = 'Expand Output';
-    } else {
-      collapseIcon.element({
-        container: overlay
-      });
-      overlayTitle = 'Collapse Output';
-    }
-    const trans = this.translator.load('jupyterlab');
-    overlay.title = trans.__(overlayTitle);
-  }
+  }
+
   /**
    * Save view collapse state to model
    */
-  saveScrolledState(): void {
-    const current = this.model.getMetadata('scrolled');
+  saveScrolledState() {
+    const { metadata } = this.model;
+    const current = metadata.get('scrolled');
 
     if (
       (this.outputsScrolled && current === true) ||
@@ -1472,22 +904,23 @@
       return;
     }
     if (this.outputsScrolled) {
-      this.model.setMetadata('scrolled', true);
+      metadata.set('scrolled', true);
     } else {
-      this.outputArea.node.style.height = '';
-      this.model.deleteMetadata('scrolled');
+      metadata.delete('scrolled');
     }
   }
 
   /**
    * Revert view collapse state from model.
    */
-  loadScrolledState(): void {
+  loadScrolledState() {
+    const metadata = this.model.metadata;
+
     // We don't have the notion of 'auto' scrolled, so we make it false.
-    if (this.model.getMetadata('scrolled') === 'auto') {
+    if (metadata.get('scrolled') === 'auto') {
       this.outputsScrolled = false;
     } else {
-      this.outputsScrolled = !!this.model.getMetadata('scrolled');
+      this.outputsScrolled = !!metadata.get('scrolled');
     }
   }
 
@@ -1516,13 +949,10 @@
    * is hidden without accessing private state.
    */
   protected handleInputHidden(value: boolean): void {
-    if (this.placeholder) {
-      return;
-    }
-    if (!value && this._outputWrapper!.isHidden) {
-      this._outputWrapper!.show();
-    } else if (value && !this._outputWrapper!.isHidden && this._outputHidden) {
-      this._outputWrapper!.hide();
+    if (!value && this._outputWrapper.isHidden) {
+      this._outputWrapper.show();
+    } else if (value && !this._outputWrapper.isHidden && this._outputHidden) {
+      this._outputWrapper.hide();
     }
   }
 
@@ -1535,8 +965,7 @@
       model: this.model,
       contentFactory: this.contentFactory,
       rendermime: this._rendermime,
-      placeholder: false,
-      translator: this.translator
+      placeholder: false
     });
   }
 
@@ -1561,10 +990,6 @@
     this._output.outputLengthChanged.disconnect(
       this._outputLengthHandler,
       this
-    );
-    this._output.node.removeEventListener(
-      'keydown',
-      this._detectCaretMovementInOuput
     );
     this._rendermime = null!;
     this._output = null!;
@@ -1594,30 +1019,16 @@
   }
 
   /**
-   * Callback on output changes
-   */
-  protected onOutputChanged(): void {
-    this._headingsCache = null;
-    if (this._outputPlaceholder && this.outputHidden) {
-      this._outputPlaceholder.text = this.getOutputPlaceholderText() ?? '';
-    }
-    // This is to hide/show icon on single line output.
-    this.updatePromptOverlayIcon();
-
-    // Clear output area when empty
-    const height = this.outputArea.node.style.height;
-    if (this.model.outputs.length === 0 && height !== '') {
-      this._lastOutputHeight = height;
-      this.outputArea.node.style.height = '';
-    } else if (this.model.outputs.length > 0 && height === '') {
-      this.outputArea.node.style.height = this._lastOutputHeight;
-    }
-  }
-
-  /**
    * Handle changes in the metadata.
    */
-  protected onMetadataChanged(model: CellModel, args: IMapChange): void {
+  protected onMetadataChanged(
+    model: IObservableJSON,
+    args: IObservableMap.IChangedArgs<JSONValue>
+  ): void {
+    if (this._savingMetadata) {
+      // We are in middle of a metadata transaction, so don't react to it.
+      return;
+    }
     switch (args.key) {
       case 'scrolled':
         if (this.syncScrolled) {
@@ -1641,31 +1052,16 @@
   private _outputLengthHandler(sender: OutputArea, args: number) {
     const force = args === 0 ? true : false;
     this.toggleClass(NO_OUTPUTS_CLASS, force);
-    const trans = this.translator.load('jupyterlab');
-    const ariaLabel = force
-      ? trans.__('Code Cell Content')
-      : trans.__('Code Cell Content with Output');
-    this.node.setAttribute('aria-label', ariaLabel);
-  }
-
-  /**
-   * Handle changes in input/output proportions in side-by-side mode.
-   */
-  private _sizeChangedHandler(sender: ResizeHandle) {
-    this._displayChanged.emit();
-  }
-
-  private _headingsCache: Cell.IHeading[] | null = null;
+  }
+
   private _rendermime: IRenderMimeRegistry;
   private _outputHidden = false;
   private _outputsScrolled: boolean;
-  private _outputWrapper: Widget | null = null;
-  private _outputPlaceholder: OutputPlaceholder | null = null;
+  private _outputWrapper: Widget;
+  private _outputPlaceholder: OutputPlaceholder;
   private _output: OutputArea;
   private _syncScrolled = false;
-  private _lastOnCaretMovedHandler: () => void;
-  private _lastTarget: HTMLElement | null = null;
-  private _lastOutputHeight = '';
+  private _savingMetadata = false;
 }
 
 /**
@@ -1676,10 +1072,6 @@
    * An options object for initializing a base cell widget.
    */
   export interface IOptions extends Cell.IOptions<ICodeCellModel> {
-    /**
-     * Code cell layout.
-     */
-    layout?: CodeCellLayout;
     /**
      * The mime renderer for the cell widget.
      */
@@ -1695,24 +1087,20 @@
     metadata?: JSONObject
   ): Promise<KernelMessage.IExecuteReplyMsg | void> {
     const model = cell.model;
-    const code = model.sharedModel.getSource();
+    const code = model.value.text;
     if (!code.trim() || !sessionContext.session?.kernel) {
-      model.sharedModel.transact(() => {
-        model.clearExecution();
-      }, false);
+      model.clearExecution();
       return;
     }
-    const cellId = { cellId: model.sharedModel.getId() };
+    const cellId = { cellId: model.id };
     metadata = {
-      ...model.metadata,
+      ...model.metadata.toJSON(),
       ...metadata,
       ...cellId
     };
     const { recordTiming } = metadata;
-    model.sharedModel.transact(() => {
-      model.clearExecution();
-      cell.outputHidden = false;
-    }, false);
+    model.clearExecution();
+    cell.outputHidden = false;
     cell.setPrompt('*');
     model.trusted = true;
     let future:
@@ -1749,15 +1137,15 @@
           const value = msg.header.date || new Date().toISOString();
           const timingInfo: any = Object.assign(
             {},
-            model.getMetadata('execution')
+            model.metadata.get('execution')
           );
           timingInfo[`iopub.${label}`] = value;
-          model.setMetadata('execution', timingInfo);
+          model.metadata.set('execution', timingInfo);
           return true;
         };
         cell.outputArea.future.registerMessageHook(recordTimingHook);
       } else {
-        model.deleteMetadata('execution');
+        model.metadata.delete('execution');
       }
       // Save this execution's future so we can compare in the catch below.
       future = cell.outputArea.future;
@@ -1766,7 +1154,7 @@
       if (recordTiming) {
         const timingInfo = Object.assign(
           {},
-          model.getMetadata('execution') as any
+          model.metadata.get('execution') as any
         );
         const started = msg.metadata.started as string;
         // Started is not in the API, but metadata IPyKernel sends
@@ -1777,7 +1165,7 @@
         const finished = msg.header.date as string;
         timingInfo['shell.execute_reply'] =
           finished || new Date().toISOString();
-        model.setMetadata('execution', timingInfo);
+        model.metadata.set('execution', timingInfo);
       }
       return msg;
     } catch (e) {
@@ -1785,15 +1173,6 @@
       // execution, clear the prompt.
       if (future && !cell.isDisposed && cell.outputArea.future === future) {
         cell.setPrompt('');
-        if (recordTiming && future.isDisposed) {
-          // Record the time when the cell execution was aborted
-          const timingInfo: any = Object.assign(
-            {},
-            model.getMetadata('execution')
-          );
-          timingInfo['execution_failed'] = new Date().toISOString();
-          model.setMetadata('execution', timingInfo);
-        }
       }
       throw e;
     }
@@ -1819,42 +1198,27 @@
    */
   handleEvent(event: Event): void {
     switch (event.type) {
+      case 'paste':
+        this._evtPaste(event as ClipboardEvent);
+        break;
+      case 'dragenter':
+        event.preventDefault();
+        break;
+      case 'dragover':
+        event.preventDefault();
+        break;
+      case 'drop':
+        this._evtNativeDrop(event as DragEvent);
+        break;
       case 'lm-dragover':
-        this._evtDragOver(event as Drag.Event);
+        this._evtDragOver(event as IDragEvent);
         break;
       case 'lm-drop':
-        this._evtDrop(event as Drag.Event);
+        this._evtDrop(event as IDragEvent);
         break;
       default:
         break;
     }
-  }
-
-  /**
-   * Get the editor options at initialization.
-   *
-   * @returns Editor options
-   */
-  protected getEditorOptions(): InputArea.IOptions['editorOptions'] {
-    const base = super.getEditorOptions() ?? {};
-    base.extensions = [
-      ...(base.extensions ?? []),
-      EditorView.domEventHandlers({
-        dragenter: (event: DragEvent) => {
-          event.preventDefault();
-        },
-        dragover: (event: DragEvent) => {
-          event.preventDefault();
-        },
-        drop: (event: DragEvent) => {
-          this._evtNativeDrop(event);
-        },
-        paste: (event: ClipboardEvent) => {
-          this._evtPaste(event);
-        }
-      })
-    ];
-    return base;
   }
 
   /**
@@ -1870,10 +1234,13 @@
    */
   protected onAfterAttach(msg: Message): void {
     super.onAfterAttach(msg);
-
     const node = this.node;
     node.addEventListener('lm-dragover', this);
     node.addEventListener('lm-drop', this);
+    node.addEventListener('dragenter', this);
+    node.addEventListener('dragover', this);
+    node.addEventListener('drop', this);
+    node.addEventListener('paste', this);
   }
 
   /**
@@ -1882,13 +1249,15 @@
    */
   protected onBeforeDetach(msg: Message): void {
     const node = this.node;
+    node.removeEventListener('drop', this);
+    node.removeEventListener('dragover', this);
+    node.removeEventListener('dragenter', this);
+    node.removeEventListener('paste', this);
     node.removeEventListener('lm-dragover', this);
     node.removeEventListener('lm-drop', this);
-
-    super.onBeforeDetach(msg);
-  }
-
-  private _evtDragOver(event: Drag.Event) {
+  }
+
+  private _evtDragOver(event: IDragEvent) {
     const supportedMimeType = some(imageRendererFactory.mimeTypes, mimeType => {
       if (!event.mimeData.hasData(CONTENTS_MIME_RICH)) {
         return false;
@@ -1919,9 +1288,7 @@
             continue;
           }
           items[i].getAsString(text => {
-            this.editor!.replaceSelection?.(
-              text.replace(/\r\n/g, '\n').replace(/\r/g, '\n')
-            );
+            this.editor.replaceSelection?.(text);
           });
         }
         this._attachFiles(event.clipboardData.items);
@@ -1943,18 +1310,20 @@
   /**
    * Handle the `'lm-drop'` event for the widget.
    */
-  private _evtDrop(event: Drag.Event): void {
-    const supportedMimeTypes = event.mimeData.types().filter(mimeType => {
-      if (mimeType === CONTENTS_MIME_RICH) {
-        const data = event.mimeData.getData(
-          CONTENTS_MIME_RICH
-        ) as DirListing.IContentsThunk;
-        return (
-          imageRendererFactory.mimeTypes.indexOf(data.model.mimetype) !== -1
-        );
-      }
-      return imageRendererFactory.mimeTypes.indexOf(mimeType) !== -1;
-    });
+  private _evtDrop(event: IDragEvent): void {
+    const supportedMimeTypes = toArray(
+      filter(event.mimeData.types(), mimeType => {
+        if (mimeType === CONTENTS_MIME_RICH) {
+          const data = event.mimeData.getData(
+            CONTENTS_MIME_RICH
+          ) as DirListing.IContentsThunk;
+          return (
+            imageRendererFactory.mimeTypes.indexOf(data.model.mimetype) !== -1
+          );
+        }
+        return imageRendererFactory.mimeTypes.indexOf(mimeType) !== -1;
+      })
+    );
     if (supportedMimeTypes.length === 0) {
       return;
     }
@@ -2069,11 +1438,8 @@
    * Construct a Markdown cell widget.
    */
   constructor(options: MarkdownCell.IOptions) {
-    super({ ...options, placeholder: true });
+    super(options);
     this.addClass(MARKDOWN_CELL_CLASS);
-    this.model.contentChanged.connect(this.onContentChanged, this);
-    const trans = this.translator.load('jupyterlab');
-    this.node.setAttribute('aria-label', trans.__('Markdown Cell Content'));
     // Ensure we can resolve attachments:
     this._rendermime = options.rendermime.clone({
       resolver: new AttachmentsResolver({
@@ -2082,125 +1448,97 @@
       })
     });
 
-    this._renderer = this._rendermime.createRenderer('text/markdown');
-    this._renderer.addClass(MARKDOWN_OUTPUT_CLASS);
+    // Stop codemirror handling paste
+    this.editor.setOption('handlePaste', false);
 
     // Check if heading cell is set to be collapsed
-    this._headingCollapsed = (this.model.getMetadata(
+    this._headingCollapsed = (this.model.metadata.get(
       MARKDOWN_HEADING_COLLAPSED
     ) ?? false) as boolean;
 
-    this._showEditorForReadOnlyMarkdown =
-      options.showEditorForReadOnlyMarkdown ??
-      MarkdownCell.defaultShowEditorForReadOnlyMarkdown;
-
-    // Defer setting placeholder as the renderer must be instantiated before initializing the DOM
-    this.placeholder = options.placeholder ?? true;
-
+    // Throttle the rendering rate of the widget.
     this._monitor = new ActivityMonitor({
       signal: this.model.contentChanged,
       timeout: RENDER_TIMEOUT
     });
-
-    // Throttle the rendering rate of the widget.
-    this.ready
-      .then(() => {
-        if (this.isDisposed) {
-          // Bail early
-          return;
+    this._monitor.activityStopped.connect(() => {
+      if (this._rendered) {
+        this.update();
+      }
+    }, this);
+
+    void this._updateRenderedInput().then(() => {
+      this._ready.resolve(void 0);
+    });
+    this.renderCollapseButtons(this._renderer!);
+    this.renderInput(this._renderer!);
+    this._showEditorForReadOnlyMarkdown =
+      options.showEditorForReadOnlyMarkdown ??
+      MarkdownCell.defaultShowEditorForReadOnlyMarkdown;
+  }
+
+  /**
+   * A promise that resolves when the widget renders for the first time.
+   */
+  get ready(): Promise<void> {
+    return this._ready.promise;
+  }
+
+  /**
+   * Text that represents the heading if cell is a heading.
+   * Returns empty string if not a heading.
+   */
+  get headingInfo(): { text: string; level: number } {
+    let text = this.model.value.text;
+    const lines = marked.lexer(text);
+    let line: any;
+    for (line of lines) {
+      if (line.type === 'heading') {
+        return { text: line.text, level: line.depth };
+      } else if (line.type === 'html') {
+        let match = line.raw.match(/<h([1-6])(.*?)>(.*?)<\/h\1>/);
+        if (match?.[3]) {
+          return { text: match[3], level: parseInt(match[1]) };
         }
-        this._monitor.activityStopped.connect(() => {
-          if (this._rendered) {
-            this.update();
-          }
-        }, this);
-      })
-      .catch(reason => {
-        console.error('Failed to be ready', reason);
-      });
-  }
-
-  /**
-   * Text that represents the highest heading (i.e. lowest level) if cell is a heading.
-   * Returns empty string if not a heading.
-   */
-  get headingInfo(): { text: string; level: number } {
-    // Use table of content algorithm for consistency
-    const headings = this.headings;
-
-    if (headings.length > 0) {
-      // Return the highest level
-      const { text, level } = headings.reduce(
-        (prev, curr) => (prev.level <= curr.level ? prev : curr),
-        headings[0]
-      );
-      return { text, level };
-    } else {
-      return { text: '', level: -1 };
-    }
-  }
-
-  get headings(): Cell.IHeading[] {
-    if (!this._headingsCache) {
-      // Use table of content algorithm for consistency
-      const headings = TableOfContentsUtils.Markdown.getHeadings(
-        this.model.sharedModel.getSource()
-      );
-      this._headingsCache = headings.map(h => {
-        return { ...h, type: Cell.HeadingType.Markdown };
-      });
-    }
-
-    return [...this._headingsCache!];
-  }
-
-  /**
-   * Whether the heading is collapsed or not.
-   */
+        return { text: '', level: -1 };
+      }
+    }
+    return { text: '', level: -1 };
+  }
+
   get headingCollapsed(): boolean {
     return this._headingCollapsed;
   }
   set headingCollapsed(value: boolean) {
-    if (this._headingCollapsed !== value) {
-      this._headingCollapsed = value;
+    this._headingCollapsed = value;
+    if (value) {
+      this.model.metadata.set(MARKDOWN_HEADING_COLLAPSED, value);
+    } else if (this.model.metadata.has(MARKDOWN_HEADING_COLLAPSED)) {
+      this.model.metadata.delete(MARKDOWN_HEADING_COLLAPSED);
+    }
+    const collapseButton = this.inputArea.promptNode.getElementsByClassName(
+      HEADING_COLLAPSER_CLASS
+    )[0];
+    if (collapseButton) {
       if (value) {
-        this.model.setMetadata(MARKDOWN_HEADING_COLLAPSED, value);
-      } else if (
-        this.model.getMetadata(MARKDOWN_HEADING_COLLAPSED) !== 'undefined'
-      ) {
-        this.model.deleteMetadata(MARKDOWN_HEADING_COLLAPSED);
-      }
-      const collapseButton = this.inputArea?.promptNode.getElementsByClassName(
-        HEADING_COLLAPSER_CLASS
-      )[0];
-      if (collapseButton) {
-        if (value) {
-          collapseButton.classList.add('jp-mod-collapsed');
-        } else {
-          collapseButton.classList.remove('jp-mod-collapsed');
-        }
-      }
-      this.renderCollapseButtons(this._renderer);
-      this._headingCollapsedChanged.emit(this._headingCollapsed);
-    }
-  }
-
-  /**
-   * Number of collapsed sub cells.
-   */
+        collapseButton.classList.add('jp-mod-collapsed');
+      } else {
+        collapseButton.classList.remove('jp-mod-collapsed');
+      }
+    }
+    this.renderCollapseButtons(this._renderer!);
+  }
+
   get numberChildNodes(): number {
     return this._numberChildNodes;
   }
   set numberChildNodes(value: number) {
     this._numberChildNodes = value;
-    this.renderCollapseButtons(this._renderer);
-  }
-
-  /**
-   * Signal emitted when the cell collapsed state changes.
-   */
-  get headingCollapsedChanged(): ISignal<MarkdownCell, boolean> {
-    return this._headingCollapsedChanged;
+    this.renderCollapseButtons(this._renderer!);
+  }
+
+  get toggleCollapsedSignal(): Signal<this, boolean> {
+    return this._toggleCollapsedSignal;
   }
 
   /**
@@ -2218,22 +1556,16 @@
       return;
     }
     this._rendered = value;
-    this._handleRendered()
-      .then(() => {
-        // If the rendered state changed, raise an event.
-        this._displayChanged.emit();
-        this._renderedChanged.emit(this._rendered);
-      })
-      .catch(reason => {
-        console.error('Failed to render', reason);
-      });
-  }
-
-  /**
-   * Signal emitted when the markdown cell rendered state changes
-   */
-  get renderedChanged(): ISignal<MarkdownCell, boolean> {
-    return this._renderedChanged;
+    this._handleRendered();
+    // Refreshing an editor can be really expensive, so we don't call it from
+    // _handleRendered, since _handledRendered is also called on every update
+    // request.
+    if (!this._rendered) {
+      this.editor.refresh();
+    }
+
+    // If the rendered state changed, raise an event.
+    this._displayChanged.emit();
   }
 
   /*
@@ -2249,16 +1581,6 @@
     }
   }
 
-  /**
-   * Renderer
-   */
-  get renderer(): IRenderMime.IRenderer {
-    return this._renderer;
-  }
-
-  /**
-   * Dispose of the resources held by the widget.
-   */
   dispose(): void {
     if (this.isDisposed) {
       return;
@@ -2267,35 +1589,20 @@
     super.dispose();
   }
 
-  /**
-   * Create children widgets.
-   */
-  protected initializeDOM(): void {
-    if (!this.placeholder) {
-      return;
-    }
-
-    super.initializeDOM();
-
-    this.renderCollapseButtons(this._renderer!);
-
-    this._handleRendered().catch(reason => {
-      console.error('Failed to render', reason);
-    });
-  }
-
   protected maybeCreateCollapseButton(): void {
-    const { level } = this.headingInfo;
     if (
-      level > 0 &&
-      this.inputArea?.promptNode.getElementsByClassName(HEADING_COLLAPSER_CLASS)
+      this.headingInfo.level > 0 &&
+      this.inputArea.promptNode.getElementsByClassName(HEADING_COLLAPSER_CLASS)
         .length == 0
     ) {
       let collapseButton = this.inputArea.promptNode.appendChild(
         document.createElement('button')
       );
       collapseButton.className = `jp-Button ${HEADING_COLLAPSER_CLASS}`;
-      collapseButton.setAttribute('data-heading-level', level.toString());
+      collapseButton.setAttribute(
+        'data-heading-level',
+        this.headingInfo.level.toString()
+      );
       if (this._headingCollapsed) {
         collapseButton.classList.add('jp-mod-collapsed');
       } else {
@@ -2303,63 +1610,47 @@
       }
       collapseButton.onclick = (event: Event) => {
         this.headingCollapsed = !this.headingCollapsed;
+        this._toggleCollapsedSignal.emit(this._headingCollapsed);
       };
     }
   }
 
-  /**
-   * Create, update or remove the hidden cells button.
-   * Note that the actual visibility is controlled in Static Notebook by toggling jp-mod-showHiddenCellsButton class.
-   */
   protected maybeCreateOrUpdateExpandButton(): void {
-    const showHiddenCellsButtonList = this.node.getElementsByClassName(
+    const expandButton = this.node.getElementsByClassName(
       SHOW_HIDDEN_CELLS_CLASS
     );
-    let trans = this.translator.load('jupyterlab');
-    let buttonText = trans._n(
-      '%1 cell hidden',
-      '%1 cells hidden',
-      this._numberChildNodes
-    );
-    let needToCreateButton =
+    // Create the "show hidden" button if not already created
+    if (
       this.headingCollapsed &&
-      this._numberChildNodes > 0 &&
-      showHiddenCellsButtonList.length == 0;
-    if (needToCreateButton) {
-      const newShowHiddenCellsButton = document.createElement('button');
-      newShowHiddenCellsButton.className = `jp-mod-minimal jp-Button ${SHOW_HIDDEN_CELLS_CLASS}`;
-      addIcon.render(newShowHiddenCellsButton);
-      const buttonTextElement = document.createElement('div');
-      buttonTextElement.textContent = buttonText;
-      newShowHiddenCellsButton.appendChild(buttonTextElement);
-      newShowHiddenCellsButton.onclick = () => {
+      expandButton.length === 0 &&
+      this._numberChildNodes > 0
+    ) {
+      const numberChildNodes = document.createElement('button');
+      numberChildNodes.className = `bp3-button bp3-minimal jp-Button ${SHOW_HIDDEN_CELLS_CLASS}`;
+      addIcon.render(numberChildNodes);
+      const numberChildNodesText = document.createElement('div');
+      numberChildNodesText.nodeValue = `${this._numberChildNodes} cell${
+        this._numberChildNodes > 1 ? 's' : ''
+      } hidden`;
+      numberChildNodes.appendChild(numberChildNodesText);
+      numberChildNodes.onclick = () => {
         this.headingCollapsed = false;
+        this._toggleCollapsedSignal.emit(this._headingCollapsed);
       };
-      this.node.appendChild(newShowHiddenCellsButton);
-    }
-    let needToUpdateButtonText =
-      this.headingCollapsed &&
-      this._numberChildNodes > 0 &&
-      showHiddenCellsButtonList.length == 1;
-    if (needToUpdateButtonText) {
-      showHiddenCellsButtonList[0].childNodes[1].textContent = buttonText;
-    }
-    let needToRemoveButton = !(
-      this.headingCollapsed && this._numberChildNodes > 0
-    );
-    if (needToRemoveButton) {
-      for (const button of showHiddenCellsButtonList) {
-        this.node.removeChild(button);
-      }
-    }
-  }
-
-  /**
-   * Callback on content changed
-   */
-  protected onContentChanged(): void {
-    super.onContentChanged();
-    this._headingsCache = null;
+      this.node.appendChild(numberChildNodes);
+    } else if (expandButton?.[0]?.childNodes?.length > 1) {
+      // If the heading is collapsed, update text
+      if (this._headingCollapsed) {
+        expandButton[0].childNodes[1].textContent = `${
+          this._numberChildNodes
+        } cell${this._numberChildNodes > 1 ? 's' : ''} hidden`;
+        // If the heading isn't collapsed, remove the button
+      } else {
+        for (const el of Array.from(expandButton)) {
+          this.node.removeChild(el);
+        }
+      }
+    }
   }
 
   /**
@@ -2381,10 +1672,8 @@
    */
   protected renderInput(widget: Widget): void {
     this.addClass(RENDERED_CLASS);
-    if (!this.placeholder && !this.isDisposed) {
-      this.renderCollapseButtons(widget);
-      this.inputArea!.renderInput(widget);
-    }
+    this.renderCollapseButtons(widget);
+    this.inputArea.renderInput(widget);
   }
 
   /**
@@ -2392,22 +1681,7 @@
    */
   protected showEditor(): void {
     this.removeClass(RENDERED_CLASS);
-    if (!this.placeholder && !this.isDisposed) {
-      this.inputArea!.showEditor();
-      // if this is going to be a heading, place the cursor accordingly
-      let numHashAtStart = (this.model.sharedModel
-        .getSource()
-        .match(/^#+/g) || [''])[0].length;
-      if (numHashAtStart > 0) {
-        this.inputArea!.editor.setCursorPosition(
-          {
-            column: numHashAtStart + 1,
-            line: 0
-          },
-          { scroll: false }
-        );
-      }
-    }
+    this.inputArea.showEditor();
   }
 
   /*
@@ -2415,9 +1689,7 @@
    */
   protected onUpdateRequest(msg: Message): void {
     // Make sure we are properly rendered.
-    this._handleRendered().catch(reason => {
-      console.error('Failed to render', reason);
-    });
+    this._handleRendered();
     super.onUpdateRequest(msg);
   }
 
@@ -2427,28 +1699,24 @@
   protected updateCellSourceWithAttachment(
     attachmentName: string,
     URI?: string
-  ): void {
+  ) {
     const textToBeAppended = `![${attachmentName}](attachment:${
       URI ?? attachmentName
     })`;
-    // TODO this should be done on the model...
-    this.editor?.replaceSelection?.(textToBeAppended);
+    this.editor.replaceSelection?.(textToBeAppended);
   }
 
   /**
    * Handle the rendered state.
    */
-  private async _handleRendered(): Promise<void> {
+  private _handleRendered(): void {
     if (!this._rendered) {
       this.showEditor();
     } else {
       // TODO: It would be nice for the cell to provide a way for
       // its consumers to hook into when the rendering is done.
-      await this._updateRenderedInput();
-      if (this._rendered) {
-        // The rendered flag may be updated in the mean time
-        this.renderInput(this._renderer);
-      }
+      void this._updateRenderedInput();
+      this.renderInput(this._renderer!);
     }
   }
 
@@ -2456,20 +1724,19 @@
    * Update the rendered input.
    */
   private _updateRenderedInput(): Promise<void> {
-    if (this.placeholder) {
-      return Promise.resolve();
-    }
-
     const model = this.model;
-    const text =
-      (model && model.sharedModel.getSource()) || DEFAULT_MARKDOWN_TEXT;
+    const text = (model && model.value.text) || DEFAULT_MARKDOWN_TEXT;
     // Do not re-render if the text has not changed.
     if (text !== this._prevText) {
       const mimeModel = new MimeModel({ data: { 'text/markdown': text } });
+      if (!this._renderer) {
+        this._renderer = this._rendermime.createRenderer('text/markdown');
+        this._renderer.addClass(MARKDOWN_OUTPUT_CLASS);
+      }
       this._prevText = text;
       return this._renderer.renderModel(mimeModel);
     }
-    return Promise.resolve();
+    return Promise.resolve(void 0);
   }
 
   /**
@@ -2481,21 +1748,19 @@
       model: this.model,
       contentFactory: this.contentFactory,
       rendermime: this._rendermime,
-      placeholder: false,
-      translator: this.translator
+      placeholder: false
     });
   }
 
-  private _headingsCache: Cell.IHeading[] | null = null;
-  private _headingCollapsed: boolean;
-  private _headingCollapsedChanged = new Signal<MarkdownCell, boolean>(this);
   private _monitor: ActivityMonitor<ICellModel, void>;
   private _numberChildNodes: number;
-  private _prevText = '';
-  private _renderer: IRenderMime.IRenderer;
+  private _headingCollapsed: boolean;
+  private _toggleCollapsedSignal = new Signal<this, boolean>(this);
+  private _renderer: IRenderMime.IRenderer | null = null;
   private _rendermime: IRenderMimeRegistry;
   private _rendered = true;
-  private _renderedChanged = new Signal<this, boolean>(this);
+  private _prevText = '';
+  private _ready = new PromiseDelegate<void>();
   private _showEditorForReadOnlyMarkdown = true;
 }
 
@@ -2538,8 +1803,6 @@
   constructor(options: RawCell.IOptions) {
     super(options);
     this.addClass(RAW_CELL_CLASS);
-    const trans = this.translator.load('jupyterlab');
-    this.node.setAttribute('aria-label', trans.__('Raw Cell Content'));
   }
 
   /**
@@ -2550,8 +1813,7 @@
     return new constructor({
       model: this.model,
       contentFactory: this.contentFactory,
-      placeholder: false,
-      translator: this.translator
+      placeholder: false
     });
   }
 }