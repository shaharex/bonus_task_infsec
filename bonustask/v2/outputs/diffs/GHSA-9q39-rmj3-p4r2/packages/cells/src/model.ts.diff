--- packages\cells\src\model.ts (old)
+++ packages\cells\src\model.ts (new)
@@ -3,6 +3,8 @@
 | Distributed under the terms of the Modified BSD License.
 |----------------------------------------------------------------------------*/
 
+import { JSONExt, JSONObject, JSONValue } from '@lumino/coreutils';
+
 import { ISignal, Signal } from '@lumino/signaling';
 
 import { AttachmentsModel, IAttachmentsModel } from '@jupyterlab/attachments';
@@ -13,24 +15,20 @@
 
 import * as nbformat from '@jupyterlab/nbformat';
 
-import { ObservableValue } from '@jupyterlab/observables';
+import * as models from '@jupyterlab/shared-models';
+
+import { UUID } from '@lumino/coreutils';
+
+import {
+  IModelDB,
+  IObservableJSON,
+  IObservableMap,
+  IObservableValue,
+  ObservableValue
+} from '@jupyterlab/observables';
 
 import { IOutputAreaModel, OutputAreaModel } from '@jupyterlab/outputarea';
-
-import {
-  CellChange,
-  createMutex,
-  createStandaloneCell,
-  IMapChange,
-  ISharedAttachmentsCell,
-  ISharedCell,
-  ISharedCodeCell,
-  ISharedMarkdownCell,
-  ISharedRawCell,
-  YCodeCell
-} from '@jupyter/ydoc';
-
-const globalModelDBMutex = createMutex();
+const globalModelDBMutex = models.createMutex();
 
 /**
  * The definition of a model object for a cell.
@@ -54,10 +52,7 @@
   /**
    * A signal emitted when a model state changes.
    */
-  readonly stateChanged: ISignal<
-    ICellModel,
-    IChangedArgs<boolean, boolean, any>
-  >;
+  readonly stateChanged: ISignal<ICellModel, IChangedArgs<any>>;
 
   /**
    * Whether the cell is trusted.
@@ -66,49 +61,10 @@
 
   /**
    * The metadata associated with the cell.
-   *
-   * ### Notes
-   * This is a copy of the metadata. Changing a part of it
-   * won't affect the model.
-   * As this returns a copy of all metadata, it is advised to
-   * use `getMetadata` to speed up the process of getting a single key.
-   */
-  readonly metadata: Omit<nbformat.IBaseCellMetadata, 'trusted'>;
-
-  /**
-   * Signal emitted when cell metadata changes.
-   */
-  readonly metadataChanged: ISignal<ICellModel, IMapChange>;
-
-  /**
-   * The cell shared model.
-   */
-  readonly sharedModel: ISharedCell;
-
-  /**
-   * Delete a metadata.
-   *
-   * @param key Metadata key
-   */
-  deleteMetadata(key: string): void;
-
-  /**
-   * Get a metadata
-   *
-   * ### Notes
-   * This returns a copy of the key value.
-   *
-   * @param key Metadata key
-   */
-  getMetadata(key: string): any;
-
-  /**
-   * Set a metadata
-   *
-   * @param key Metadata key
-   * @param value Metadata value
-   */
-  setMetadata(key: string, value: any): void;
+   */
+  readonly metadata: IObservableJSON;
+
+  readonly sharedModel: models.ISharedCell & models.ISharedText;
 
   /**
    * Serialize the model to JSON.
@@ -162,11 +118,6 @@
    * Clear execution, outputs, and related metadata
    */
   clearExecution(): void;
-
-  /**
-   * The code cell shared model
-   */
-  readonly sharedModel: ISharedCodeCell;
 }
 
 /**
@@ -216,31 +167,66 @@
 /**
  * An implementation of the cell model.
  */
-export abstract class CellModel extends CodeEditor.Model implements ICellModel {
-  constructor(options: CellModel.IOptions<ISharedCell> = {}) {
-    const { cell_type, sharedModel, ...others } = options;
+export class CellModel extends CodeEditor.Model implements ICellModel {
+  /**
+   * Construct a cell model from optional cell content.
+   */
+  constructor(options: CellModel.IOptions) {
     super({
-      sharedModel:
-        sharedModel ??
-        createStandaloneCell({
-          cell_type: cell_type ?? 'raw',
-          id: options.id
-        }),
-      ...others
-    });
-    this.standaloneModel = typeof options.sharedModel === 'undefined';
-    this.trusted = !!this.getMetadata('trusted') || !!options.trusted;
-
-    this.sharedModel.changed.connect(this.onGenericChange, this);
-    this.sharedModel.metadataChanged.connect(this._onMetadataChanged, this);
-  }
-
-  readonly sharedModel: ISharedCell;
+      modelDB: options.modelDB,
+      id: options.id || (options.cell?.id as string) || UUID.uuid4()
+    });
+
+    this.value.changed.connect(this.onGenericChange, this);
+
+    const cellType = this.modelDB.createValue('type');
+    cellType.set(this.type);
+
+    const observableMetadata = this.modelDB.createMap('metadata');
+    observableMetadata.changed.connect(this.onModelDBMetadataChange, this);
+    observableMetadata.changed.connect(this.onGenericChange, this);
+
+    const cell = options.cell;
+    const trusted = this.modelDB.createValue('trusted');
+    trusted.changed.connect(this.onTrustedChanged, this);
+
+    if (!cell) {
+      trusted.set(false);
+      return;
+    }
+    trusted.set(!!cell.metadata['trusted']);
+    delete cell.metadata['trusted'];
+
+    // Set the text value, normalizing line endings to \n
+    if (Array.isArray(cell.source)) {
+      this.value.text = cell.source
+        .map(s => s.replace(/\r\n/g, '\n').replace(/\r/g, '\n'))
+        .join('');
+    } else {
+      this.value.text = cell.source.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
+    }
+    const metadata = JSONExt.deepCopy(cell.metadata);
+    if (this.type !== 'raw') {
+      delete metadata['format'];
+    }
+    if (this.type !== 'code') {
+      delete metadata['collapsed'];
+      delete metadata['scrolled'];
+    }
+
+    for (const key in metadata) {
+      observableMetadata.set(key, metadata[key]);
+    }
+  }
 
   /**
    * The type of cell.
    */
-  abstract get type(): nbformat.CellType;
+  get type(): nbformat.CellType {
+    // This getter really should be abstract, but our current constructor
+    // depends on .type working
+    return 'raw';
+  }
 
   /**
    * A signal emitted when the state of the model changes.
@@ -248,19 +234,9 @@
   readonly contentChanged = new Signal<this, void>(this);
 
   /**
-   * Signal emitted when cell metadata changes.
-   */
-  get metadataChanged(): ISignal<ICellModel, IMapChange> {
-    return this._metadataChanged;
-  }
-
-  /**
    * A signal emitted when a model state changes.
    */
-  readonly stateChanged = new Signal<
-    this,
-    IChangedArgs<any, any, 'isDirty' | 'trusted' | 'executionCount'>
-  >(this);
+  readonly stateChanged = new Signal<this, IChangedArgs<any>>(this);
 
   /**
    * The id for the cell.
@@ -272,34 +248,45 @@
   /**
    * The metadata associated with the cell.
    */
-  get metadata(): Omit<nbformat.IBaseCellMetadata, 'trusted'> {
-    return this.sharedModel.metadata;
-  }
-
-  /**
-   * The trusted state of the model.
+  get metadata(): IObservableJSON {
+    return this.modelDB.get('metadata') as IObservableJSON;
+  }
+
+  /**
+   * Get the trusted state of the model.
    */
   get trusted(): boolean {
-    return this._trusted;
-  }
+    return this.modelDB.getValue('trusted') as boolean;
+  }
+
+  /**
+   * Set the trusted state of the model.
+   */
   set trusted(newValue: boolean) {
     const oldValue = this.trusted;
-    if (oldValue !== newValue) {
-      this._trusted = newValue;
-      this.onTrustedChanged(this, { newValue, oldValue });
-    }
-  }
-
-  /**
-   * Dispose of the resources held by the model.
-   */
-  dispose(): void {
-    if (this.isDisposed) {
+    if (oldValue === newValue) {
       return;
     }
-    this.sharedModel.changed.disconnect(this.onGenericChange, this);
-    this.sharedModel.metadataChanged.disconnect(this._onMetadataChanged, this);
-    super.dispose();
+    this.modelDB.setValue('trusted', newValue);
+  }
+
+  /**
+   * Serialize the model to JSON.
+   */
+  toJSON(): nbformat.ICell {
+    const metadata: nbformat.IBaseCellMetadata = Object.create(null);
+    for (const key of this.metadata.keys()) {
+      const value = JSON.parse(JSON.stringify(this.metadata.get(key)));
+      metadata[key] = value as JSONValue;
+    }
+    if (this.trusted) {
+      metadata['trusted'] = true;
+    }
+    return {
+      cell_type: this.type,
+      source: this.value.text,
+      metadata
+    } as nbformat.ICell;
   }
 
   /**
@@ -308,52 +295,136 @@
    * The default implementation is a no-op.
    */
   onTrustedChanged(
-    trusted: CellModel,
+    trusted: IObservableValue,
     args: ObservableValue.IChangedArgs
   ): void {
     /* no-op */
   }
 
   /**
-   * Delete a metadata
+   * When we initialize a cell model, we create a standalone model that cannot be shared in a YNotebook.
+   * Call this function to re-initialize the local representation based on a fresh shared model (e.g. models.YFile or models.YCodeCell).
    *
-   * @param key Metadata key
-   */
-  deleteMetadata(key: string): any {
-    return this.sharedModel.deleteMetadata(key);
-  }
-
-  /**
-   * Get a metadata
+   * @param sharedModel
+   * @param reinitialize Whether to reinitialize the shared model.
+   */
+  switchSharedModel(
+    sharedModel: models.ISharedCodeCell,
+    reinitialize?: boolean
+  ): void {
+    if (reinitialize) {
+      const newValue = sharedModel.getMetadata();
+      if (newValue) {
+        this._updateModelDBMetadata(newValue);
+      }
+    }
+    super.switchSharedModel(sharedModel, reinitialize);
+  }
+
+  /**
+   * Handle a change to the cell metadata modelDB and reflect it in the shared model.
+   */
+  protected onModelDBMetadataChange(
+    sender: IObservableJSON,
+    event: IObservableJSON.IChangedArgs
+  ): void {
+    const metadata = this.sharedModel.getMetadata();
+    globalModelDBMutex(() => {
+      switch (event.type) {
+        case 'add':
+          this._changeCellMetadata(metadata, event);
+          break;
+        case 'change':
+          this._changeCellMetadata(metadata, event);
+          break;
+        case 'remove':
+          delete metadata[event.key];
+          break;
+        default:
+          throw new Error(`Invalid event type: ${event.type}`);
+      }
+      this.sharedModel.setMetadata(metadata);
+    });
+  }
+
+  /**
+   * Change the cell metadata for a given event.
    *
-   * ### Notes
-   * This returns a copy of the key value.
+   * @param metadata The cell metadata.
+   * @param event The event to handle.
+   */
+  private _changeCellMetadata(
+    metadata: Partial<nbformat.IBaseCellMetadata>,
+    event: IObservableJSON.IChangedArgs
+  ): void {
+    switch (event.key) {
+      case 'jupyter':
+        metadata.jupyter = event.newValue as any;
+        break;
+      case 'collapsed':
+        metadata.collapsed = event.newValue as any;
+        break;
+      case 'name':
+        metadata.name = event.newValue as any;
+        break;
+      case 'scrolled':
+        metadata.scrolled = event.newValue as any;
+        break;
+      case 'tags':
+        metadata.tags = event.newValue as any;
+        break;
+      case 'trusted':
+        metadata.trusted = event.newValue as any;
+        break;
+      default:
+        // The default is applied for custom metadata that are not
+        // defined in the official nbformat but which are defined
+        // by the user.
+        metadata[event.key] = event.newValue as any;
+    }
+  }
+
+  /**
+   * Handle a change to the cell shared model and reflect it in modelDB.
+   * We update the modeldb metadata when the shared model changes.
    *
-   * @param key Metadata key
-   */
-  getMetadata(key: string): any {
-    return this.sharedModel.getMetadata(key);
-  }
-
-  /**
-   * Set a metadata
+   * This method overrides the CodeEditor protected _onSharedModelChanged
+   * so we first call super._onSharedModelChanged
    *
-   * @param key Metadata key
-   * @param value Metadata value
-   */
-  setMetadata(key: string, value: any): void {
-    if (typeof value === 'undefined') {
-      this.sharedModel.deleteMetadata(key);
-    } else {
-      this.sharedModel.setMetadata(key, value);
-    }
-  }
-
-  /**
-   * Serialize the model to JSON.
-   */
-  toJSON(): nbformat.ICell {
-    return this.sharedModel.toJSON();
+   * @override CodeEditor._onSharedModelChanged
+   */
+  protected _onSharedModelChanged(
+    sender: models.ISharedCodeCell,
+    change: models.CellChange<nbformat.IBaseCellMetadata>
+  ): void {
+    super._onSharedModelChanged(sender, change);
+    globalModelDBMutex(() => {
+      if (change.metadataChange) {
+        const newValue = this.sharedModel.getMetadata();
+        if (newValue) {
+          this._updateModelDBMetadata(newValue);
+        }
+      }
+    });
+  }
+
+  private _updateModelDBMetadata(
+    metadata: Partial<nbformat.IBaseCellMetadata>
+  ): void {
+    this.metadata.clear();
+    Object.entries(metadata).forEach(([key, value]) => {
+      switch (key) {
+        case 'trusted':
+          this.metadata.set('trusted', value);
+          this.trusted = value as boolean;
+          break;
+        default:
+          // The default is applied for custom metadata that are not
+          // defined in the official nbformat but which are defined
+          // by the user.
+          this.metadata.set(key, value);
+      }
+    });
   }
 
   /**
@@ -362,13 +433,7 @@
   protected onGenericChange(): void {
     this.contentChanged.emit(void 0);
   }
-
-  private _onMetadataChanged(sender: ISharedCell, change: IMapChange) {
-    this._metadataChanged.emit(change);
-  }
-
-  private _metadataChanged = new Signal<this, IMapChange>(this);
-  private _trusted = false;
+  sharedModel: models.ISharedCell;
 }
 
 /**
@@ -378,48 +443,48 @@
   /**
    * The options used to initialize a `CellModel`.
    */
-  export interface IOptions<T extends ISharedCell> {
+  export interface IOptions {
     /**
-     * A unique identifier for the model.
+     * The source cell data.
+     */
+    cell?: nbformat.IBaseCell;
+
+    /**
+     * An IModelDB in which to store cell data.
+     */
+    modelDB?: IModelDB;
+
+    /**
+     * A unique identifier for this cell.
      */
     id?: string;
-
-    /**
-     * The cell shared model.
-     */
-    sharedModel?: T;
-
-    /**
-     * The cell type
-     */
-    cell_type?: string;
-
-    /**
-     * Whether the cell is trusted or not.
-     */
-    trusted?: boolean;
   }
 }
 
 /**
  * A base implementation for cell models with attachments.
  */
-export abstract class AttachmentsCellModel extends CellModel {
+export class AttachmentsCellModel extends CellModel {
   /**
    * Construct a new cell with optional attachments.
    */
-  constructor(options: AttachmentsCellModel.IOptions<ISharedCell>) {
+  constructor(options: AttachmentsCellModel.IOptions) {
     super(options);
     const factory =
-      options.contentFactory ?? AttachmentsCellModel.defaultContentFactory;
-    const values = (
-      this.sharedModel as ISharedAttachmentsCell
-    ).getAttachments();
-    this._attachments = factory.createAttachmentsModel({ values });
+      options.contentFactory || AttachmentsCellModel.defaultContentFactory;
+    let attachments: nbformat.IAttachments | undefined;
+    const cell = options.cell;
+    if (cell && (cell.cell_type === 'raw' || cell.cell_type === 'markdown')) {
+      attachments = (cell as nbformat.IRawCell | nbformat.IMarkdownCell)
+        .attachments;
+    }
+
+    this._attachments = factory.createAttachmentsModel({
+      values: attachments,
+      modelDB: this.modelDB
+    });
     this._attachments.stateChanged.connect(this.onGenericChange, this);
-    this._attachments.changed.connect(this._onAttachmentsChange, this);
-
-    this.sharedModel.changed.connect(this._onSharedModelChanged, this);
+    this._attachments.changed.connect(this.onModelDBAttachmentsChange, this);
   }
 
   /**
@@ -430,50 +495,69 @@
   }
 
   /**
-   * Dispose of the resources held by the model.
-   */
-  dispose(): void {
-    if (this.isDisposed) {
-      return;
-    }
-    this._attachments.stateChanged.disconnect(this.onGenericChange, this);
-    this._attachments.changed.disconnect(this._onAttachmentsChange, this);
-    this._attachments.dispose();
-    this.sharedModel.changed.disconnect(this._onSharedModelChanged, this);
-    super.dispose();
-  }
-
-  /**
    * Serialize the model to JSON.
    */
   toJSON(): nbformat.IRawCell | nbformat.IMarkdownCell {
-    return super.toJSON() as nbformat.IRawCell | nbformat.IMarkdownCell;
+    const cell = super.toJSON() as nbformat.IRawCell | nbformat.IMarkdownCell;
+    if (this.attachments.length) {
+      cell.attachments = this.attachments.toJSON();
+    }
+    return cell;
+  }
+
+  public switchSharedModel(
+    sharedModel: models.ISharedCodeCell,
+    reinitialize?: boolean
+  ): void {
+    if (reinitialize) {
+      const attachments = ((sharedModel as unknown) as models.YRawCell).getAttachments();
+      this._attachments.fromJSON(attachments ?? {});
+    }
+    super.switchSharedModel(sharedModel, reinitialize);
   }
 
   /**
    * Handle a change to the cell outputs modelDB and reflect it in the shared model.
    */
-  private _onAttachmentsChange(
+  protected onModelDBAttachmentsChange(
     sender: IAttachmentsModel,
     event: IAttachmentsModel.ChangedArgs
   ): void {
-    const cell = this.sharedModel as ISharedAttachmentsCell;
-    globalModelDBMutex(() => cell.setAttachments(sender.toJSON()));
-  }
-
-  /**
-   * Handle a change to the code cell value.
-   */
-  private _onSharedModelChanged(
-    slot: ISharedAttachmentsCell,
-    change: CellChange
-  ): void {
-    if (change.attachmentsChange) {
-      const cell = this.sharedModel as ISharedAttachmentsCell;
-      globalModelDBMutex(() =>
-        this._attachments.fromJSON(cell.getAttachments() ?? {})
-      );
-    }
+    const sharedModel = this.sharedModel as models.YRawCell;
+    globalModelDBMutex(() => {
+      switch (event.type) {
+        case 'add':
+        case 'change':
+        case 'remove':
+          sharedModel.setAttachments(sender.toJSON());
+          break;
+        default:
+          throw new Error(`Invalid event type: ${event.type}`);
+      }
+    });
+  }
+
+  /**
+   * Handle a change to the output shared model and reflect it in modelDB.
+   * We update the modeldb metadata when the nbcell changes.
+   *
+   * This method overrides the CellModel protected _onSharedModelChanged
+   * so we first call super._onSharedModelChanged
+   *
+   * @override CellModel._onSharedModelChanged
+   */
+  protected _onSharedModelChanged(
+    sender: models.ISharedCodeCell,
+    change: models.CellChange<nbformat.IBaseCellMetadata>
+  ): void {
+    super._onSharedModelChanged(sender, change);
+    const sharedModel = this.sharedModel as models.YRawCell;
+    globalModelDBMutex(() => {
+      if (change.attachmentsChange) {
+        const attachments = sharedModel.getAttachments();
+        this._attachments.fromJSON(attachments ?? {});
+      }
+    });
   }
 
   private _attachments: IAttachmentsModel;
@@ -486,8 +570,7 @@
   /**
    * The options used to initialize a `AttachmentsCellModel`.
    */
-  export interface IOptions<T extends ISharedCell>
-    extends CellModel.IOptions<T> {
+  export interface IOptions extends CellModel.IOptions {
     /**
      * The factory for attachment model creation.
      */
@@ -531,21 +614,6 @@
  */
 export class RawCellModel extends AttachmentsCellModel {
   /**
-   * Construct a raw cell model from optional shared model.
-   */
-  constructor(
-    options: Omit<
-      AttachmentsCellModel.IOptions<ISharedRawCell>,
-      'cell_type'
-    > = {}
-  ) {
-    super({
-      cell_type: 'raw',
-      ...options
-    });
-  }
-
-  /**
    * The type of the cell.
    */
   get type(): 'raw' {
@@ -556,7 +624,9 @@
    * Serialize the model to JSON.
    */
   toJSON(): nbformat.IRawCell {
-    return super.toJSON() as nbformat.IRawCell;
+    const cell = super.toJSON() as nbformat.IRawCell;
+    cell.id = this.id;
+    return cell;
   }
 }
 
@@ -565,18 +635,10 @@
  */
 export class MarkdownCellModel extends AttachmentsCellModel {
   /**
-   * Construct a markdown cell model from optional shared model.
-   */
-  constructor(
-    options: Omit<
-      AttachmentsCellModel.IOptions<ISharedMarkdownCell>,
-      'cell_type'
-    > = {}
-  ) {
-    super({
-      cell_type: 'markdown',
-      ...options
-    });
+   * Construct a markdown cell model from optional cell content.
+   */
+  constructor(options: CellModel.IOptions) {
+    super(options);
     // Use the Github-flavored markdown mode.
     this.mimeType = 'text/x-ipythongfm';
   }
@@ -592,7 +654,9 @@
    * Serialize the model to JSON.
    */
   toJSON(): nbformat.IMarkdownCell {
-    return super.toJSON() as nbformat.IMarkdownCell;
+    const cell = super.toJSON() as nbformat.IMarkdownCell;
+    cell.id = this.id;
+    return cell;
   }
 }
 
@@ -603,21 +667,77 @@
   /**
    * Construct a new code cell with optional original cell content.
    */
-  constructor(options: CodeCellModel.IOptions = {}) {
-    super({
-      cell_type: 'code',
-      ...options
-    });
-
+  constructor(options: CodeCellModel.IOptions) {
+    super(options);
     const factory =
-      options?.contentFactory ?? CodeCellModel.defaultContentFactory;
+      options.contentFactory || CodeCellModel.defaultContentFactory;
     const trusted = this.trusted;
-    const outputs = this.sharedModel.getOutputs();
+    const cell = options.cell as nbformat.ICodeCell;
+    let outputs: nbformat.IOutput[] = [];
+    const executionCount = this.modelDB.createValue('executionCount');
+    if (!executionCount.get()) {
+      if (cell && cell.cell_type === 'code') {
+        executionCount.set(cell.execution_count || null);
+        outputs = cell.outputs ?? [];
+        // If execution count is not null presume the input code was the latest executed
+        // TODO load from the notebook file when the dirty state is stored in it
+        if (cell.execution_count != null) {
+          // True if execution_count is null or undefined
+          this._executedCode = this.value.text.trim();
+        }
+      } else {
+        executionCount.set(null);
+      }
+    }
+    this.value.changed.connect(this._onValueChanged, this);
+
+    executionCount.changed.connect(this._onExecutionCountChanged, this);
+
+    globalModelDBMutex(() => {
+      const sharedCell = this.sharedModel as models.ISharedCodeCell;
+      sharedCell.setOutputs(outputs);
+    });
     this._outputs = factory.createOutputArea({ trusted, values: outputs });
-
-    this.sharedModel.changed.connect(this._onSharedModelChanged, this);
     this._outputs.changed.connect(this.onGenericChange, this);
-    this._outputs.changed.connect(this.onOutputsChange, this);
+    this._outputs.changed.connect(this.onModelDBOutputsChange, this);
+
+    // We keep `collapsed` and `jupyter.outputs_hidden` metadata in sync, since
+    // they are redundant in nbformat 4.4. See
+    // https://github.com/jupyter/nbformat/issues/137
+    this.metadata.changed.connect(Private.collapseChanged, this);
+
+    // Sync `collapsed` and `jupyter.outputs_hidden` for the first time, giving
+    // preference to `collapsed`.
+    if (this.metadata.has('collapsed')) {
+      const collapsed = this.metadata.get('collapsed') as boolean | undefined;
+      Private.collapseChanged(this.metadata, {
+        type: 'change',
+        key: 'collapsed',
+        oldValue: collapsed,
+        newValue: collapsed
+      });
+    } else if (this.metadata.has('jupyter')) {
+      const jupyter = this.metadata.get('jupyter') as JSONObject;
+      if (jupyter.hasOwnProperty('outputs_hidden')) {
+        Private.collapseChanged(this.metadata, {
+          type: 'change',
+          key: 'jupyter',
+          oldValue: jupyter,
+          newValue: jupyter
+        });
+      }
+    }
+  }
+
+  public switchSharedModel(
+    sharedModel: models.ISharedCodeCell,
+    reinitialize?: boolean
+  ): void {
+    if (reinitialize) {
+      this.clearExecution();
+      sharedModel.getOutputs().forEach(output => this._outputs.add(output));
+    }
+    super.switchSharedModel(sharedModel, reinitialize);
   }
 
   /**
@@ -631,10 +751,16 @@
    * The execution count of the cell.
    */
   get executionCount(): nbformat.ExecutionCount {
-    return this.sharedModel.execution_count || null;
+    return this.modelDB.has('executionCount')
+      ? (this.modelDB.getValue('executionCount') as nbformat.ExecutionCount)
+      : null;
   }
   set executionCount(newValue: nbformat.ExecutionCount) {
-    this.sharedModel.execution_count = newValue || null;
+    const oldValue = this.executionCount;
+    if (newValue === oldValue) {
+      return;
+    }
+    this.modelDB.setValue('executionCount', newValue || null);
   }
 
   /**
@@ -650,28 +776,34 @@
   }
 
   /**
-   * Public Set whether the cell is dirty or not.
-   */
-  set isDirty(dirty: boolean) {
-    this._setDirty(dirty);
-  }
-
-  /**
-   * The cell outputs.
-   */
-  get outputs(): IOutputAreaModel {
-    return this._outputs;
-  }
-
-  readonly sharedModel: ISharedCodeCell;
+   * Set whether the cell is dirty or not.
+   */
+  private _setDirty(v: boolean) {
+    if (v !== this._isDirty) {
+      if (!v) {
+        this._executedCode = this.value.text.trim();
+      }
+      this._isDirty = v;
+      this.stateChanged.emit({
+        name: 'isDirty',
+        oldValue: !v,
+        newValue: v
+      });
+    }
+  }
 
   clearExecution(): void {
     this.outputs.clear();
     this.executionCount = null;
     this._setDirty(false);
-    this.sharedModel.deleteMetadata('execution');
-    // We trust this cell as it no longer has any outputs.
-    this.trusted = true;
+    this.metadata.delete('execution');
+  }
+
+  /**
+   * The cell outputs.
+   */
+  get outputs(): IOutputAreaModel {
+    return this._outputs;
   }
 
   /**
@@ -681,19 +813,27 @@
     if (this.isDisposed) {
       return;
     }
-    this.sharedModel.changed.disconnect(this._onSharedModelChanged, this);
-    this._outputs.changed.disconnect(this.onGenericChange, this);
-    this._outputs.changed.disconnect(this.onOutputsChange, this);
     this._outputs.dispose();
     this._outputs = null!;
     super.dispose();
   }
 
   /**
+   * Serialize the model to JSON.
+   */
+  toJSON(): nbformat.ICodeCell {
+    const cell = super.toJSON() as nbformat.ICodeCell;
+    cell.execution_count = this.executionCount || null;
+    cell.outputs = this.outputs.toJSON();
+    cell.id = this.id;
+    return cell;
+  }
+
+  /**
    * Handle a change to the trusted state.
    */
   onTrustedChanged(
-    trusted: CellModel,
+    trusted: IObservableValue,
     args: ObservableValue.IChangedArgs
   ): void {
     const newTrusted = args.newValue as boolean;
@@ -701,38 +841,35 @@
       this._outputs.trusted = newTrusted;
     }
     if (newTrusted) {
-      const codeCell = this.sharedModel as YCodeCell;
+      const codeCell = this.sharedModel as models.YCodeCell;
       const metadata = codeCell.getMetadata();
       metadata.trusted = true;
       codeCell.setMetadata(metadata);
     }
     this.stateChanged.emit({
       name: 'trusted',
-      oldValue: args.oldValue as boolean,
+      oldValue: args.oldValue,
       newValue: newTrusted
     });
   }
 
   /**
-   * Serialize the model to JSON.
-   */
-  toJSON(): nbformat.ICodeCell {
-    return super.toJSON() as nbformat.ICodeCell;
-  }
-
-  /**
    * Handle a change to the cell outputs modelDB and reflect it in the shared model.
    */
-  protected onOutputsChange(
+  protected onModelDBOutputsChange(
     sender: IOutputAreaModel,
     event: IOutputAreaModel.ChangedArgs
   ): void {
-    const codeCell = this.sharedModel as YCodeCell;
+    const codeCell = this.sharedModel as models.YCodeCell;
     globalModelDBMutex(() => {
       switch (event.type) {
         case 'add': {
           const outputs = event.newValues.map(output => output.toJSON());
-          codeCell.updateOutputs(event.newIndex, event.newIndex, outputs);
+          codeCell.updateOutputs(
+            event.newIndex,
+            event.newIndex + outputs.length,
+            outputs
+          );
           break;
         }
         case 'set': {
@@ -756,56 +893,67 @@
   /**
    * Handle a change to the code cell value.
    */
-  private _onSharedModelChanged(
-    slot: ISharedCodeCell,
-    change: CellChange
-  ): void {
-    if (change.outputsChange) {
-      globalModelDBMutex(() => {
-        this.outputs.clear();
-        slot.getOutputs().forEach(output => this._outputs.add(output));
-      });
-    }
-
-    if (change.executionCountChange) {
-      if (
-        change.executionCountChange.newValue &&
-        (this.isDirty || !change.executionCountChange.oldValue)
-      ) {
-        this._setDirty(false);
-      }
-      this.stateChanged.emit({
-        name: 'executionCount',
-        oldValue: change.executionCountChange.oldValue,
-        newValue: change.executionCountChange.newValue
-      });
-    }
-
-    if (change.sourceChange && this.executionCount !== null) {
-      this._setDirty(
-        this._executedCode !== this.sharedModel.getSource().trim()
-      );
-    }
-  }
-
-  /**
-   * Set whether the cell is dirty or not.
-   */
-  private _setDirty(v: boolean) {
-    if (!v) {
-      this._executedCode = this.sharedModel.getSource().trim();
-    }
-    if (v !== this._isDirty) {
-      this._isDirty = v;
-      this.stateChanged.emit({
-        name: 'isDirty',
-        oldValue: !v,
-        newValue: v
-      });
-    }
-  }
-
-  private _executedCode = '';
+  private _onValueChanged(): void {
+    if (this.executionCount !== null) {
+      this._setDirty(this._executedCode !== this.value.text.trim());
+    }
+  }
+
+  /**
+   * Handle a change to the output shared model and reflect it in modelDB.
+   * We update the modeldb metadata when the nbcell changes.
+   *
+   * This method overrides the CellModel protected _onSharedModelChanged
+   * so we first call super._onSharedModelChanged
+   *
+   * @override CellModel._onSharedModelChanged
+   */
+  protected _onSharedModelChanged(
+    sender: models.ISharedCodeCell,
+    change: models.CellChange<nbformat.IBaseCellMetadata>
+  ): void {
+    super._onSharedModelChanged(sender, change);
+    globalModelDBMutex(() => {
+      if (change.outputsChange) {
+        this.clearExecution();
+        sender.getOutputs().forEach(output => this._outputs.add(output));
+      }
+
+      if (change.executionCountChange) {
+        this.executionCount = change.executionCountChange.newValue
+          ? change.executionCountChange.newValue
+          : null;
+      }
+    });
+  }
+
+  /**
+   * Handle a change to the execution count.
+   */
+  private _onExecutionCountChanged(
+    count: IObservableValue,
+    args: ObservableValue.IChangedArgs
+  ): void {
+    const codeCell = this.sharedModel as models.YCodeCell;
+    globalModelDBMutex(() => {
+      codeCell.transact(() => {
+        codeCell.execution_count = args.newValue
+          ? (args.newValue as number)
+          : null;
+      }, false);
+    });
+    this.contentChanged.emit(void 0);
+    this.stateChanged.emit({
+      name: 'executionCount',
+      oldValue: args.oldValue,
+      newValue: args.newValue
+    });
+    if (args.newValue && this.isDirty) {
+      this._setDirty(false);
+    }
+  }
+
+  private _executedCode: string = '';
   private _isDirty = false;
   private _outputs: IOutputAreaModel;
 }
@@ -817,8 +965,7 @@
   /**
    * The options used to initialize a `CodeCellModel`.
    */
-  export interface IOptions
-    extends Omit<CellModel.IOptions<ISharedCodeCell>, 'cell_type'> {
+  export interface IOptions extends CellModel.IOptions {
     /**
      * The factory for output area model creation.
      */
@@ -852,3 +999,33 @@
    */
   export const defaultContentFactory = new ContentFactory();
 }
+
+namespace Private {
+  export function collapseChanged(
+    metadata: IObservableJSON,
+    args: IObservableMap.IChangedArgs<JSONValue>
+  ): void {
+    if (args.key === 'collapsed') {
+      const jupyter = (metadata.get('jupyter') || {}) as JSONObject;
+      const { outputs_hidden, ...newJupyter } = jupyter;
+
+      if (outputs_hidden !== args.newValue) {
+        if (args.newValue !== undefined) {
+          newJupyter['outputs_hidden'] = args.newValue;
+        }
+        if (Object.keys(newJupyter).length === 0) {
+          metadata.delete('jupyter');
+        } else {
+          metadata.set('jupyter', newJupyter);
+        }
+      }
+    } else if (args.key === 'jupyter') {
+      const jupyter = (args.newValue || {}) as JSONObject;
+      if (jupyter.hasOwnProperty('outputs_hidden')) {
+        metadata.set('collapsed', jupyter.outputs_hidden);
+      } else {
+        metadata.delete('collapsed');
+      }
+    }
+  }
+}