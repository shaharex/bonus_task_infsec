--- packages\cells\test\widget.spec.ts (old)
+++ packages\cells\test\widget.spec.ts (new)
@@ -1,9 +1,14 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
-import { createStandaloneCell, YCodeCell, YMarkdownCell } from '@jupyter/ydoc';
+import { Message, MessageLoop } from '@lumino/messaging';
+
+import { Widget } from '@lumino/widgets';
+
 import { ISessionContext, SessionContext } from '@jupyterlab/apputils';
-import { createSessionContext } from '@jupyterlab/apputils/lib/testutils';
+
+import { CodeEditor, CodeEditorWrapper } from '@jupyterlab/codeeditor';
+
 import {
   Cell,
   CellFooter,
@@ -18,38 +23,26 @@
   RawCell,
   RawCellModel
 } from '@jupyterlab/cells';
-import { NBTestUtils } from '@jupyterlab/cells/lib/testutils';
-import { CodeEditorWrapper } from '@jupyterlab/codeeditor';
+
 import { OutputArea, OutputPrompt } from '@jupyterlab/outputarea';
-import { defaultRenderMime } from '@jupyterlab/rendermime/lib/testutils';
-import { IExecuteReplyMsg } from '@jupyterlab/services/lib/kernel/messages';
+
 import {
+  createSessionContext,
   framePromise,
   JupyterServer,
-  signalToPromise
-} from '@jupyterlab/testing';
-import { Message, MessageLoop } from '@lumino/messaging';
-import { Widget } from '@lumino/widgets';
+  NBTestUtils
+} from '@jupyterlab/testutils';
 
 const RENDERED_CLASS = 'jp-mod-rendered';
-const rendermime = defaultRenderMime();
-
-class TestModel extends CellModel {
-  get type(): 'raw' {
-    return 'raw';
-  }
-}
+const rendermime = NBTestUtils.defaultRenderMime();
 
 class LogBaseCell extends Cell {
   methods: string[] = [];
 
   constructor() {
     super({
-      contentFactory: NBTestUtils.createBaseCellFactory(),
-      model: new TestModel({
-        sharedModel: createStandaloneCell({ cell_type: 'code' }) as YCodeCell
-      }),
-      placeholder: false
+      model: new CellModel({}),
+      contentFactory: NBTestUtils.createBaseCellFactory()
     });
   }
 
@@ -74,15 +67,14 @@
 
   constructor() {
     super({
+      model: new CodeCellModel({}),
       contentFactory: NBTestUtils.createCodeCellFactory(),
-      model: new CodeCellModel(),
-      rendermime,
-      placeholder: false
+      rendermime
     });
   }
 
   protected onUpdateRequest(msg: Message): void {
-    super.onUpdateRequest(msg);
+    super.onAfterAttach(msg);
     this.methods.push('onUpdateRequest');
   }
 
@@ -96,25 +88,31 @@
   methods: string[] = [];
 
   protected onUpdateRequest(msg: Message): void {
-    super.onUpdateRequest(msg);
+    super.onAfterAttach(msg);
     this.methods.push('onUpdateRequest');
   }
 }
 
+const server = new JupyterServer();
+
+beforeAll(async () => {
+  await server.start();
+});
+
+afterAll(async () => {
+  await server.shutdown();
+});
+
 describe('cells/widget', () => {
   const editorFactory = NBTestUtils.editorFactory;
 
   describe('Cell', () => {
-    const model = new TestModel({
-      sharedModel: createStandaloneCell({ cell_type: 'code' }) as YCodeCell
-    });
+    const contentFactory = NBTestUtils.createBaseCellFactory();
+    const model = new CellModel({});
 
     describe('#constructor()', () => {
       it('should create a base cell widget', () => {
-        const widget = new Cell({
-          contentFactory: NBTestUtils.createBaseCellFactory(),
-          model
-        }).initializeState();
+        const widget = new Cell({ model, contentFactory }).initializeState();
         expect(widget).toBeInstanceOf(Cell);
       });
 
@@ -125,89 +123,67 @@
       });
 
       it('should accept a custom editorConfig', () => {
-        const editorConfig: Record<string, any> = {
+        const editorConfig: Partial<CodeEditor.IConfig> = {
+          insertSpaces: false,
           matchBrackets: false
         };
         const widget = new Cell({
-          contentFactory: NBTestUtils.createBaseCellFactory(),
           editorConfig,
           model,
-          placeholder: false
+          contentFactory
         }).initializeState();
-        expect(widget.editor!.getOption('matchBrackets')).toEqual(false);
+        expect(widget.editor.getOption('insertSpaces')).toEqual(false);
+        expect(widget.editor.getOption('matchBrackets')).toEqual(false);
+        expect(widget.editor.getOption('lineNumbers')).toEqual(
+          CodeEditor.defaultConfig.lineNumbers
+        );
       });
     });
 
     describe('#model', () => {
       it('should be the model used by the widget', () => {
-        const model = new TestModel({
-          sharedModel: createStandaloneCell({ cell_type: 'code' }) as YCodeCell
-        });
-        const widget = new Cell({
-          contentFactory: NBTestUtils.createBaseCellFactory(),
-          model,
-          placeholder: false
-        }).initializeState();
+        const model = new CellModel({});
+        const widget = new Cell({ model, contentFactory }).initializeState();
         expect(widget.model).toEqual(model);
       });
     });
 
     describe('#editorWidget', () => {
       it('should be a code editor widget', () => {
-        const widget = new Cell({
-          contentFactory: NBTestUtils.createBaseCellFactory(),
-          model,
-          placeholder: false
-        }).initializeState();
+        const widget = new Cell({ model, contentFactory }).initializeState();
         expect(widget.editorWidget).toBeInstanceOf(CodeEditorWrapper);
       });
     });
 
     describe('#editor', () => {
       it('should be a cell editor', () => {
-        const widget = new Cell({
-          contentFactory: NBTestUtils.createBaseCellFactory(),
-          model,
-          placeholder: false
-        }).initializeState();
-        expect(widget.editor!.uuid).toBeTruthy();
+        const widget = new Cell({ model, contentFactory }).initializeState();
+        expect(widget.editor.uuid).toBeTruthy();
       });
     });
 
     describe('#inputArea', () => {
       it('should be the input area for the cell', () => {
-        const widget = new Cell({
-          contentFactory: NBTestUtils.createBaseCellFactory(),
-          model,
-          placeholder: false
-        }).initializeState();
+        const widget = new Cell({ model }).initializeState();
         expect(widget.inputArea).toBeInstanceOf(InputArea);
       });
     });
 
     describe('#readOnly', () => {
       it('should be a boolean', () => {
-        const widget = new Cell({
-          contentFactory: NBTestUtils.createBaseCellFactory(),
-          model,
-          placeholder: false
-        }).initializeState();
+        const widget = new Cell({ model, contentFactory }).initializeState();
         expect(typeof widget.readOnly).toEqual('boolean');
       });
 
       it('should default to false', () => {
-        const widget = new Cell({
-          contentFactory: NBTestUtils.createBaseCellFactory(),
-          model,
-          placeholder: false
-        }).initializeState();
+        const widget = new Cell({ model, contentFactory }).initializeState();
         expect(widget.readOnly).toEqual(false);
       });
 
       it('should be settable', () => {
         const widget = new Cell({
-          contentFactory: NBTestUtils.createBaseCellFactory(),
-          model
+          model,
+          contentFactory
         }).initializeState();
         widget.readOnly = true;
         expect(widget.readOnly).toEqual(true);
@@ -222,12 +198,11 @@
       });
 
       it('should reflect model metadata', () => {
-        model.setMetadata('editable', false);
+        model.metadata.set('editable', false);
 
         const widget = new Cell({
-          contentFactory: NBTestUtils.createBaseCellFactory(),
           model,
-          placeholder: false
+          contentFactory
         }).initializeState();
         expect(widget.readOnly).toEqual(true);
       });
@@ -244,20 +219,15 @@
 
     describe('#loadEditableState()', () => {
       it('should load the editable state from the model', () => {
-        const model = new TestModel({
-          sharedModel: createStandaloneCell({ cell_type: 'code' }) as YCodeCell
-        });
-        const widget = new Cell({
-          contentFactory: NBTestUtils.createBaseCellFactory(),
-          model
-        }).initializeState();
+        const model = new CellModel({});
+        const widget = new Cell({ model, contentFactory }).initializeState();
         expect(widget.readOnly).toEqual(false);
 
-        model.setMetadata('editable', false);
+        model.metadata.set('editable', false);
         widget.loadEditableState();
         expect(widget.readOnly).toEqual(true);
 
-        model.setMetadata('editable', true);
+        model.metadata.set('editable', true);
         widget.loadEditableState();
         expect(widget.readOnly).toEqual(false);
       });
@@ -265,82 +235,64 @@
 
     describe('#saveEditableState()', () => {
       it('should save the editable state to the model', () => {
-        const model = new TestModel({
-          sharedModel: createStandaloneCell({ cell_type: 'code' }) as YCodeCell
-        });
-        const widget = new Cell({
-          contentFactory: NBTestUtils.createBaseCellFactory(),
-          model,
-          placeholder: false
-        }).initializeState();
+        const model = new CellModel({});
+        const widget = new Cell({ model, contentFactory }).initializeState();
         expect(widget.readOnly).toEqual(false);
 
         widget.readOnly = true;
         widget.saveEditableState();
-        expect(model.getMetadata('editable')).toEqual(false);
+        expect(model.metadata.get('editable')).toEqual(false);
 
         widget.readOnly = false;
         widget.saveEditableState();
         // Default values are not saved explicitly
-        expect(model.getMetadata('editable')).toEqual(undefined);
+        expect(model.metadata.get('editable')).toEqual(undefined);
       });
     });
 
     describe('#syncEditable', () => {
       it('should control automatic syncing of editable state with model', () => {
-        const model = new TestModel({
-          sharedModel: createStandaloneCell({ cell_type: 'code' }) as YCodeCell
-        });
-        const widget = new Cell({
-          contentFactory: NBTestUtils.createBaseCellFactory(),
-          model,
-          placeholder: false
-        }).initializeState();
+        const model = new CellModel({});
+        const widget = new Cell({ model, contentFactory }).initializeState();
         expect(widget.syncEditable).toEqual(false);
         expect(widget.readOnly).toEqual(false);
 
         // Not synced if setting widget attribute
         widget.readOnly = true;
-        expect(model.getMetadata('editable')).toEqual(undefined);
+        expect(model.metadata.get('editable')).toEqual(undefined);
 
         // Not synced if setting metadata attribute
-        model.setMetadata('editable', true);
+        model.metadata.set('editable', true);
         expect(widget.readOnly).toEqual(true);
 
         widget.syncEditable = true;
 
         // Setting sync does an initial sync from model to view. This also sets
         // the metadata to undefined if it is the default value.
-        expect(model.getMetadata('editable')).toEqual(undefined);
+        expect(model.metadata.get('editable')).toEqual(undefined);
         expect(widget.readOnly).toEqual(false);
 
         // Synced if setting widget attribute
         widget.readOnly = true;
-        expect(model.getMetadata('editable')).toEqual(false);
+        expect(model.metadata.get('editable')).toEqual(false);
 
         // Synced if setting metadata attribute
-        model.setMetadata('editable', true);
+        model.metadata.set('editable', true);
         expect(widget.readOnly).toEqual(false);
       });
     });
 
     describe('#loadCollapseState()', () => {
       it('should load the input collapse state from the model', () => {
-        const model = new TestModel({
-          sharedModel: createStandaloneCell({ cell_type: 'code' }) as YCodeCell
-        });
-        const widget = new Cell({
-          contentFactory: NBTestUtils.createBaseCellFactory(),
-          model,
-          placeholder: false
-        }).initializeState();
+        const model = new CellModel({});
+        const widget = new Cell({ model, contentFactory }).initializeState();
         expect(widget.inputHidden).toEqual(false);
 
-        model.setMetadata('jupyter', { source_hidden: true });
+        model.metadata.set('jupyter', { source_hidden: true });
         widget.loadCollapseState();
         expect(widget.inputHidden).toEqual(true);
 
-        model.setMetadata('jupyter', { source_hidden: false });
+        model.metadata.set('jupyter', { source_hidden: false });
         widget.loadCollapseState();
         expect(widget.inputHidden).toEqual(false);
       });
@@ -348,65 +300,53 @@
 
     describe('#saveCollapseState()', () => {
       it('should save the collapse state to the model', () => {
-        const model = new TestModel({
-          sharedModel: createStandaloneCell({ cell_type: 'code' }) as YCodeCell
-        });
-        const widget = new Cell({
-          contentFactory: NBTestUtils.createBaseCellFactory(),
-          model,
-          placeholder: false
-        }).initializeState();
+        const model = new CellModel({});
+        const widget = new Cell({ model, contentFactory }).initializeState();
         expect(widget.inputHidden).toEqual(false);
 
         widget.inputHidden = true;
         widget.saveCollapseState();
-        expect(model.getMetadata('jupyter')).toEqual({
+        expect(model.metadata.get('jupyter')).toEqual({
           source_hidden: true
         });
 
         widget.inputHidden = false;
         widget.saveCollapseState();
         // Default values are not saved explicitly
-        expect(model.getMetadata('jupyter')).toEqual(undefined);
+        expect(model.metadata.get('jupyter')).toEqual(undefined);
       });
     });
 
     describe('#syncCollapse', () => {
       it('should control automatic syncing of collapse state with model', () => {
-        const model = new TestModel({
-          sharedModel: createStandaloneCell({ cell_type: 'code' }) as YCodeCell
-        });
-        const widget = new Cell({
-          contentFactory: NBTestUtils.createBaseCellFactory(),
-          model,
-          placeholder: false
-        }).initializeState();
+        const model = new CellModel({});
+        const widget = new Cell({ model, contentFactory }).initializeState();
         expect(widget.syncCollapse).toEqual(false);
         expect(widget.inputHidden).toEqual(false);
 
         // Not synced if setting widget attribute
         widget.inputHidden = true;
-        expect(model.getMetadata('jupyter')).toEqual(undefined);
+        expect(model.metadata.get('jupyter')).toEqual(undefined);
 
         // Not synced if setting metadata attribute
-        model.setMetadata('jupyter', { source_hidden: false });
+        model.metadata.set('jupyter', { source_hidden: false });
         expect(widget.inputHidden).toEqual(true);
 
         widget.syncCollapse = true;
 
         // Setting sync does an initial sync from model to view. This also sets
         // the metadata to undefined if it is the default value.
-        expect(model.getMetadata('jupyter')).toEqual(undefined);
+        expect(model.metadata.get('jupyter')).toEqual(undefined);
         expect(widget.inputHidden).toEqual(false);
 
         // Synced if setting widget attribute
         widget.inputHidden = true;
-        expect(model.getMetadata('jupyter')).toEqual({
+        expect(model.metadata.get('jupyter')).toEqual({
           source_hidden: true
         });
 
         // Synced if setting metadata attribute
-        model.setMetadata('jupyter', {});
+        model.metadata.set('jupyter', {});
         expect(widget.inputHidden).toEqual(false);
       });
     });
@@ -419,17 +359,14 @@
         await framePromise();
         expect(widget.methods).toContain('onActivateRequest');
         await framePromise();
-        expect(widget.editor!.hasFocus()).toEqual(true);
+        expect(widget.editor.hasFocus()).toEqual(true);
         widget.dispose();
       });
     });
 
     describe('#setPrompt()', () => {
       it('should not throw an error (full test in input area)', () => {
-        const widget = new Cell({
-          contentFactory: NBTestUtils.createBaseCellFactory(),
-          model
-        }).initializeState();
+        const widget = new Cell({ model, contentFactory }).initializeState();
         expect(() => {
           widget.setPrompt('');
         }).not.toThrow();
@@ -444,19 +381,13 @@
 
     describe('#dispose()', () => {
       it('should dispose of the resources held by the widget', () => {
-        const widget = new Cell({
-          contentFactory: NBTestUtils.createBaseCellFactory(),
-          model
-        }).initializeState();
+        const widget = new Cell({ model, contentFactory }).initializeState();
         widget.dispose();
         expect(widget.isDisposed).toEqual(true);
       });
 
       it('should be safe to call multiple times', () => {
-        const widget = new Cell({
-          contentFactory: NBTestUtils.createBaseCellFactory(),
-          model
-        }).initializeState();
+        const widget = new Cell({ model, contentFactory }).initializeState();
         widget.dispose();
         widget.dispose();
         expect(widget.isDisposed).toEqual(true);
@@ -482,6 +413,12 @@
       });
     });
 
+    describe('#.defaultContentFactory', () => {
+      it('should be a contentFactory', () => {
+        expect(Cell.defaultContentFactory).toBeInstanceOf(Cell.ContentFactory);
+      });
+    });
+
     describe('.ContentFactory', () => {
       describe('#constructor', () => {
         it('should create a ContentFactory', () => {
@@ -499,28 +436,28 @@
 
       describe('#createCellHeader()', () => {
         it('should create a new cell header', () => {
-          const factory = new Cell.ContentFactory({ editorFactory });
+          const factory = new Cell.ContentFactory();
           expect(factory.createCellHeader()).toBeInstanceOf(CellHeader);
         });
       });
 
       describe('#createCellFooter()', () => {
         it('should create a new cell footer', () => {
-          const factory = new Cell.ContentFactory({ editorFactory });
+          const factory = new Cell.ContentFactory();
           expect(factory.createCellFooter()).toBeInstanceOf(CellFooter);
         });
       });
 
       describe('#createOutputPrompt()', () => {
         it('should create a new output prompt', () => {
-          const factory = new Cell.ContentFactory({ editorFactory });
+          const factory = new Cell.ContentFactory();
           expect(factory.createOutputPrompt()).toBeInstanceOf(OutputPrompt);
         });
       });
 
       describe('#createInputPrompt()', () => {
         it('should create a new input prompt', () => {
-          const factory = new Cell.ContentFactory({ editorFactory });
+          const factory = new Cell.ContentFactory();
           expect(factory.createInputPrompt()).toBeInstanceOf(InputPrompt);
         });
       });
@@ -529,7 +466,7 @@
 
   describe('CodeCell', () => {
     const contentFactory = NBTestUtils.createCodeCellFactory();
-    const model = new CodeCellModel();
+    const model = new CodeCellModel({});
 
     describe('#constructor()', () => {
       it('should create a code cell widget', () => {
@@ -548,11 +485,7 @@
 
     describe('#outputArea', () => {
       it('should be the output area used by the cell', () => {
-        const widget = new CodeCell({
-          contentFactory: NBTestUtils.createCodeCellFactory(),
-          model,
-          rendermime
-        });
+        const widget = new CodeCell({ model, rendermime });
         widget.initializeState();
         expect(widget.outputArea).toBeInstanceOf(OutputArea);
       });
@@ -560,41 +493,25 @@
 
     describe('#outputCollapsed', () => {
       it('should initialize from the model', () => {
-        const collapsedModel = new CodeCellModel();
-        let widget = new CodeCell({
-          contentFactory: NBTestUtils.createCodeCellFactory(),
-          model: collapsedModel,
-          rendermime
-        });
+        const collapsedModel = new CodeCellModel({});
+        let widget = new CodeCell({ model: collapsedModel, rendermime });
         widget.initializeState();
         expect(widget.outputHidden).toEqual(false);
 
-        collapsedModel.setMetadata('collapsed', true);
-        widget = new CodeCell({
-          contentFactory: NBTestUtils.createCodeCellFactory(),
-          model: collapsedModel,
-          rendermime
-        });
+        collapsedModel.metadata.set('collapsed', true);
+        widget = new CodeCell({ model: collapsedModel, rendermime });
         widget.initializeState();
         expect(widget.outputHidden).toEqual(true);
 
-        collapsedModel.deleteMetadata('collapsed');
-        collapsedModel.setMetadata('jupyter', { outputs_hidden: true });
-        widget = new CodeCell({
-          contentFactory: NBTestUtils.createCodeCellFactory(),
-          model: collapsedModel,
-          rendermime
-        });
+        collapsedModel.metadata.delete('collapsed');
+        collapsedModel.metadata.set('jupyter', { outputs_hidden: true });
+        widget = new CodeCell({ model: collapsedModel, rendermime });
         widget.initializeState();
         expect(widget.outputHidden).toEqual(true);
       });
 
       it('should be the view state of the output being collapsed', () => {
-        const widget = new CodeCell({
-          contentFactory: NBTestUtils.createCodeCellFactory(),
-          model,
-          rendermime
-        });
+        const widget = new CodeCell({ model, rendermime });
         widget.initializeState();
         expect(widget.outputHidden).toEqual(false);
         widget.outputHidden = true;
@@ -604,39 +521,23 @@
 
     describe('#outputsScrolled', () => {
       it('should initialize from the model', () => {
-        const model = new CodeCellModel();
-        let widget = new CodeCell({
-          contentFactory: NBTestUtils.createCodeCellFactory(),
-          model,
-          rendermime
-        });
+        const model = new CodeCellModel({});
+        let widget = new CodeCell({ model, rendermime });
         widget.initializeState();
         expect(widget.outputsScrolled).toEqual(false);
 
-        model.setMetadata('scrolled', false);
-        widget = new CodeCell({
-          contentFactory: NBTestUtils.createCodeCellFactory(),
-          model,
-          rendermime
-        });
+        model.metadata.set('scrolled', false);
+        widget = new CodeCell({ model, rendermime });
         widget.initializeState();
         expect(widget.outputsScrolled).toEqual(false);
 
-        model.setMetadata('scrolled', 'auto');
-        widget = new CodeCell({
-          contentFactory: NBTestUtils.createCodeCellFactory(),
-          model,
-          rendermime
-        });
+        model.metadata.set('scrolled', 'auto');
+        widget = new CodeCell({ model, rendermime });
         widget.initializeState();
         expect(widget.outputsScrolled).toEqual(false);
 
-        model.setMetadata('scrolled', true);
-        widget = new CodeCell({
-          contentFactory: NBTestUtils.createCodeCellFactory(),
-          model,
-          rendermime
-        });
+        model.metadata.set('scrolled', true);
+        widget = new CodeCell({ model, rendermime });
         widget.initializeState();
         expect(widget.outputsScrolled).toEqual(true);
       });
@@ -644,20 +545,16 @@
 
     describe('#loadScrolledState()', () => {
       it('should load the output scrolled state from the model', () => {
-        const model = new CodeCellModel();
-        const widget = new CodeCell({
-          contentFactory: NBTestUtils.createCodeCellFactory(),
-          model,
-          rendermime
-        });
+        const model = new CodeCellModel({});
+        const widget = new CodeCell({ model, rendermime });
         widget.initializeState();
         expect(widget.outputsScrolled).toEqual(false);
 
-        model.setMetadata('scrolled', true);
+        model.metadata.set('scrolled', true);
         widget.loadScrolledState();
         expect(widget.outputsScrolled).toEqual(true);
 
-        model.setMetadata('scrolled', false);
+        model.metadata.set('scrolled', false);
         widget.loadScrolledState();
         expect(widget.outputsScrolled).toEqual(false);
       });
@@ -665,80 +562,68 @@
 
     describe('#saveScrolledState()', () => {
       it('should save the collapse state to the model', () => {
-        const model = new CodeCellModel();
-        const widget = new CodeCell({
-          contentFactory: NBTestUtils.createCodeCellFactory(),
-          model,
-          rendermime
-        });
+        const model = new CodeCellModel({});
+        const widget = new CodeCell({ model, rendermime });
         widget.initializeState();
         expect(widget.outputsScrolled).toEqual(false);
 
         widget.outputsScrolled = true;
         widget.saveScrolledState();
-        expect(model.getMetadata('scrolled')).toEqual(true);
+        expect(model.metadata.get('scrolled')).toEqual(true);
 
         widget.outputsScrolled = false;
         widget.saveScrolledState();
         // Default values are not saved explicitly
-        expect(model.getMetadata('scrolled')).toEqual(undefined);
+        expect(model.metadata.get('scrolled')).toEqual(undefined);
       });
     });
 
     describe('#syncScrolled', () => {
       it('should control automatic syncing of scrolled state with model', () => {
-        const model = new CodeCellModel();
-        const widget = new CodeCell({
-          contentFactory: NBTestUtils.createCodeCellFactory(),
-          model,
-          rendermime
-        });
+        const model = new CodeCellModel({});
+        const widget = new CodeCell({ model, rendermime });
         widget.initializeState();
         expect(widget.syncScrolled).toEqual(false);
         expect(widget.outputsScrolled).toEqual(false);
 
         // Not synced if setting widget attribute
         widget.outputsScrolled = true;
-        expect(model.getMetadata('scrolled')).toEqual(undefined);
+        expect(model.metadata.get('scrolled')).toEqual(undefined);
 
         // Not synced if setting metadata attribute
-        model.setMetadata('scrolled', false);
+        model.metadata.set('scrolled', false);
         expect(widget.outputsScrolled).toEqual(true);
 
         widget.syncScrolled = true;
 
         // Setting sync does an initial sync from model to view. This also sets
         // the metadata to undefined if it is the default value.
-        expect(model.getMetadata('scrolled')).toEqual(undefined);
+        expect(model.metadata.get('scrolled')).toEqual(undefined);
         expect(widget.outputsScrolled).toEqual(false);
 
         // Synced if setting widget attribute
         widget.outputsScrolled = true;
-        expect(model.getMetadata('scrolled')).toEqual(true);
+        expect(model.metadata.get('scrolled')).toEqual(true);
 
         // Synced if setting metadata attribute
-        model.setMetadata('scrolled', false);
+        model.metadata.set('scrolled', false);
         expect(widget.outputsScrolled).toEqual(false);
       });
     });
 
     describe('#loadCollapseState()', () => {
       it('should load the output collapse state from the model', () => {
-        const model = new CodeCellModel();
-        const widget = new CodeCell({
-          contentFactory: NBTestUtils.createCodeCellFactory(),
-          model,
-          rendermime
-        });
+        const model = new CodeCellModel({});
+        const widget = new CodeCell({ model, rendermime });
         widget.initializeState();
         widget.loadCollapseState();
         expect(widget.outputHidden).toEqual(false);
 
-        model.setMetadata('collapsed', true);
+        model.metadata.set('collapsed', true);
         widget.loadCollapseState();
         expect(widget.outputHidden).toEqual(true);
 
-        model.setMetadata('collapsed', false);
+        model.metadata.set('collapsed', false);
         widget.loadCollapseState();
         expect(widget.outputHidden).toEqual(false);
       });
@@ -746,70 +631,62 @@
 
     describe('#saveCollapseState()', () => {
       it('should save the collapse state to the model `collapsed` metadata', () => {
-        const model = new CodeCellModel();
-        const widget = new CodeCell({
-          contentFactory: NBTestUtils.createCodeCellFactory(),
-          model,
-          rendermime
-        });
+        const model = new CodeCellModel({});
+        const widget = new CodeCell({ model, rendermime });
         widget.initializeState();
         expect(widget.outputHidden).toEqual(false);
 
         widget.outputHidden = true;
         widget.saveCollapseState();
-        expect(model.getMetadata('collapsed')).toEqual(true);
+        expect(model.metadata.get('collapsed')).toEqual(true);
 
         // Default values are not saved explicitly
         widget.outputHidden = false;
         widget.saveCollapseState();
-        expect(model.getMetadata('collapsed')).toEqual(undefined);
+        expect(model.metadata.get('collapsed')).toEqual(undefined);
 
         // Default values are explicitly deleted
-        model.setMetadata('collapsed', false);
+        model.metadata.set('collapsed', false);
         widget.outputHidden = false;
         widget.saveCollapseState();
-        expect(model.getMetadata('collapsed')).toEqual(undefined);
+        expect(model.metadata.get('collapsed')).toEqual(undefined);
       });
     });
 
     describe('#syncCollapse', () => {
       it('should control automatic syncing of collapse state with model', () => {
-        const model = new CodeCellModel();
-        const widget = new CodeCell({
-          contentFactory: NBTestUtils.createCodeCellFactory(),
-          model,
-          rendermime
-        });
+        const model = new CodeCellModel({});
+        const widget = new CodeCell({ model, rendermime });
         widget.initializeState();
         expect(widget.syncCollapse).toEqual(false);
         expect(widget.outputHidden).toEqual(false);
 
         // Not synced if setting widget attribute
         widget.outputHidden = true;
-        expect(model.getMetadata('collapsed')).toEqual(undefined);
+        expect(model.metadata.get('collapsed')).toEqual(undefined);
 
         // Not synced if setting metadata attribute
-        model.setMetadata('collapsed', false);
+        model.metadata.set('collapsed', false);
         expect(widget.outputHidden).toEqual(true);
 
         widget.syncCollapse = true;
 
         // Setting sync does an initial sync from model to view.
-        expect(model.getMetadata('collapsed')).toEqual(undefined);
+        expect(model.metadata.get('collapsed')).toEqual(undefined);
         expect(widget.outputHidden).toEqual(false);
 
         // Synced if setting widget attribute
         widget.outputHidden = true;
-        expect(model.getMetadata('collapsed')).toEqual(true);
+        expect(model.metadata.get('collapsed')).toEqual(true);
 
         // Synced if setting metadata attribute
-        model.setMetadata('collapsed', false);
+        model.metadata.set('collapsed', false);
         expect(widget.outputHidden).toEqual(false);
 
         // Synced if deleting collapsed metadata attribute
         widget.outputHidden = true;
-        expect(model.getMetadata('collapsed')).toEqual(true);
-        model.deleteMetadata('collapsed');
+        expect(model.metadata.get('collapsed')).toEqual(true);
+        model.metadata.delete('collapsed');
         expect(widget.outputHidden).toEqual(false);
       });
     });
@@ -845,23 +722,13 @@
         const method = 'onMetadataChanged';
         const widget = new LogCodeCell().initializeState();
         expect(widget.methods).not.toContain(method);
-        widget.model.setMetadata('foo', 1);
+        widget.model.metadata.set('foo', 1);
         expect(widget.methods).toContain(method);
       });
     });
 
     describe('.execute()', () => {
       let sessionContext: ISessionContext;
-
-      const server = new JupyterServer();
-
-      beforeAll(async () => {
-        await server.start();
-      }, 30000);
-
-      afterAll(async () => {
-        await server.shutdown();
-      });
 
       beforeEach(async () => {
         sessionContext = await createSessionContext();
@@ -874,28 +741,16 @@
       });
 
       it('should fulfill a promise if there is no code to execute', async () => {
-        const widget = new CodeCell({
-          model,
-          rendermime,
-          contentFactory,
-          placeholder: false
-        });
-        widget.initializeState();
-        await expect(
-          CodeCell.execute(widget, sessionContext)
-        ).resolves.not.toThrow();
+        const widget = new CodeCell({ model, rendermime, contentFactory });
+        widget.initializeState();
+        await CodeCell.execute(widget, sessionContext);
       });
 
       it('should fulfill a promise if there is code to execute', async () => {
-        const widget = new CodeCell({
-          model,
-          rendermime,
-          contentFactory,
-          placeholder: false
-        });
+        const widget = new CodeCell({ model, rendermime, contentFactory });
         widget.initializeState();
         let originalCount: number;
-        widget.model.sharedModel.setSource('foo');
+        widget.model.value.text = 'foo';
         originalCount = widget.model.executionCount!;
         await CodeCell.execute(widget, sessionContext);
         const executionCount = widget.model.executionCount;
@@ -911,128 +766,70 @@
       ];
 
       it('should not save timing info by default', async () => {
-        const widget = new CodeCell({
-          model,
-          rendermime,
-          contentFactory,
-          placeholder: false
-        });
+        const widget = new CodeCell({ model, rendermime, contentFactory });
         await CodeCell.execute(widget, sessionContext);
-        expect(widget.model.getMetadata('execution')).toBeUndefined();
+        expect(widget.model.metadata.get('execution')).toBeUndefined();
       });
       it('should save timing info if requested', async () => {
-        const widget = new CodeCell({
-          model,
-          rendermime,
-          contentFactory,
-          placeholder: false
-        });
+        const widget = new CodeCell({ model, rendermime, contentFactory });
         await CodeCell.execute(widget, sessionContext, { recordTiming: true });
-        expect(widget.model.getMetadata('execution')).toBeDefined();
-        const timingInfo = widget.model.getMetadata('execution') as any;
+        expect(widget.model.metadata.get('execution')).toBeDefined();
+        const timingInfo = widget.model.metadata.get('execution') as any;
         for (const key of TIMING_KEYS) {
           expect(timingInfo[key]).toBeDefined();
         }
       });
 
       it('should set the cell prompt properly while executing', async () => {
-        const widget = new CodeCell({
-          model,
-          rendermime,
-          contentFactory,
-          placeholder: false
-        });
-        widget.initializeState();
-        widget.model.sharedModel.setSource('foo');
+        const widget = new CodeCell({ model, rendermime, contentFactory });
+        widget.initializeState();
+        widget.model.value.text = 'foo';
         const future1 = CodeCell.execute(widget, sessionContext);
-        expect(widget.promptNode!.textContent).toEqual('[*]:');
+        expect(widget.promptNode.textContent).toEqual('[*]:');
         const future2 = CodeCell.execute(widget, sessionContext);
-        expect(widget.promptNode!.textContent).toEqual('[*]:');
+        expect(widget.promptNode.textContent).toEqual('[*]:');
         await expect(future1).rejects.toThrow('Canceled');
-        expect(widget.promptNode!.textContent).toEqual('[*]:');
+        expect(widget.promptNode.textContent).toEqual('[*]:');
         const msg = await future2;
         expect(msg).not.toBeUndefined();
 
-        expect(widget.promptNode!.textContent).toEqual(
-          `[${(msg as IExecuteReplyMsg).content.execution_count}]:`
-        );
+        // The `if` is a Typescript type guard so that msg.content works below.
+        if (msg) {
+          expect(widget.promptNode.textContent).toEqual(
+            `[${msg.content.execution_count}]:`
+          );
+        }
       });
     });
   });
 
   describe('MarkdownCell', () => {
     const contentFactory = NBTestUtils.createBaseCellFactory();
-    const model = new MarkdownCellModel();
+    const model = new MarkdownCellModel({});
+
     describe('#constructor()', () => {
       it('should create a markdown cell widget', () => {
-        const widget = new MarkdownCell({
-          model,
-          rendermime,
-          contentFactory,
-          placeholder: false
-        });
+        const widget = new MarkdownCell({ model, rendermime, contentFactory });
         widget.initializeState();
         expect(widget).toBeInstanceOf(MarkdownCell);
       });
 
       it('should accept a custom contentFactory', () => {
-        const widget = new MarkdownCell({
-          model,
-          rendermime,
-          contentFactory,
-          placeholder: false
-        });
+        const widget = new MarkdownCell({ model, rendermime, contentFactory });
         widget.initializeState();
         expect(widget).toBeInstanceOf(MarkdownCell);
       });
 
       it('should set the default mimetype to text/x-ipythongfm', () => {
-        const widget = new MarkdownCell({
-          model,
-          rendermime,
-          contentFactory,
-          placeholder: false
-        });
+        const widget = new MarkdownCell({ model, rendermime, contentFactory });
         widget.initializeState();
         expect(widget.model.mimeType).toEqual('text/x-ipythongfm');
-      });
-    });
-
-    describe('#getEditorOptions()', () => {
-      it('should normalise line endings on paste', () => {
-        const model = new MarkdownCellModel({
-          sharedModel: createStandaloneCell({
-            cell_type: 'markdown'
-          }) as YMarkdownCell
-        });
-        const widget = new MarkdownCell({
-          model,
-          rendermime,
-          contentFactory,
-          placeholder: false
-        });
-        widget.initializeState();
-        document.body.appendChild(widget.node);
-        // todo: replace with user-event
-        const dt = new DataTransfer();
-        dt.setData('text/plain', '\r\nTest\r\nString\r\n.\r\n');
-        const event = new ClipboardEvent('paste', { clipboardData: dt });
-        widget.editor!.host.querySelector('.cm-content')!.dispatchEvent(event);
-
-        expect(widget.model.sharedModel.getSource()).toEqual(
-          '\nTest\nString\n.\n'
-        );
       });
     });
 
     describe('#rendered', () => {
       it('should default to true', async () => {
-        const widget = new MarkdownCell({
-          model,
-          rendermime,
-          contentFactory,
-          placeholder: false
-        });
+        const widget = new MarkdownCell({ model, rendermime, contentFactory });
         widget.initializeState();
         Widget.attach(widget, document.body);
         expect(widget.rendered).toEqual(true);
@@ -1041,16 +838,10 @@
       });
 
       it('should unrender the widget', async () => {
-        const widget = new MarkdownCell({
-          model,
-          rendermime,
-          contentFactory,
-          placeholder: false
-        });
+        const widget = new MarkdownCell({ model, rendermime, contentFactory });
         widget.initializeState();
         Widget.attach(widget, document.body);
         widget.rendered = false;
-        await signalToPromise(widget.renderedChanged);
         await framePromise();
         expect(widget.node.classList.contains(RENDERED_CLASS)).toEqual(false);
         widget.dispose();
@@ -1059,24 +850,14 @@
 
     describe('#dispose()', () => {
       it('should dispose of the resources held by the widget', () => {
-        const widget = new MarkdownCell({
-          model,
-          rendermime,
-          contentFactory,
-          placeholder: false
-        });
+        const widget = new MarkdownCell({ model, rendermime, contentFactory });
         widget.initializeState();
         widget.dispose();
         expect(widget.isDisposed).toEqual(true);
       });
 
       it('should be safe to call multiple times', () => {
-        const widget = new MarkdownCell({
-          model,
-          rendermime,
-          contentFactory,
-          placeholder: false
-        });
+        const widget = new MarkdownCell({ model, rendermime, contentFactory });
         widget.initializeState();
         widget.dispose();
         widget.dispose();
@@ -1089,8 +870,7 @@
         const widget = new LogMarkdownCell({
           model,
           rendermime,
-          contentFactory,
-          placeholder: false
+          contentFactory
         }).initializeState();
         expect(widget.methods).not.toContain('onUpdateRequest');
         MessageLoop.sendMessage(widget, Widget.Msg.UpdateRequest);
@@ -1104,12 +884,8 @@
 
     describe('#constructor()', () => {
       it('should create a raw cell widget', () => {
-        const model = new RawCellModel();
-        const widget = new RawCell({
-          model,
-          contentFactory,
-          placeholder: false
-        }).initializeState();
+        const model = new RawCellModel({});
+        const widget = new RawCell({ model, contentFactory }).initializeState();
         expect(widget).toBeInstanceOf(RawCell);
       });
     });