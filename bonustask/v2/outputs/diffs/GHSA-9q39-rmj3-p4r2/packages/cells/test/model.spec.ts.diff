--- packages\cells\test\model.spec.ts (old)
+++ packages\cells\test\model.spec.ts (new)
@@ -1,24 +1,24 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
-import {
-  createStandaloneCell,
-  ISharedCodeCell,
-  YCodeCell,
-  YMarkdownCell,
-  YRawCell
-} from '@jupyter/ydoc';
+import { toArray } from '@lumino/algorithm';
+
+import { IChangedArgs } from '@jupyterlab/coreutils';
+
 import {
   CellModel,
   CodeCellModel,
   MarkdownCellModel,
   RawCellModel
 } from '@jupyterlab/cells';
-import { IChangedArgs } from '@jupyterlab/coreutils';
+
 import * as nbformat from '@jupyterlab/nbformat';
+
 import { OutputAreaModel } from '@jupyterlab/outputarea';
-import { DEFAULT_OUTPUTS } from '@jupyterlab/rendermime/lib/testutils';
+
+import { NBTestUtils } from '@jupyterlab/testutils';
 import { JSONObject } from '@lumino/coreutils';
+import { YCodeCell } from '@jupyterlab/shared-models';
 
 class TestModel extends CellModel {
   get type(): 'raw' {
@@ -30,60 +30,64 @@
   describe('CellModel', () => {
     describe('#constructor()', () => {
       it('should create a cell model', () => {
-        const model = new TestModel({
-          sharedModel: createStandaloneCell({ cell_type: 'code' }) as YCodeCell
-        });
+        const model = new CellModel({});
         expect(model).toBeInstanceOf(CellModel);
       });
 
       it('should accept a base cell argument', () => {
-        const sharedModel = createStandaloneCell({
+        const cell: nbformat.IRawCell = {
           cell_type: 'raw',
           source: 'foo',
           metadata: { trusted: false }
-        }) as YRawCell;
-        const model = new TestModel({ sharedModel });
+        };
+        const model = new CellModel({ cell });
         expect(model).toBeInstanceOf(CellModel);
-        expect(model.sharedModel.getSource()).toBe('foo');
+        expect(model.value.text).toBe(cell.source);
       });
 
       it('should accept a base cell argument with a multiline source', () => {
-        const sharedModel = createStandaloneCell({
+        const cell: nbformat.IRawCell = {
           cell_type: 'raw',
           source: ['foo\n', 'bar\n', 'baz'],
           metadata: { trusted: false },
           id: 'cell_id'
-        }) as YRawCell;
-        const model = new TestModel({ sharedModel });
+        };
+        const model = new CellModel({ cell });
         expect(model).toBeInstanceOf(CellModel);
-        expect(model.sharedModel.getSource()).toBe('foo\nbar\nbaz');
-      });
-
-      it('should use the cell id if an id is supplied', () => {
-        const sharedModel = createStandaloneCell({
+        expect(model.value.text).toBe((cell.source as string[]).join(''));
+      });
+
+      it('should use the id argument', () => {
+        const cell: nbformat.IRawCell = {
           cell_type: 'raw',
           source: ['foo\n', 'bar\n', 'baz'],
           metadata: { trusted: false },
           id: 'cell_id'
-        }) as YRawCell;
-        const model = new TestModel({ sharedModel, id: 'my_id' });
+        };
+        const model = new CellModel({ cell, id: 'my_id' });
+        expect(model).toBeInstanceOf(CellModel);
+        expect(model.id).toBe('my_id');
+      });
+
+      it('should use the cell id if an id is not supplied', () => {
+        const cell: nbformat.IRawCell = {
+          cell_type: 'raw',
+          source: ['foo\n', 'bar\n', 'baz'],
+          metadata: { trusted: false },
+          id: 'cell_id'
+        };
+        const model = new CellModel({ cell });
         expect(model).toBeInstanceOf(CellModel);
         expect(model.id).toBe('cell_id');
       });
 
-      it('should use the id if an cell is not supplied', () => {
-        const model = new TestModel({ id: 'cell_id' });
-        expect(model).toBeInstanceOf(CellModel);
-        expect(model.id).toBe('cell_id');
-      });
-
       it('should generate an id if an id or cell id is not supplied', () => {
-        const sharedModel = createStandaloneCell({
+        const cell = {
           cell_type: 'raw',
           source: ['foo\n', 'bar\n', 'baz'],
           metadata: { trusted: false }
-        }) as YRawCell;
-        const model = new TestModel({ sharedModel });
+        };
+        const model = new CellModel({ cell });
         expect(model).toBeInstanceOf(CellModel);
         expect(model.id.length).toBeGreaterThan(0);
       });
@@ -91,26 +95,23 @@
 
     describe('#contentChanged', () => {
       it('should signal when model content has changed', () => {
-        const model = new TestModel({
-          sharedModel: createStandaloneCell({ cell_type: 'code' }) as YCodeCell
-        });
+        const model = new CellModel({});
         let called = false;
         model.contentChanged.connect(() => {
           called = true;
         });
         expect(called).toBe(false);
-        model.sharedModel.setSource('foo');
+        model.value.text = 'foo';
         expect(called).toBe(true);
       });
     });
 
     describe('#stateChanged', () => {
       it('should signal when model state has changed', () => {
-        const model = new CodeCellModel();
+        const model = new CodeCellModel({});
         let called = false;
         const listener = (sender: any, args: IChangedArgs<any>) => {
           if (args.name == 'executionCount') {
-            // eslint-disable-next-line jest/no-conditional-expect
             expect(args.newValue).toBe(1);
             called = true;
           }
@@ -121,10 +122,10 @@
       });
 
       it('should not signal when model state has not changed', () => {
-        const model = new CodeCellModel();
+        const model = new CodeCellModel({});
         let called = 0;
-        model.sharedModel.changed.connect((model, change) => {
-          if (change.executionCountChange) {
+        model.stateChanged.connect((model, args) => {
+          if (args.name == 'executionCount') {
             called++;
           }
         });
@@ -138,19 +139,17 @@
 
     describe('#trusted', () => {
       it('should be the trusted state of the cell', () => {
-        const model = new CodeCellModel();
+        const model = new CodeCellModel({});
         expect(model.trusted).toBe(false);
         model.trusted = true;
         expect(model.trusted).toBe(true);
-        const other = new CodeCellModel({
-          trusted: true
-        });
+        const other = new CodeCellModel({ cell: model.toJSON() });
         expect(other.trusted).toBe(true);
       });
 
       it('should update the trusted state of the output models', () => {
-        const model = new CodeCellModel();
-        model.outputs.add(DEFAULT_OUTPUTS[0]);
+        const model = new CodeCellModel({});
+        model.outputs.add(NBTestUtils.DEFAULT_OUTPUTS[0]);
         expect(model.outputs.get(0).trusted).toBe(false);
         model.trusted = true;
         expect(model.outputs.get(0).trusted).toBe(true);
@@ -159,59 +158,53 @@
 
     describe('#metadataChanged', () => {
       it('should signal when model metadata has changed', () => {
-        const model = new CodeCellModel();
+        const model = new TestModel({});
         const listener = (sender: any, args: any) => {
           value = args.newValue;
         };
         let value = '';
-        model.metadataChanged.connect(listener);
+        model.metadata.changed.connect(listener);
         expect(Object.keys(value)).toHaveLength(0);
-        model.setMetadata('foo', 'bar');
+        model.metadata.set('foo', 'bar');
         expect(value).toBe('bar');
       });
 
       it('should not signal when model metadata has not changed', () => {
-        const model = new TestModel({
-          sharedModel: createStandaloneCell({ cell_type: 'code' })
-        });
+        const model = new TestModel({});
         let called = 0;
-        model.metadataChanged.connect(() => {
+        model.metadata.changed.connect(() => {
           called++;
         });
         expect(called).toBe(0);
-        model.setMetadata('foo', 'bar');
+        model.metadata.set('foo', 'bar');
         expect(called).toBe(1);
-        model.setMetadata('foo', 'bar');
+        model.metadata.set('foo', 'bar');
         expect(called).toBe(1);
       });
     });
 
     describe('#source', () => {
       it('should default to an empty string', () => {
-        const model = new CodeCellModel();
-        expect(model.sharedModel.getSource()).toHaveLength(0);
+        const model = new CellModel({});
+        expect(model.value.text).toHaveLength(0);
       });
 
       it('should be settable', () => {
-        const model = new CodeCellModel();
-        expect(model.sharedModel.getSource()).toHaveLength(0);
-        model.sharedModel.setSource('foo');
-        expect(model.sharedModel.getSource()).toBe('foo');
+        const model = new CellModel({});
+        expect(model.value.text).toHaveLength(0);
+        model.value.text = 'foo';
+        expect(model.value.text).toBe('foo');
       });
     });
 
     describe('#isDisposed', () => {
       it('should be false by default', () => {
-        const model = new TestModel({
-          sharedModel: createStandaloneCell({ cell_type: 'code' }) as YCodeCell
-        });
+        const model = new CellModel({});
         expect(model.isDisposed).toBe(false);
       });
 
       it('should be true after model is disposed', () => {
-        const model = new TestModel({
-          sharedModel: createStandaloneCell({ cell_type: 'code' }) as YCodeCell
-        });
+        const model = new CellModel({});
         model.dispose();
         expect(model.isDisposed).toBe(true);
       });
@@ -219,17 +212,13 @@
 
     describe('#dispose()', () => {
       it('should dispose of the resources held by the model', () => {
-        const model = new TestModel({
-          sharedModel: createStandaloneCell({ cell_type: 'code' })
-        });
+        const model = new TestModel({});
         model.dispose();
         expect(model.isDisposed).toBe(true);
       });
 
       it('should be safe to call multiple times', () => {
-        const model = new TestModel({
-          sharedModel: createStandaloneCell({ cell_type: 'code' }) as YCodeCell
-        });
+        const model = new CellModel({});
         model.dispose();
         model.dispose();
         expect(model.isDisposed).toBe(true);
@@ -239,28 +228,22 @@
     describe('#toJSON()', () => {
       it('should return a base cell encapsulation of the model value', () => {
         const cell: nbformat.IRawCell = {
-          id: '42',
           cell_type: 'raw',
           source: 'foo',
           metadata: { trusted: false }
         };
-        const model = new TestModel({
-          sharedModel: createStandaloneCell(cell)
-        });
+        const model = new TestModel({ cell });
         expect(model.toJSON()).not.toBe(cell);
         expect(model.toJSON()).toEqual(cell);
       });
 
       it('should always return a string source', () => {
         const cell: nbformat.IRawCell = {
-          id: '42',
           cell_type: 'raw',
           source: ['foo\n', 'bar\n', 'baz'],
           metadata: { trusted: false }
         };
-        const model = new TestModel({
-          sharedModel: createStandaloneCell(cell)
-        });
+        const model = new TestModel({ cell });
         cell.source = (cell.source as string[]).join('');
         expect(model.toJSON()).not.toBe(cell);
         expect(model.toJSON()).toEqual(cell);
@@ -269,32 +252,26 @@
 
     describe('#metadata', () => {
       it('should handle a metadata for the cell', () => {
-        const model = new TestModel({
-          sharedModel: createStandaloneCell({ cell_type: 'code' }) as YCodeCell
-        });
-        expect(model.getMetadata('foo')).toBeUndefined();
-        model.setMetadata('foo', 1);
-        expect(model.getMetadata('foo')).toBe(1);
+        const model = new CellModel({});
+        expect(model.metadata.get('foo')).toBeUndefined();
+        model.metadata.set('foo', 1);
+        expect(model.metadata.get('foo')).toBe(1);
       });
 
       it('should get a list of user metadata keys', () => {
-        const model = new TestModel({
-          sharedModel: createStandaloneCell({ cell_type: 'code' }) as YCodeCell
-        });
-        expect(Array.from(Object.keys(model.metadata))).toHaveLength(0);
-        model.setMetadata('foo', 1);
-        expect(Object.keys(model.metadata)).toEqual(['foo']);
+        const model = new CellModel({});
+        expect(toArray(model.metadata.keys())).toHaveLength(0);
+        model.metadata.set('foo', 1);
+        expect(model.metadata.keys()).toEqual(['foo']);
       });
 
       it('should trigger changed signal', () => {
-        const model = new TestModel({
-          sharedModel: createStandaloneCell({ cell_type: 'code' }) as YCodeCell
-        });
+        const model = new CellModel({});
         let called = false;
-        model.metadataChanged.connect(() => {
+        model.metadata.changed.connect(() => {
           called = true;
         });
-        model.setMetadata('foo', 1);
+        model.metadata.set('foo', 1);
         expect(called).toBe(true);
       });
     });
@@ -303,7 +280,7 @@
   describe('RawCellModel', () => {
     describe('#type', () => {
       it('should be set with type "raw"', () => {
-        const model = new RawCellModel();
+        const model = new RawCellModel({});
         expect(model.type).toBe('raw');
       });
     });
@@ -315,9 +292,7 @@
           metadata: {},
           id: 'cell_id'
         };
-        const model = new RawCellModel({
-          sharedModel: createStandaloneCell(cell) as YRawCell
-        });
+        const model = new RawCellModel({ cell });
         const serialized = model.toJSON();
         expect(serialized).not.toBe(cell);
         expect(serialized).toEqual(cell);
@@ -328,7 +303,7 @@
   describe('MarkdownCellModel', () => {
     describe('#type', () => {
       it('should be set with type "markdown"', () => {
-        const model = new MarkdownCellModel();
+        const model = new MarkdownCellModel({});
         expect(model.type).toBe('markdown');
       });
     });
@@ -340,9 +315,7 @@
           metadata: {},
           id: 'cell_id'
         };
-        const model = new MarkdownCellModel({
-          sharedModel: createStandaloneCell(cell) as YMarkdownCell
-        });
+        const model = new MarkdownCellModel({ cell });
         const serialized = model.toJSON();
         expect(serialized).not.toBe(cell);
         expect(serialized).toEqual(cell);
@@ -353,12 +326,12 @@
   describe('CodeCellModel', () => {
     describe('#constructor()', () => {
       it('should create a code cell model', () => {
-        const model = new CodeCellModel();
+        const model = new CodeCellModel({});
         expect(model).toBeInstanceOf(CodeCellModel);
       });
 
       it('should accept a code cell argument', () => {
-        const sharedModel = createStandaloneCell({
+        const cell: nbformat.ICodeCell = {
           cell_type: 'code',
           execution_count: 1,
           outputs: [
@@ -370,10 +343,10 @@
           ],
           source: 'foo',
           metadata: { trusted: false }
-        }) as YCodeCell;
-        const model = new CodeCellModel({ sharedModel });
+        };
+        const model = new CodeCellModel({ cell });
         expect(model).toBeInstanceOf(CodeCellModel);
-        expect(model.sharedModel.getSource()).toBe('foo');
+        expect(model.value.text).toBe(cell.source);
       });
 
       it('should connect the outputs changes to content change signal', () => {
@@ -382,7 +355,7 @@
           data: { 'text/plain': 'foo' },
           metadata: {}
         } as nbformat.IDisplayData;
-        const model = new CodeCellModel();
+        const model = new CodeCellModel({});
         let called = false;
         model.contentChanged.connect(() => {
           called = true;
@@ -398,74 +371,76 @@
 
         // Setting `collapsed` works
         model = new CodeCellModel({
-          sharedModel: createStandaloneCell({
+          cell: {
             cell_type: 'code',
             source: '',
             metadata: { collapsed: true }
-          }) as YCodeCell
-        });
-        expect(model.getMetadata('collapsed')).toBe(true);
-        jupyter = model.getMetadata('jupyter') as JSONObject;
+          }
+        });
+        expect(model.metadata.get('collapsed')).toBe(true);
+        jupyter = model.metadata.get('jupyter') as JSONObject;
         expect(jupyter.outputs_hidden).toBe(true);
 
         // Setting `jupyter.outputs_hidden` works
         model = new CodeCellModel({
-          sharedModel: createStandaloneCell({
+          cell: {
             cell_type: 'code',
             source: '',
             metadata: { jupyter: { outputs_hidden: true } }
-          }) as YCodeCell
-        });
-        expect(model.getMetadata('collapsed')).toBe(true);
-        jupyter = model.getMetadata('jupyter') as JSONObject;
+          }
+        });
+        expect(model.metadata.get('collapsed')).toBe(true);
+        jupyter = model.metadata.get('jupyter') as JSONObject;
         expect(jupyter.outputs_hidden).toBe(true);
 
         // `collapsed` takes precedence
         model = new CodeCellModel({
-          sharedModel: createStandaloneCell({
+          cell: {
             cell_type: 'code',
             source: '',
             metadata: { collapsed: false, jupyter: { outputs_hidden: true } }
-          }) as YCodeCell
-        });
-        expect(model.getMetadata('collapsed')).toBe(false);
-        jupyter = model.getMetadata('jupyter') as JSONObject;
+          }
+        });
+        expect(model.metadata.get('collapsed')).toBe(false);
+        jupyter = model.metadata.get('jupyter') as JSONObject;
         expect(jupyter.outputs_hidden).toBe(false);
       });
     });
 
     describe('#type', () => {
       it('should be set with type "code"', () => {
-        const model = new CodeCellModel();
+        const model = new CodeCellModel({});
         expect(model.type).toBe('code');
       });
     });
 
     describe('#executionCount', () => {
       it('should show the execution count of the cell', () => {
-        const sharedModel = createStandaloneCell({
+        const cell: nbformat.ICodeCell = {
           cell_type: 'code',
           execution_count: 1,
           outputs: [],
           source: 'foo',
           metadata: { trusted: false }
-        }) as YCodeCell;
-        const model = new CodeCellModel({ sharedModel });
+        };
+        const model = new CodeCellModel({ cell });
         expect(model.executionCount).toBe(1);
       });
 
       it('should be settable', () => {
-        const model = new CodeCellModel();
+        const model = new CodeCellModel({});
+        expect(model.executionCount).toBeNull();
         model.executionCount = 1;
         expect(model.executionCount).toBe(1);
       });
 
       it('should emit a state change signal when set', () => {
-        const model = new CodeCellModel();
+        const model = new CodeCellModel({});
         let called = false;
         model.stateChanged.connect(() => {
           called = true;
         });
+        expect(model.executionCount).toBeNull();
         expect(called).toBe(false);
         model.executionCount = 1;
         expect(model.executionCount).toBe(1);
@@ -473,13 +448,14 @@
       });
 
       it('should not signal when state has not changed', () => {
-        const model = new CodeCellModel();
+        const model = new CodeCellModel({});
         let called = 0;
-        model.sharedModel.changed.connect((model, args) => {
-          if (args.executionCountChange) {
+        model.stateChanged.connect((model, args) => {
+          if (args.name == 'executionCount') {
             called++;
           }
         });
+        expect(model.executionCount).toBeNull();
         expect(called).toBe(0);
         model.executionCount = 1;
         expect(model.executionCount).toBe(1);
@@ -488,14 +464,14 @@
       });
 
       it('should set dirty flag and signal', () => {
-        const model = new CodeCellModel();
+        const model = new CodeCellModel({});
         let called = 0;
         model.stateChanged.connect((model, args) => {
           if (args.name == 'isDirty') {
             called++;
           }
         });
-        expect(model.executionCount).toBe(null);
+        expect(model.executionCount).toBeNull();
         expect(model.isDirty).toBe(false);
         expect(called).toBe(0);
 
@@ -503,7 +479,7 @@
         expect(model.isDirty).toBe(false);
         expect(called).toBe(0);
 
-        model.sharedModel.setSource('foo');
+        model.value.text = 'foo';
         expect(model.isDirty).toBe(true);
         expect(called).toBe(1);
 
@@ -515,14 +491,14 @@
 
     describe('#outputs', () => {
       it('should be an output area model', () => {
-        const model = new CodeCellModel();
+        const model = new CodeCellModel({});
         expect(model.outputs).toBeInstanceOf(OutputAreaModel);
       });
     });
 
     describe('#dispose()', () => {
       it('should dispose of the resources held by the model', () => {
-        const model = new CodeCellModel();
+        const model = new CodeCellModel({});
         expect(model.outputs).toBeInstanceOf(OutputAreaModel);
         model.dispose();
         expect(model.isDisposed).toBe(true);
@@ -530,7 +506,7 @@
       });
 
       it('should be safe to call multiple times', () => {
-        const model = new CodeCellModel();
+        const model = new CodeCellModel({});
         model.dispose();
         model.dispose();
         expect(model.isDisposed).toBe(true);
@@ -556,9 +532,7 @@
           metadata: { trusted: false },
           id: 'cell_id'
         };
-        const model = new CodeCellModel({
-          sharedModel: createStandaloneCell(cell) as ISharedCodeCell
-        });
+        const model = new CodeCellModel({ cell });
         const serialized = model.toJSON();
         expect(serialized).not.toBe(cell);
         expect(serialized).toEqual(cell);
@@ -567,7 +541,7 @@
       });
     });
 
-    describe('#onOutputsChange()', () => {
+    describe('#onModelDBOutputsChange()', () => {
       const output0 = {
         output_type: 'display_data',
         data: {
@@ -601,7 +575,7 @@
         id: 'cell_id'
       };
       it('should add new items correctly', () => {
-        const model = new CodeCellModel();
+        const model = new CodeCellModel({});
         const sharedModel = model.sharedModel as YCodeCell;
         expect(sharedModel.ymodel.get('outputs').length).toBe(0);
 
@@ -612,7 +586,7 @@
           oldIndex: -1,
           newIndex: 0
         } as any;
-        model['onOutputsChange'](null as any, newEvent0);
+        model['onModelDBOutputsChange'](null as any, newEvent0);
         expect(sharedModel.ymodel.get('outputs').length).toBe(1);
         expect(sharedModel.ymodel.get('outputs').get(0)).toEqual(output0);
 
@@ -623,15 +597,13 @@
           oldIndex: -1,
           newIndex: 1
         } as any;
-        model['onOutputsChange'](null as any, newEvent1);
+        model['onModelDBOutputsChange'](null as any, newEvent1);
         expect(sharedModel.ymodel.get('outputs').length).toBe(2);
         expect(sharedModel.ymodel.get('outputs').get(1)).toEqual(output1);
       });
 
       it('should set new items correctly', () => {
-        const model = new CodeCellModel({
-          sharedModel: createStandaloneCell(cell) as ISharedCodeCell
-        });
+        const model = new CodeCellModel({ cell });
         const sharedModel = model.sharedModel as YCodeCell;
         expect(sharedModel.ymodel.get('outputs').length).toBe(2);
 
@@ -642,7 +614,7 @@
           oldIndex: 0,
           newIndex: 0
         } as any;
-        model['onOutputsChange'](null as any, newEvent0);
+        model['onModelDBOutputsChange'](null as any, newEvent0);
         expect(sharedModel.ymodel.get('outputs').length).toBe(2);
         expect(sharedModel.ymodel.get('outputs').get(0)).toEqual(output2);
         const newEvent1 = {
@@ -652,17 +624,16 @@
           oldIndex: 1,
           newIndex: 1
         } as any;
-        model['onOutputsChange'](null as any, newEvent1);
+        model['onModelDBOutputsChange'](null as any, newEvent1);
         expect(sharedModel.ymodel.get('outputs').length).toBe(2);
         expect(sharedModel.ymodel.get('outputs').get(1)).toEqual(output2);
       });
 
       it('should remove items correctly', () => {
-        const model = new CodeCellModel({
-          sharedModel: createStandaloneCell(cell) as ISharedCodeCell
-        });
+        const model = new CodeCellModel({ cell });
         const sharedModel = model.sharedModel as YCodeCell;
-        expect(sharedModel.getOutputs().length).toBe(2);
+        expect(sharedModel.ymodel.get('outputs').length).toBe(2);
+
         const newEvent0 = {
           type: 'remove',
           newValues: [],
@@ -670,75 +641,75 @@
           oldIndex: 0,
           newIndex: 0
         } as any;
-        model['onOutputsChange'](null as any, newEvent0);
+        model['onModelDBOutputsChange'](null as any, newEvent0);
         expect(sharedModel.ymodel.get('outputs').length).toBe(0);
       });
     });
 
     describe('.metadata', () => {
       it('should sync collapsed and jupyter.outputs_hidden metadata when changed', () => {
-        const cell = new CodeCellModel();
-
-        expect(cell.getMetadata('collapsed')).toBeUndefined();
-        expect(cell.getMetadata('jupyter')).toBeUndefined();
+        const metadata = new CodeCellModel({}).metadata;
+
+        expect(metadata.get('collapsed')).toBeUndefined();
+        expect(metadata.get('jupyter')).toBeUndefined();
 
         // Setting collapsed sets jupyter.outputs_hidden
-        cell.setMetadata('collapsed', true);
-        expect(cell.getMetadata('collapsed')).toBe(true);
-        expect(cell.getMetadata('jupyter')).toEqual({
+        metadata.set('collapsed', true);
+        expect(metadata.get('collapsed')).toBe(true);
+        expect(metadata.get('jupyter')).toEqual({
           outputs_hidden: true
         });
 
-        cell.setMetadata('collapsed', false);
-        expect(cell.getMetadata('collapsed')).toBe(false);
-        expect(cell.getMetadata('jupyter')).toEqual({
+        metadata.set('collapsed', false);
+        expect(metadata.get('collapsed')).toBe(false);
+        expect(metadata.get('jupyter')).toEqual({
           outputs_hidden: false
         });
 
-        cell.deleteMetadata('collapsed');
-        expect(cell.getMetadata('collapsed')).toBeUndefined();
-        expect(cell.getMetadata('jupyter')).toBeUndefined();
+        metadata.delete('collapsed');
+        expect(metadata.get('collapsed')).toBeUndefined();
+        expect(metadata.get('jupyter')).toBeUndefined();
 
         // Setting jupyter.outputs_hidden sets collapsed
-        cell.setMetadata('jupyter', { outputs_hidden: true });
-        expect(cell.getMetadata('collapsed')).toBe(true);
-        expect(cell.getMetadata('jupyter')).toEqual({
+        metadata.set('jupyter', { outputs_hidden: true });
+        expect(metadata.get('collapsed')).toBe(true);
+        expect(metadata.get('jupyter')).toEqual({
           outputs_hidden: true
         });
 
-        cell.setMetadata('jupyter', { outputs_hidden: false });
-        expect(cell.getMetadata('collapsed')).toBe(false);
-        expect(cell.getMetadata('jupyter')).toEqual({
+        metadata.set('jupyter', { outputs_hidden: false });
+        expect(metadata.get('collapsed')).toBe(false);
+        expect(metadata.get('jupyter')).toEqual({
           outputs_hidden: false
         });
 
-        cell.deleteMetadata('jupyter');
-        expect(cell.getMetadata('collapsed')).toBeUndefined();
-        expect(cell.getMetadata('jupyter')).toBeUndefined();
+        metadata.delete('jupyter');
+        expect(metadata.get('collapsed')).toBeUndefined();
+        expect(metadata.get('jupyter')).toBeUndefined();
 
         // Deleting jupyter.outputs_hidden preserves other jupyter fields
-        cell.setMetadata('jupyter', { outputs_hidden: true, other: true });
-        expect(cell.getMetadata('collapsed')).toBe(true);
-        expect(cell.getMetadata('jupyter')).toEqual({
+        metadata.set('jupyter', { outputs_hidden: true, other: true });
+        expect(metadata.get('collapsed')).toBe(true);
+        expect(metadata.get('jupyter')).toEqual({
           outputs_hidden: true,
           other: true
         });
-        cell.setMetadata('jupyter', { other: true });
-        expect(cell.getMetadata('collapsed')).toBeUndefined();
-        expect(cell.getMetadata('jupyter')).toEqual({
+        metadata.set('jupyter', { other: true });
+        expect(metadata.get('collapsed')).toBeUndefined();
+        expect(metadata.get('jupyter')).toEqual({
           other: true
         });
 
         // Deleting collapsed preserves other jupyter fields
-        cell.setMetadata('jupyter', { outputs_hidden: true, other: true });
-        expect(cell.getMetadata('collapsed')).toBe(true);
-        expect(cell.getMetadata('jupyter')).toEqual({
+        metadata.set('jupyter', { outputs_hidden: true, other: true });
+        expect(metadata.get('collapsed')).toBe(true);
+        expect(metadata.get('jupyter')).toEqual({
           outputs_hidden: true,
           other: true
         });
-        cell.deleteMetadata('collapsed');
-        expect(cell.getMetadata('collapsed')).toBeUndefined();
-        expect(cell.getMetadata('jupyter')).toEqual({
+        metadata.delete('collapsed');
+        expect(metadata.get('collapsed')).toBeUndefined();
+        expect(metadata.get('jupyter')).toEqual({
           other: true
         });
       });