--- packages\terminal-extension\src\index.ts (old)
+++ packages\terminal-extension\src\index.ts (new)
@@ -18,23 +18,22 @@
   WidgetTracker
 } from '@jupyterlab/apputils';
 import { ILauncher } from '@jupyterlab/launcher';
-import { IMainMenu } from '@jupyterlab/mainmenu';
+import { IFileMenu, IMainMenu } from '@jupyterlab/mainmenu';
 import { IRunningSessionManagers, IRunningSessions } from '@jupyterlab/running';
 import { Terminal, TerminalAPI } from '@jupyterlab/services';
 import { ISettingRegistry } from '@jupyterlab/settingregistry';
-import {
-  ITerminal,
-  ITerminalTracker,
-  Terminal as XTerm
-} from '@jupyterlab/terminal';
+import { ITerminal, ITerminalTracker } from '@jupyterlab/terminal';
+// Name-only import so as to not trigger inclusion in main bundle
+import * as WidgetModuleType from '@jupyterlab/terminal/lib/widget';
 import { ITranslator } from '@jupyterlab/translation';
+import { toArray } from '@lumino/algorithm';
 import {
   copyIcon,
   pasteIcon,
   refreshIcon,
   terminalIcon
 } from '@jupyterlab/ui-components';
-import { Menu, Widget } from '@lumino/widgets';
+import { Menu } from '@lumino/widgets';
 
 /**
  * The command IDs used by the terminal plugin.
@@ -55,8 +54,6 @@
   export const paste = 'terminal:paste';
 
   export const setTheme = 'terminal:set-theme';
-
-  export const shutdown = 'terminal:shut-down';
 }
 
 /**
@@ -65,7 +62,6 @@
 const plugin: JupyterFrontEndPlugin<ITerminalTracker> = {
   activate,
   id: '@jupyterlab/terminal-extension:plugin',
-  description: 'Adds terminal and provides its tracker.',
   provides: ITerminalTracker,
   requires: [ISettingRegistry, ITranslator],
   optional: [
@@ -228,9 +224,13 @@
 
     // Add terminal close-and-shutdown to the file menu.
     mainMenu.fileMenu.closeAndCleaners.add({
-      id: CommandIDs.shutdown,
-      isEnabled: (w: Widget) => tracker.currentWidget !== null && tracker.has(w)
-    });
+      tracker,
+      closeAndCleanupLabel: (n: number) => trans.__('Shutdown Terminal'),
+      closeAndCleanup: (current: MainAreaWidget<ITerminal.ITerminal>) => {
+        // The widget is automatically disposed upon session shutdown.
+        return current.content.session.shutdown();
+      }
+    } as IFileMenu.ICloseAndCleaner<MainAreaWidget<ITerminal.ITerminal>>);
   }
 
   if (palette) {
@@ -292,30 +292,10 @@
   const trans = translator.load('jupyterlab');
   const manager = app.serviceManager.terminals;
 
-  class RunningTerminal implements IRunningSessions.IRunningItem {
-    constructor(model: Terminal.IModel) {
-      this._model = model;
-    }
-    open() {
-      void app.commands.execute('terminal:open', { name: this._model.name });
-    }
-    icon() {
-      return terminalIcon;
-    }
-    label() {
-      return `terminals/${this._model.name}`;
-    }
-    shutdown() {
-      return manager.shutdown(this._model.name);
-    }
-
-    private _model: Terminal.IModel;
-  }
-
   managers.add({
     name: trans.__('Terminals'),
     running: () =>
-      Array.from(manager.running()).map(model => new RunningTerminal(model)),
+      toArray(manager.running()).map(model => new RunningTerminal(model)),
     shutdownAll: () => manager.shutdownAll(),
     refreshRunning: () => manager.refreshRunning(),
     runningChanged: manager.runningChanged,
@@ -325,12 +305,32 @@
       'Are you sure you want to permanently shut down all running terminals?'
     )
   });
+
+  class RunningTerminal implements IRunningSessions.IRunningItem {
+    constructor(model: Terminal.IModel) {
+      this._model = model;
+    }
+    open() {
+      void app.commands.execute('terminal:open', { name: this._model.name });
+    }
+    icon() {
+      return terminalIcon;
+    }
+    label() {
+      return `terminals/${this._model.name}`;
+    }
+    shutdown() {
+      return manager.shutdown(this._model.name);
+    }
+
+    private _model: Terminal.IModel;
+  }
 }
 
 /**
  * Add the commands for the terminal.
  */
-function addCommands(
+export function addCommands(
   app: JupyterFrontEnd,
   tracker: WidgetTracker<MainAreaWidget<ITerminal.ITerminal>>,
   settingRegistry: ISettingRegistry,
@@ -351,11 +351,17 @@
     caption: trans.__('Start a new terminal session'),
     icon: args => (args['isPalette'] ? undefined : terminalIcon),
     execute: async args => {
+      // wait for the widget to lazy load
+      let Terminal: typeof WidgetModuleType.Terminal;
+      try {
+        Terminal = (await Private.ensureWidget()).Terminal;
+      } catch (err) {
+        Private.showErrorMessage(err);
+        return;
+      }
+
       const name = args['name'] as string;
       const cwd = args['cwd'] as string;
-      const localPath = cwd
-        ? serviceManager.contents.localPath(cwd)
-        : undefined;
 
       let session;
       if (name) {
@@ -367,24 +373,21 @@
         } else {
           // we are restoring a terminal widget but the corresponding terminal was closed
           // let's start a new terminal with the original name
-          session = await serviceManager.terminals.startNew({
-            name,
-            cwd: localPath
-          });
+          session = await serviceManager.terminals.startNew({ name, cwd });
         }
       } else {
         // we are creating a new terminal widget with a new terminal
         // let the server choose the terminal name
-        session = await serviceManager.terminals.startNew({ cwd: localPath });
-      }
-
-      const term = new XTerm(session, options, translator);
+        session = await serviceManager.terminals.startNew({ cwd });
+      }
+
+      const term = new Terminal(session, options, translator);
 
       term.title.icon = terminalIcon;
       term.title.label = '...';
 
-      const main = new MainAreaWidget({ content: term, reveal: term.ready });
-      app.shell.add(main, 'main', { type: 'Terminal' });
+      const main = new MainAreaWidget({ content: term });
+      app.shell.add(main);
       void tracker.add(main);
       app.shell.activateById(main.id);
       return main;
@@ -392,7 +395,6 @@
   });
 
   commands.addCommand(CommandIDs.open, {
-    label: trans.__('Open a terminal by its `name`.'),
     execute: args => {
       const name = args['name'] as string;
       // Check for a running terminal with the given name.
@@ -445,7 +447,7 @@
         return;
       }
 
-      const text = widget.getSelection();
+      const text = widget.getSelection!();
 
       if (text) {
         Clipboard.copyToSystem(text);
@@ -462,8 +464,12 @@
         return false;
       }
 
+      if (!widget.hasSelection) {
+        return false;
+      }
+
       // Enable command if there is a text selection in the terminal
-      return widget.hasSelection();
+      return widget.hasSelection!();
     },
     icon: copyIcon.bindprops({ stylesheet: 'menuItem' }),
     label: trans.__('Copy')
@@ -486,26 +492,24 @@
 
       if (clipboardData) {
         // Paste data to the terminal
-        widget.paste(clipboardData);
+        widget.paste!(clipboardData);
       }
     },
-    isEnabled: () => Boolean(isEnabled() && tracker.currentWidget?.content),
+    isEnabled: () => {
+      const widget = tracker.currentWidget?.content;
+
+      if (!widget) {
+        return false;
+      }
+
+      if (!widget.paste) {
+        return false;
+      }
+
+      return isEnabled();
+    },
     icon: pasteIcon.bindprops({ stylesheet: 'menuItem' }),
     label: trans.__('Paste')
-  });
-
-  commands.addCommand(CommandIDs.shutdown, {
-    label: trans.__('Shutdown Terminal'),
-    execute: () => {
-      const current = tracker.currentWidget;
-      if (!current) {
-        return;
-      }
-
-      // The widget is automatically disposed upon session shutdown.
-      return current.content.session.shutdown();
-    },
-    isEnabled
   });
 
   commands.addCommand(CommandIDs.increaseFont, {
@@ -544,9 +548,6 @@
 
   commands.addCommand(CommandIDs.setTheme, {
     label: args => {
-      if (args.theme === undefined) {
-        return trans.__('Set terminal theme to the provided `theme`.');
-      }
       const theme = args['theme'] as string;
       const displayName =
         theme in themeDisplayedName
@@ -572,25 +573,30 @@
       }
     }
   });
-
-  // All commands with isEnabled defined directly or in a semantic commands
-  const commandIds = [
-    CommandIDs.refresh,
-    CommandIDs.copy,
-    CommandIDs.paste,
-    CommandIDs.shutdown
-  ];
-  const notify = () => {
-    commandIds.forEach(id => commands.notifyCommandChanged(id));
-  };
-  tracker.currentChanged.connect(notify);
-  app.shell.currentChanged?.connect(notify);
 }
 
 /**
  * A namespace for private data.
  */
 namespace Private {
+  /**
+   * A Promise for the initial load of the terminal widget.
+   */
+  export let widgetReady: Promise<typeof WidgetModuleType>;
+
+  /**
+   * Lazy-load the widget (and xterm library and addons)
+   */
+  export function ensureWidget(): Promise<typeof WidgetModuleType> {
+    if (widgetReady) {
+      return widgetReady;
+    }
+
+    widgetReady = import('@jupyterlab/terminal/lib/widget');
+
+    return widgetReady;
+  }
+
   /**
    *  Utility function for consistent error reporting
    */