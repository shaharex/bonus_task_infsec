--- packages\services\src\event\index.ts (old)
+++ packages\services\src\event\index.ts (new)
@@ -1,11 +1,11 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
-import { URLExt } from '@jupyterlab/coreutils';
-import { JSONObject, ReadonlyJSONObject } from '@lumino/coreutils';
+import { PageConfig, URLExt } from '@jupyterlab/coreutils';
+import { PromiseDelegate } from '@lumino/coreutils';
 import { IDisposable } from '@lumino/disposable';
 import { Poll } from '@lumino/polling';
-import { IStream, Signal, Stream } from '@lumino/signaling';
+import { ISignal, Signal } from '@lumino/signaling';
 import { ServerConnection } from '../serverconnection';
 
 /**
@@ -16,7 +16,7 @@
 /**
  * The events API service manager.
  */
-export class EventManager implements Event.IManager {
+export class EventManager implements IDisposable {
   /**
    * Create a new event manager.
    */
@@ -24,12 +24,15 @@
     this.serverSettings =
       options.serverSettings ?? ServerConnection.makeSettings();
 
-    // If subscription fails, the poll attempts to reconnect and backs off.
     this._poll = new Poll({ factory: () => this._subscribe() });
-    this._stream = new Stream(this);
-
-    // Subscribe to the events socket.
-    void this._poll.start();
+    this._stream = new Private.Stream(this);
+
+    // TODO: Remove this logic in JupyterLab 4
+    if (this._isDisabled) {
+      this._stream.stop();
+    } else {
+      void this._poll.start();
+    }
   }
 
   /**
@@ -41,7 +44,7 @@
    * Whether the event manager is disposed.
    */
   get isDisposed(): boolean {
-    return this._poll.isDisposed;
+    return this._isDisposed;
   }
 
   /**
@@ -58,6 +61,7 @@
     if (this.isDisposed) {
       return;
     }
+    this._isDisposed = true;
 
     // Clean up poll.
     this._poll.dispose();
@@ -83,9 +87,11 @@
    */
   async emit(event: Event.Request): Promise<void> {
     const { serverSettings } = this;
-    const { baseUrl } = serverSettings;
+    const { baseUrl, token } = serverSettings;
     const { makeRequest, ResponseError } = ServerConnection;
-    const url = URLExt.join(baseUrl, SERVICE_EVENTS_URL);
+    const url =
+      URLExt.join(baseUrl, SERVICE_EVENTS_URL) +
+      (token ? `?token=${token}` : '');
     const init = { body: JSON.stringify(event), method: 'POST' };
     const response = await makeRequest(url, init, serverSettings);
 
@@ -99,26 +105,30 @@
    */
   private _subscribe(): Promise<void> {
     return new Promise<void>((_, reject) => {
-      if (this.isDisposed) {
+      if (this.isDisposed || this._isDisabled) {
         return;
       }
 
-      const { appendToken, token, WebSocket, wsUrl } = this.serverSettings;
-      let url = URLExt.join(wsUrl, SERVICE_EVENTS_URL, 'subscribe');
-      if (appendToken && token !== '') {
-        url += `?token=${encodeURIComponent(token)}`;
-      }
+      const { token, WebSocket, wsUrl } = this.serverSettings;
+      const url =
+        URLExt.join(wsUrl, SERVICE_EVENTS_URL, 'subscribe') +
+        (token ? `?token=${encodeURIComponent(token)}` : '');
       const socket = (this._socket = new WebSocket(url));
       const stream = this._stream;
 
+      // Cause the poll to tick a rejection and back off if the socket closes.
       socket.onclose = () => reject(new Error('EventManager socket closed'));
       socket.onmessage = msg => msg.data && stream.emit(JSON.parse(msg.data));
     });
   }
 
+  // TODO: Remove this check for the `jupyter_server` version.
+  // It is only necessary in JupyterLab < 4.
+  private _isDisabled = 2 > PageConfig.getNotebookVersion()[0];
+  private _isDisposed = false;
   private _poll: Poll;
   private _socket: WebSocket | null = null;
-  private _stream: Stream<this, Event.Emission>;
+  private _stream: Private.Stream<this, Event.Emission>;
 }
 
 /**
@@ -143,7 +153,8 @@
   /**
    * The event emission type.
    */
-  export type Emission = ReadonlyJSONObject & {
+  export type Emission = {
+    [key: string]: any;
     schema_id: string;
   };
 
@@ -151,7 +162,7 @@
    * The event request type.
    */
   export type Request = {
-    data: JSONObject;
+    data: { [key: string]: any };
     schema_id: string;
     version: string;
   };
@@ -164,18 +175,63 @@
   /**
    * The interface for the event bus front-end.
    */
-  export interface IManager extends IDisposable {
-    /**
-     * The server settings used to make API requests.
-     */
-    readonly serverSettings: ServerConnection.ISettings;
-    /**
-     * An event stream that emits and yields each new event.
-     */
-    readonly stream: Event.Stream;
-    /**
-     * Post an event request to be emitted by the event bus.
-     */
-    emit(event: Event.Request): Promise<void>;
-  }
-}
+  export interface IManager extends EventManager {}
+
+  /**
+   * An object that is both a signal and an async iterable.
+   */
+  export interface IStream<T, U> extends ISignal<T, U>, AsyncIterable<U> {}
+}
+
+/**
+ * A namespace for private module data.
+ */
+namespace Private {
+  /**
+   * A pending promise in a promise chain underlying a stream.
+   */
+  export type Pending<U> = PromiseDelegate<{ args: U; next: Pending<U> }>;
+
+  /**
+   * A stream with the characteristics of a signal and an async iterable.
+   */
+  export class Stream<T, U> extends Signal<T, U> {
+    /**
+     * Return an async iterator that yields every emission.
+     */
+    async *[Symbol.asyncIterator](): AsyncIterableIterator<U> {
+      let pending = this._pending;
+      while (true) {
+        try {
+          const { args, next } = await pending.promise;
+          pending = next;
+          yield args;
+        } catch (_) {
+          return; // Any promise rejection stops the iterator.
+        }
+      }
+    }
+
+    /**
+     * Emit the signal, invoke the connected slots, and yield the emission.
+     *
+     * @param args - The args to pass to the connected slots.
+     */
+    emit(args: U): void {
+      const pending = this._pending;
+      this._pending = new PromiseDelegate();
+      pending.resolve({ args, next: this._pending });
+      super.emit(args);
+    }
+
+    /**
+     * Stop the stream's async iteration.
+     */
+    stop(): void {
+      this._pending.promise.catch(() => undefined);
+      this._pending.reject('stop');
+    }
+
+    private _pending: Private.Pending<U> = new PromiseDelegate();
+  }
+}