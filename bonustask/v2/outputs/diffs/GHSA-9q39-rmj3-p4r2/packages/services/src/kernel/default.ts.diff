--- packages\services\src\kernel\default.ts (old)
+++ packages\services\src\kernel\default.ts (new)
@@ -20,6 +20,8 @@
   KernelFutureHandler,
   KernelShellFutureHandler
 } from './future';
+
+import * as serialize from './serialize';
 
 import * as validate from './validate';
 import { KernelSpec, KernelSpecAPI } from '../kernelspec';
@@ -405,9 +407,7 @@
       KernelMessage.isInfoRequestMsg(msg)
     ) {
       if (this.connectionStatus === 'connected') {
-        this._ws!.send(
-          this.serverSettings.serializer.serialize(msg, this._ws!.protocol)
-        );
+        this._ws!.send(serialize.serialize(msg));
         return;
       } else {
         throw new Error('Could not send message: status is not connected');
@@ -425,9 +425,7 @@
       this.connectionStatus === 'connected' &&
       this._kernelSession !== RESTARTING_KERNEL_SESSION
     ) {
-      this._ws!.send(
-        this.serverSettings.serializer.serialize(msg, this._ws!.protocol)
-      );
+      this._ws!.send(serialize.serialize(msg));
     } else if (queue) {
       this._pendingMessages.push(msg);
     } else {
@@ -439,7 +437,7 @@
    * Interrupt a kernel.
    *
    * #### Notes
-   * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/kernels).
+   * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/kernels).
    *
    * The promise is fulfilled on a valid response and rejected otherwise.
    *
@@ -460,7 +458,7 @@
    * Request a kernel restart.
    *
    * #### Notes
-   * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/kernels)
+   * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/kernels)
    * and validates the response model.
    *
    * Any existing Future or Comm objects are cleared once the kernel has
@@ -528,7 +526,7 @@
    * Shutdown a kernel.
    *
    * #### Notes
-   * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/kernels).
+   * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/kernels).
    *
    * The promise is fulfilled on a valid response and rejected otherwise.
    *
@@ -631,10 +629,9 @@
       session: this._clientId,
       content
     });
-    return Private.handleShellMessage(
-      this,
-      msg
-    ) as Promise<KernelMessage.ICompleteReplyMsg>;
+    return Private.handleShellMessage(this, msg) as Promise<
+      KernelMessage.ICompleteReplyMsg
+    >;
   }
 
   /**
@@ -656,10 +653,9 @@
       session: this._clientId,
       content: content
     });
-    return Private.handleShellMessage(
-      this,
-      msg
-    ) as Promise<KernelMessage.IInspectReplyMsg>;
+    return Private.handleShellMessage(this, msg) as Promise<
+      KernelMessage.IInspectReplyMsg
+    >;
   }
 
   /**
@@ -681,10 +677,9 @@
       session: this._clientId,
       content
     });
-    return Private.handleShellMessage(
-      this,
-      msg
-    ) as Promise<KernelMessage.IHistoryReplyMsg>;
+    return Private.handleShellMessage(this, msg) as Promise<
+      KernelMessage.IHistoryReplyMsg
+    >;
   }
 
   /**
@@ -788,10 +783,9 @@
       session: this._clientId,
       content
     });
-    return Private.handleShellMessage(
-      this,
-      msg
-    ) as Promise<KernelMessage.IIsCompleteReplyMsg>;
+    return Private.handleShellMessage(this, msg) as Promise<
+      KernelMessage.IIsCompleteReplyMsg
+    >;
   }
 
   /**
@@ -811,10 +805,9 @@
       session: this._clientId,
       content
     });
-    return Private.handleShellMessage(
-      this,
-      msg
-    ) as Promise<KernelMessage.ICommInfoReplyMsg>;
+    return Private.handleShellMessage(this, msg) as Promise<
+      KernelMessage.ICommInfoReplyMsg
+    >;
   }
 
   /**
@@ -825,7 +818,7 @@
    */
   sendInputReply(
     content: KernelMessage.IInputReplyMsg['content'],
-    parent_header: KernelMessage.IInputReplyMsg['parent_header']
+    parent_header?: KernelMessage.IInputReplyMsg['parent_header']
   ): void {
     const msg = KernelMessage.createMessage({
       msgType: 'input_reply',
@@ -834,7 +827,9 @@
       session: this._clientId,
       content
     });
-    msg.parent_header = parent_header;
+    if (parent_header) {
+      msg.parent_header = parent_header;
+    }
 
     this._sendMessage(msg);
     this._anyMessage.emit({ msg, direction: 'send' });
@@ -1002,12 +997,12 @@
       // We've seen it before, update existing outputs with same display_id
       // by handling display_data as update_display_data.
       const updateMsg: KernelMessage.IMessage = {
-        header: JSONExt.deepCopy(
-          msg.header as unknown as JSONObject
-        ) as unknown as KernelMessage.IHeader,
-        parent_header: JSONExt.deepCopy(
-          msg.parent_header as unknown as JSONObject
-        ) as unknown as KernelMessage.IHeader,
+        header: (JSONExt.deepCopy(
+          (msg.header as unknown) as JSONObject
+        ) as unknown) as KernelMessage.IHeader,
+        parent_header: (JSONExt.deepCopy(
+          (msg.parent_header as unknown) as JSONObject
+        ) as unknown) as KernelMessage.IHeader,
         metadata: JSONExt.deepCopy(msg.metadata),
         content: JSONExt.deepCopy(msg.content as JSONObject),
         channel: msg.channel,
@@ -1235,7 +1230,7 @@
   /**
    * Create the kernel websocket connection and add socket status handlers.
    */
-  private _createSocket = (useProtocols = true) => {
+  private _createSocket = () => {
     this._errorIfDisposed();
 
     // Make sure the socket is clear
@@ -1266,13 +1261,7 @@
       url = url + `&token=${encodeURIComponent(token)}`;
     }
 
-    // Try opening the websocket with our list of subprotocols.
-    // If the server doesn't handle subprotocols,
-    // the accepted protocol will be ''.
-    // But we cannot send '' as a subprotocol, so if connection fails,
-    // reconnect without subprotocols.
-    const supportedProtocols = useProtocols ? this._supportedProtocols : [];
-    this._ws = new settings.WebSocket(url, supportedProtocols);
+    this._ws = new settings.WebSocket(url);
 
     // Ensure incoming binary messages are not Blobs
     this._ws.binaryType = 'arraybuffer';
@@ -1516,14 +1505,7 @@
           timeout / 1000
         )} seconds.`
       );
-      // Try reconnection with subprotocols if the server had supported them.
-      // Otherwise, try reconnection without subprotocols.
-      const useProtocols = this._selectedProtocol !== '' ? true : false;
-      this._reconnectTimeout = setTimeout(
-        this._createSocket,
-        timeout,
-        useProtocols
-      );
+      this._reconnectTimeout = setTimeout(this._createSocket, timeout);
       this._reconnectAttempt += 1;
     } else {
       this._updateConnectionStatus('disconnected');
@@ -1548,19 +1530,6 @@
    * Handle a websocket open event.
    */
   private _onWSOpen = (evt: Event) => {
-    if (
-      this._ws!.protocol !== '' &&
-      !this._supportedProtocols.includes(this._ws!.protocol)
-    ) {
-      console.log(
-        'Server selected unknown kernel wire protocol:',
-        this._ws!.protocol
-      );
-      this._updateStatus('dead');
-      throw new Error(`Unknown kernel wire protocol:  ${this._ws!.protocol}`);
-    }
-    // Remember the kernel wire protocol selected by the server.
-    this._selectedProtocol = this._ws!.protocol;
     this._ws!.onclose = this._onWSClose;
     this._ws!.onerror = this._onWSClose;
     this._updateConnectionStatus('connected');
@@ -1573,10 +1542,7 @@
     // Notify immediately if there is an error with the message.
     let msg: KernelMessage.IMessage;
     try {
-      msg = this.serverSettings.serializer.deserialize(
-        evt.data,
-        this._ws!.protocol
-      );
+      msg = serialize.deserialize(evt.data);
       validate.validateMessage(msg);
     } catch (error) {
       error.message = `Kernel message validation error: ${error.message}`;
@@ -1640,10 +1606,6 @@
   private _reconnectLimit = 7;
   private _reconnectAttempt = 0;
   private _reconnectTimeout: any = null;
-  private _supportedProtocols: string[] = Object.values(
-    KernelMessage.supportedKernelWebSocketProtocols
-  );
-  private _selectedProtocol: string = '';
 
   private _futures = new Map<
     string,
@@ -1705,10 +1667,7 @@
    */
   export async function handleShellMessage<
     T extends KernelMessage.ShellMessageType
-  >(
-    kernel: Kernel.IKernelConnection,
-    msg: KernelMessage.IShellMessage<T>
-  ): Promise<KernelMessage.IShellMessage<KernelMessage.ShellMessageType>> {
+  >(kernel: Kernel.IKernelConnection, msg: KernelMessage.IShellMessage<T>) {
     const future = kernel.sendShellMessage(msg, true);
     return future.done;
   }
@@ -1767,7 +1726,7 @@
    * that, but doing so would cause your random numbers to follow a non-uniform
    * distribution, which may not be acceptable for your needs.
    */
-  export function getRandomIntInclusive(min: number, max: number): number {
+  export function getRandomIntInclusive(min: number, max: number) {
     min = Math.ceil(min);
     max = Math.floor(max);
     return Math.floor(Math.random() * (max - min + 1)) + min;