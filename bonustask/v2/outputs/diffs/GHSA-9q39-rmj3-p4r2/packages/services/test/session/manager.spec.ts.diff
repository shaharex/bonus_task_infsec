--- packages\services\test\session\manager.spec.ts (old)
+++ packages\services\test\session\manager.spec.ts (new)
@@ -1,7 +1,12 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
-import { JupyterServer, testEmission } from '@jupyterlab/testing';
+import {
+  flakyIt as it,
+  JupyterServer,
+  testEmission
+} from '@jupyterlab/testutils';
+import { toArray } from '@lumino/algorithm';
 import { UUID } from '@lumino/coreutils';
 import {
   KernelManager,
@@ -25,39 +30,43 @@
   return session;
 }
 
+const server = new JupyterServer();
+
+beforeAll(async () => {
+  await server.start();
+});
+
+afterAll(async () => {
+  await server.shutdown();
+});
+
 describe('session/manager', () => {
-  let server: JupyterServer;
-  jest.setTimeout(20000);
-  jest.retryTimes(3);
-
-  beforeAll(async () => {
-    server = new JupyterServer();
-    await server.start();
-  }, 30000);
+  let kernelManager: KernelManager;
+  let manager: SessionManager;
+  let session: Session.ISessionConnection;
+
+  beforeAll(() => {
+    jest.setTimeout(20000);
+    kernelManager = new KernelManager({ standby: 'never' });
+  });
+
+  beforeEach(async () => {
+    manager = new SessionManager({ kernelManager, standby: 'never' });
+    await manager.ready;
+    session = await startNew(manager);
+    await session.kernel!.info;
+  });
+
+  afterEach(() => {
+    manager.dispose();
+  });
 
   afterAll(async () => {
     const sessions = await SessionAPI.listRunning();
     await Promise.all(sessions.map(s => SessionAPI.shutdownSession(s.id)));
-    await server.shutdown();
   });
 
   describe('SessionManager', () => {
-    let kernelManager: KernelManager;
-    let manager: SessionManager;
-    let session: Session.ISessionConnection;
-
-    beforeEach(async () => {
-      kernelManager = new KernelManager({ standby: 'never' });
-      manager = new SessionManager({ kernelManager, standby: 'never' });
-      await manager.ready;
-      session = await startNew(manager);
-      await session.kernel!.info;
-    });
-
-    afterEach(() => {
-      manager.dispose();
-    });
-
     describe('#constructor()', () => {
       it('should create a new session manager', () => {
         expect(manager instanceof SessionManager).toBe(true);
@@ -87,14 +96,14 @@
 
     describe('#ready', () => {
       it('should resolve when the manager is ready', async () => {
-        await expect(manager.ready).resolves.not.toThrow();
+        await manager.ready;
       });
     });
 
     describe('#running()', () => {
       it('should get the running sessions', async () => {
         await manager.refreshRunning();
-        const running = Array.from(manager.running());
+        const running = toArray(manager.running());
         expect(running.length).toBeGreaterThan(0);
       });
     });
@@ -104,7 +113,7 @@
         const promise = testEmission(manager.runningChanged, {
           test: (sender, args) => {
             expect(sender).toBe(manager);
-            expect(Array.from(args).length).toBeGreaterThan(0);
+            expect(toArray(args).length).toBeGreaterThan(0);
           }
         });
         await startNew(manager);
@@ -148,7 +157,7 @@
       // future is prematurely disposed.
       it('should refresh the list of session ids', async () => {
         await manager.refreshRunning();
-        const running = Array.from(manager.running());
+        const running = toArray(manager.running());
         expect(running.length).toBeGreaterThan(0);
       });
     });
@@ -221,95 +230,7 @@
         const session1 = manager.connectTo({ model: session0.model });
         const emission = testEmission(session1.disposed);
         await session0.shutdown();
-        await expect(emission).resolves.not.toThrow();
-      });
-    });
-  });
-
-  describe('NoopManager', () => {
-    let manager: SessionManager.NoopManager;
-    let kernelManager: KernelManager.NoopManager;
-
-    beforeEach(async () => {
-      kernelManager = new KernelManager.NoopManager({ standby: 'never' });
-      await kernelManager.parentReady;
-      manager = new SessionManager.NoopManager({
-        kernelManager,
-        standby: 'never'
-      });
-      await manager.parentReady;
-    });
-
-    afterEach(() => {
-      manager.dispose();
-    });
-
-    describe('#constructor()', () => {
-      it('should take the options as an argument', async () => {
-        manager.dispose();
-        manager = new SessionManager.NoopManager({
-          kernelManager,
-          standby: 'never'
-        });
-        await manager.parentReady;
-        expect(manager instanceof SessionManager.NoopManager).toBe(true);
-      });
-    });
-
-    describe('#serverSettings', () => {
-      it('should get the server settings', async () => {
-        manager.dispose();
-        const serverSettings = ServerConnection.makeSettings();
-        const standby = 'never';
-        const token = serverSettings.token;
-        manager = new SessionManager.NoopManager({
-          kernelManager,
-          serverSettings,
-          standby
-        });
-        await manager.parentReady;
-        expect(manager.serverSettings.token).toBe(token);
-      });
-    });
-
-    describe('#running()', () => {
-      it('should get the running sessions', async () => {
-        await manager.refreshRunning();
-        expect(Array.from(manager.running()).length).toEqual(0);
-      });
-    });
-
-    describe('#refreshRunning()', () => {
-      it('should update the running kernels', async () => {
-        await manager.refreshRunning();
-        expect(Array.from(manager.running()).length).toEqual(0);
-      });
-    });
-
-    describe('#startNew()', () => {
-      it('should throw an error', () => {
-        return expect(startNew(manager)).rejects.toThrow();
-      });
-    });
-
-    describe('#connectTo()', () => {
-      it('should throw an error', () => {
-        const model = {
-          id: UUID.uuid4(),
-          path: UUID.uuid4(),
-          name: UUID.uuid4(),
-          type: 'MYTEST',
-          kernel: { name: 'foo', id: UUID.uuid4() }
-        };
-        return expect(() => {
-          manager.connectTo({ model });
-        }).toThrow();
-      });
-    });
-
-    describe('shutdown()', () => {
-      it('should throw an error', () => {
-        return expect(manager.shutdown(UUID.uuid4())).rejects.toThrow();
+        await emission;
       });
     });
   });