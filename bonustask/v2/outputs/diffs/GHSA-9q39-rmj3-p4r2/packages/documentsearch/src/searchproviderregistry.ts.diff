--- packages\documentsearch\src\searchproviderregistry.ts (old)
+++ packages\documentsearch\src\searchproviderregistry.ts (new)
@@ -1,36 +1,22 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
-import { ITranslator, nullTranslator } from '@jupyterlab/translation';
 import { DisposableDelegate, IDisposable } from '@lumino/disposable';
 import { ISignal, Signal } from '@lumino/signaling';
 import { Widget } from '@lumino/widgets';
-import {
-  ISearchProvider,
-  ISearchProviderFactory,
-  ISearchProviderRegistry
-} from './tokens';
+import { ISearchProvider, ISearchProviderConstructor } from './interfaces';
+import { ISearchProviderRegistry } from './tokens';
 
-/**
- * Search provider registry
- */
 export class SearchProviderRegistry implements ISearchProviderRegistry {
-  /**
-   * Constructor
-   *
-   * @param translator Application translator object
-   */
-  constructor(protected translator: ITranslator = nullTranslator) {}
-
   /**
    * Add a provider to the registry.
    *
    * @param key - The provider key.
    * @returns A disposable delegate that, when disposed, deregisters the given search provider
    */
-  add<T extends Widget = Widget>(
+  register<T extends Widget = Widget>(
     key: string,
-    provider: ISearchProviderFactory<T>
+    provider: ISearchProviderConstructor<T>
   ): IDisposable {
     this._providerMap.set(key, provider);
     this._changed.emit();
@@ -46,30 +32,10 @@
    * @param widget - The widget to search over.
    * @returns the search provider, or undefined if none exists.
    */
-  getProvider(widget: Widget): ISearchProvider | undefined {
-    // iterate through all providers and ask each one if it can search on the
-    // widget.
-    for (const P of this._providerMap.values()) {
-      if (P.isApplicable(widget)) {
-        return P.createNew(widget, this.translator);
-      }
-    }
-    return undefined;
-  }
-
-  /**
-   * Whether the registry as a matching provider for the widget.
-   *
-   * @param widget - The widget to search over.
-   * @returns Provider existence
-   */
-  hasProvider(widget: Widget): boolean {
-    for (const P of this._providerMap.values()) {
-      if (P.isApplicable(widget)) {
-        return true;
-      }
-    }
-    return false;
+  getProviderForWidget<T extends Widget = Widget>(
+    widget: T
+  ): ISearchProvider<T> | undefined {
+    return this._findMatchingProvider(this._providerMap, widget);
   }
 
   /**
@@ -80,6 +46,27 @@
     return this._changed;
   }
 
+  private _findMatchingProvider<T extends Widget = Widget>(
+    providerMap: Private.ProviderMap,
+    widget: T
+  ): ISearchProvider<T> | undefined {
+    // iterate through all providers and ask each one if it can search on the
+    // widget.
+    for (const P of providerMap.values()) {
+      if (P.canSearchOn(widget)) {
+        return new P();
+      }
+    }
+    return undefined;
+  }
+
   private _changed = new Signal<this, void>(this);
-  private _providerMap = new Map<string, ISearchProviderFactory<Widget>>();
+  private _providerMap: Private.ProviderMap = new Map<
+    string,
+    ISearchProviderConstructor<any>
+  >();
 }
+
+namespace Private {
+  export type ProviderMap = Map<string, ISearchProviderConstructor<any>>;
+}