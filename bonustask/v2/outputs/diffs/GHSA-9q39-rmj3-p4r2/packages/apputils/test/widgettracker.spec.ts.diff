--- packages\apputils\test\widgettracker.spec.ts (old)
+++ packages\apputils\test\widgettracker.spec.ts (new)
@@ -2,7 +2,7 @@
 // Distributed under the terms of the Modified BSD License.
 
 import { WidgetTracker } from '@jupyterlab/apputils';
-import { signalToPromise, testEmission } from '@jupyterlab/testing';
+import { signalToPromise, testEmission } from '@jupyterlab/testutils';
 import { Panel, Widget } from '@lumino/widgets';
 import { simulate } from 'simulate-event';
 
@@ -50,33 +50,28 @@
     });
 
     describe('#currentChanged', () => {
-      let widget: Widget;
-      let widget2: Widget;
-
-      beforeEach(() => {
-        widget = createWidget();
-        widget2 = createWidget();
-      });
-
-      afterEach(() => {
-        widget.dispose();
-        widget2.dispose();
-      });
-
       it('should emit for the first added widget', async () => {
+        const widget = createWidget();
         const promise = signalToPromise(tracker.currentChanged);
         void tracker.add(widget);
-        await expect(promise).resolves.not.toThrow();
+        await promise;
+        widget.dispose();
       });
 
       it('should emit when a widget is added and there is another widget that does not have focus', async () => {
+        const widget = createWidget();
+        const widget2 = createWidget();
         await tracker.add(widget);
         const promise = signalToPromise(tracker.currentChanged);
         await tracker.add(widget2);
-        await expect(promise).resolves.not.toThrow();
+        await promise;
+        widget.dispose();
+        widget2.dispose();
       });
 
       it('should not emit when a widget is added and there is another widget that has focus', async () => {
+        const widget = createWidget();
+        const widget2 = createWidget();
         Widget.attach(widget, document.body);
         focus(widget);
         await tracker.add(widget);
@@ -86,9 +81,13 @@
         });
         await tracker.add(widget2);
         expect(called).toBe(false);
+        widget.dispose();
+        widget2.dispose();
       });
 
       it('should emit when the focus changes', async () => {
+        const widget = createWidget();
+        const widget2 = createWidget();
         Widget.attach(widget, document.body);
         Widget.attach(widget2, document.body);
         focus(widget);
@@ -96,25 +95,15 @@
         await tracker.add(widget2);
         const promise = signalToPromise(tracker.currentChanged);
         focus(widget2);
-        await expect(promise).resolves.not.toThrow();
+        await promise;
+        widget.dispose();
+        widget2.dispose();
       });
     });
 
     describe('#widgetAdded', () => {
-      let widget: Widget;
-      let widget2: Widget;
-
-      beforeEach(() => {
-        widget = createWidget();
-        widget2 = createWidget();
-      });
-
-      afterEach(() => {
-        widget.dispose();
-        widget2.dispose();
-      });
-
       it('should emit when a widget has been added', async () => {
+        const widget = createWidget();
         const promise = signalToPromise(tracker.widgetAdded);
 
         await tracker.add(widget);
@@ -123,9 +112,12 @@
 
         expect(sender).toBe(tracker);
         expect(args).toBe(widget);
+        widget.dispose();
       });
 
       it('should not emit when a widget has been injected', async () => {
+        const one = createWidget();
+        const two = createWidget();
         let total = 0;
         const promise = testEmission(tracker.currentChanged, {
           find: () => {
@@ -136,12 +128,14 @@
         tracker.widgetAdded.connect(() => {
           total++;
         });
-        void tracker.add(widget);
-        void tracker.inject(widget2);
-        Widget.attach(widget2, document.body);
-        focus(widget2);
-        Widget.detach(widget2);
-        await expect(promise).resolves.not.toThrow();
+        void tracker.add(one);
+        void tracker.inject(two);
+        Widget.attach(two, document.body);
+        focus(two);
+        Widget.detach(two);
+        await promise;
+        one.dispose();
+        two.dispose();
       });
     });
 