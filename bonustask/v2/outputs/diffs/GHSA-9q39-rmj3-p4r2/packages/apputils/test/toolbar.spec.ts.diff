--- packages\apputils\test\toolbar.spec.ts (old)
+++ packages\apputils\test\toolbar.spec.ts (new)
@@ -2,33 +2,393 @@
 // Distributed under the terms of the Modified BSD License.
 
 import {
+  CommandToolbarButton,
   createToolbarFactory,
+  ReactiveToolbar,
   SessionContext,
-  SessionContextDialogs,
   Toolbar,
+  ToolbarButton,
   ToolbarRegistry,
   ToolbarWidgetRegistry
 } from '@jupyterlab/apputils';
 import { ISettingRegistry, SettingRegistry } from '@jupyterlab/settingregistry';
 import { IDataConnector } from '@jupyterlab/statedb';
-import { framePromise, JupyterServer } from '@jupyterlab/testing';
+import {
+  createSessionContext,
+  framePromise,
+  JupyterServer
+} from '@jupyterlab/testutils';
 import { ITranslator } from '@jupyterlab/translation';
-import { JSONExt, PromiseDelegate } from '@lumino/coreutils';
-import { Widget } from '@lumino/widgets';
-import { createSessionContext } from '@jupyterlab/apputils/lib/testutils';
+import {
+  blankIcon,
+  bugDotIcon,
+  bugIcon,
+  jupyterIcon
+} from '@jupyterlab/ui-components';
+import { toArray } from '@lumino/algorithm';
+import { CommandRegistry } from '@lumino/commands';
+import {
+  JSONExt,
+  PromiseDelegate,
+  ReadonlyPartialJSONObject
+} from '@lumino/coreutils';
+import { PanelLayout, Widget } from '@lumino/widgets';
+import { simulate } from 'simulate-event';
 
 const server = new JupyterServer();
 
 beforeAll(async () => {
   await server.start();
-}, 30000);
+});
 
 afterAll(async () => {
   await server.shutdown();
 });
 
 describe('@jupyterlab/apputils', () => {
+  describe('CommandToolbarButton', () => {
+    let commands: CommandRegistry;
+    const id = 'test-command';
+    const options: CommandRegistry.ICommandOptions = {
+      execute: jest.fn()
+    };
+
+    beforeEach(() => {
+      commands = new CommandRegistry();
+    });
+
+    it('should render a command', async () => {
+      commands.addCommand(id, options);
+      const button = new CommandToolbarButton({
+        commands,
+        id
+      });
+
+      Widget.attach(button, document.body);
+      await framePromise();
+
+      expect(button.hasClass('jp-CommandToolbarButton')).toBe(true);
+      simulate(button.node.firstElementChild!, 'mousedown');
+      expect(options.execute).toBeCalledTimes(1);
+    });
+
+    it('should render the label command', async () => {
+      const label = 'This is a test label';
+      commands.addCommand(id, { ...options, label });
+      const button = new CommandToolbarButton({
+        commands,
+        id
+      });
+
+      Widget.attach(button, document.body);
+      await framePromise();
+
+      expect(button.node.textContent).toMatch(label);
+    });
+
+    it('should render the customized label command', async () => {
+      const label = 'This is a test label';
+      const buttonLabel = 'This is the button label';
+      commands.addCommand(id, { ...options, label });
+      const button = new CommandToolbarButton({
+        commands,
+        id,
+        label: buttonLabel
+      });
+
+      Widget.attach(button, document.body);
+      await framePromise();
+
+      expect(button.node.textContent).toMatch(buttonLabel);
+      expect(button.node.textContent).not.toMatch(label);
+    });
+
+    it('should render the icon command', async () => {
+      const icon = jupyterIcon;
+      commands.addCommand(id, { ...options, icon });
+      const button = new CommandToolbarButton({
+        commands,
+        id
+      });
+
+      Widget.attach(button, document.body);
+      await framePromise();
+
+      expect(button.node.getElementsByTagName('svg')[0].dataset.icon).toMatch(
+        icon.name
+      );
+    });
+
+    it('should render the customized icon command', async () => {
+      const icon = jupyterIcon;
+      const buttonIcon = blankIcon;
+      commands.addCommand(id, { ...options, icon });
+      const button = new CommandToolbarButton({
+        commands,
+        id,
+        icon: buttonIcon
+      });
+
+      Widget.attach(button, document.body);
+      await framePromise();
+
+      const iconSVG = button.node.getElementsByTagName('svg')[0];
+      expect(iconSVG.dataset.icon).toMatch(buttonIcon.name);
+      expect(iconSVG.dataset.icon).not.toMatch(icon.name);
+    });
+  });
+
   describe('Toolbar', () => {
+    let widget: Toolbar<Widget>;
+
+    beforeEach(async () => {
+      jest.setTimeout(20000);
+      widget = new Toolbar();
+    });
+
+    afterEach(async () => {
+      widget.dispose();
+    });
+
+    describe('#constructor()', () => {
+      it('should construct a new toolbar widget', () => {
+        const widget = new Toolbar();
+        expect(widget).toBeInstanceOf(Toolbar);
+      });
+
+      it('should add the `jp-Toolbar` class', () => {
+        const widget = new Toolbar();
+        expect(widget.hasClass('jp-Toolbar')).toBe(true);
+      });
+    });
+
+    describe('#names()', () => {
+      it('should get an ordered list the toolbar item names', () => {
+        widget.addItem('foo', new Widget());
+        widget.addItem('bar', new Widget());
+        widget.addItem('baz', new Widget());
+        expect(toArray(widget.names())).toEqual(['foo', 'bar', 'baz']);
+      });
+    });
+
+    describe('#addItem()', () => {
+      it('should add an item to the toolbar', () => {
+        const item = new Widget();
+        expect(widget.addItem('test', item)).toBe(true);
+        expect(toArray(widget.names())).toContain('test');
+      });
+
+      it('should add the `jp-Toolbar-item` class to the widget', () => {
+        const item = new Widget();
+        widget.addItem('test', item);
+        expect(item.hasClass('jp-Toolbar-item')).toBe(true);
+      });
+
+      it('should return false if the name is already used', () => {
+        widget.addItem('test', new Widget());
+        expect(widget.addItem('test', new Widget())).toBe(false);
+      });
+    });
+
+    describe('#insertItem()', () => {
+      it('should insert the item into the toolbar', () => {
+        widget.addItem('a', new Widget());
+        widget.addItem('b', new Widget());
+        widget.insertItem(1, 'c', new Widget());
+        expect(toArray(widget.names())).toEqual(['a', 'c', 'b']);
+      });
+
+      it('should clamp the bounds', () => {
+        widget.addItem('a', new Widget());
+        widget.addItem('b', new Widget());
+        widget.insertItem(10, 'c', new Widget());
+        expect(toArray(widget.names())).toEqual(['a', 'b', 'c']);
+      });
+    });
+
+    describe('#insertAfter()', () => {
+      it('should insert an item into the toolbar after `c`', () => {
+        widget.addItem('a', new Widget());
+        widget.addItem('b', new Widget());
+        widget.insertItem(1, 'c', new Widget());
+        widget.insertAfter('c', 'd', new Widget());
+        expect(toArray(widget.names())).toEqual(['a', 'c', 'd', 'b']);
+      });
+
+      it('should return false if the target item does not exist', () => {
+        widget.addItem('a', new Widget());
+        widget.addItem('b', new Widget());
+        const value = widget.insertAfter('c', 'd', new Widget());
+        expect(value).toBe(false);
+      });
+    });
+
+    describe('#insertBefore()', () => {
+      it('should insert an item into the toolbar before `c`', () => {
+        widget.addItem('a', new Widget());
+        widget.addItem('b', new Widget());
+        widget.insertItem(1, 'c', new Widget());
+        widget.insertBefore('c', 'd', new Widget());
+        expect(toArray(widget.names())).toEqual(['a', 'd', 'c', 'b']);
+      });
+
+      it('should return false if the target item does not exist', () => {
+        widget.addItem('a', new Widget());
+        widget.addItem('b', new Widget());
+        const value = widget.insertBefore('c', 'd', new Widget());
+        expect(value).toBe(false);
+      });
+    });
+
+    describe('.createFromCommand', () => {
+      const commands = new CommandRegistry();
+      const testLogCommandId = 'test:toolbar-log';
+      const logArgs: ReadonlyPartialJSONObject[] = [];
+      let enabled = false;
+      let toggled = true;
+      let visible = false;
+      commands.addCommand(testLogCommandId, {
+        execute: args => {
+          logArgs.push(args);
+        },
+        label: 'Test log command label',
+        caption: 'Test log command caption',
+        usage: 'Test log command usage',
+        iconClass: 'test-icon-class',
+        className: 'test-log-class',
+        isEnabled: () => enabled,
+        isToggled: () => toggled,
+        isVisible: () => visible
+      });
+
+      async function render(button: CommandToolbarButton) {
+        button.update();
+        await framePromise();
+        expect(button.renderPromise).toBeDefined();
+        await button.renderPromise;
+      }
+
+      it('should create a button', () => {
+        const button = new CommandToolbarButton({
+          commands,
+          id: testLogCommandId
+        });
+        expect(button).toBeInstanceOf(CommandToolbarButton);
+        button.dispose();
+      });
+
+      it('should add main class', async () => {
+        const button = new CommandToolbarButton({
+          commands,
+          id: testLogCommandId
+        });
+        await render(button);
+        const buttonNode = button.node.firstChild as HTMLButtonElement;
+        expect(buttonNode.classList.contains('test-log-class')).toBe(true);
+        button.dispose();
+      });
+
+      it('should add an icon with icon class and label', async () => {
+        const button = new CommandToolbarButton({
+          commands,
+          id: testLogCommandId
+        });
+        await render(button);
+        const buttonNode = button.node.firstChild as HTMLButtonElement;
+        expect(buttonNode.title).toBe('Test log command caption');
+        const wrapperNode = buttonNode.firstChild as HTMLElement;
+        const iconNode = wrapperNode.firstChild as HTMLElement;
+        expect(iconNode.classList.contains('test-icon-class')).toBe(true);
+        button.dispose();
+      });
+
+      it('should apply state classes', async () => {
+        enabled = false;
+        toggled = true;
+        visible = false;
+        const button = new CommandToolbarButton({
+          commands,
+          id: testLogCommandId
+        });
+        await render(button);
+        const buttonNode = button.node.firstChild as HTMLButtonElement;
+        expect(buttonNode.disabled).toBe(true);
+        expect(buttonNode.classList.contains('lm-mod-toggled')).toBe(true);
+        expect(buttonNode.classList.contains('lm-mod-hidden')).toBe(true);
+        button.dispose();
+      });
+
+      it('should update state classes', async () => {
+        enabled = false;
+        toggled = true;
+        visible = false;
+        const button = new CommandToolbarButton({
+          commands,
+          id: testLogCommandId
+        });
+        await render(button);
+        const buttonNode = button.node.firstChild as HTMLButtonElement;
+        expect(buttonNode.disabled).toBe(true);
+        expect(buttonNode.classList.contains('lm-mod-toggled')).toBe(true);
+        expect(buttonNode.classList.contains('lm-mod-hidden')).toBe(true);
+        enabled = true;
+        visible = true;
+        commands.notifyCommandChanged(testLogCommandId);
+        expect(buttonNode.disabled).toBe(false);
+        expect(buttonNode.classList.contains('lm-mod-toggled')).toBe(true);
+        expect(buttonNode.classList.contains('lm-mod-hidden')).toBe(false);
+        enabled = false;
+        visible = false;
+        button.dispose();
+      });
+
+      it('should use the command label if no icon class/label', async () => {
+        const id = 'to-be-removed';
+        const cmd = commands.addCommand(id, {
+          execute: () => {
+            return;
+          },
+          label: 'Label-only button'
+        });
+        const button = new CommandToolbarButton({
+          commands,
+          id
+        });
+        await render(button);
+        const buttonNode = button.node.firstChild as HTMLButtonElement;
+        expect(buttonNode.textContent).toBe('Label-only button');
+        cmd.dispose();
+      });
+
+      it('should update the node content on command change event', async () => {
+        const id = 'to-be-removed';
+        let iconClassValue: string = '';
+        const cmd = commands.addCommand(id, {
+          execute: () => {
+            /* no op */
+          },
+          label: 'Label-only button',
+          iconClass: () => iconClassValue ?? ''
+        });
+        const button = new CommandToolbarButton({
+          commands,
+          id
+        });
+        await render(button);
+        const buttonNode = button.node.firstChild as HTMLButtonElement;
+        expect(buttonNode.textContent).toBe('Label-only button');
+        expect(buttonNode.classList.contains(iconClassValue)).toBe(false);
+
+        iconClassValue = 'updated-icon-class';
+        commands.notifyCommandChanged(id);
+        await render(button);
+        const wrapperNode = buttonNode.firstChild as HTMLElement;
+        const iconNode = wrapperNode.firstChild as HTMLElement;
+        expect(iconNode.classList.contains(iconClassValue)).toBe(true);
+        cmd.dispose();
+      });
+    });
+
     describe('Kernel buttons', () => {
       let sessionContext: SessionContext;
       beforeEach(async () => {
@@ -53,10 +413,7 @@
 
       describe('.createRestartButton()', () => {
         it("should add an inline svg node with the 'refresh' icon", async () => {
-          const button = Toolbar.createRestartButton(
-            sessionContext,
-            new SessionContextDialogs()
-          );
+          const button = Toolbar.createRestartButton(sessionContext);
           Widget.attach(button, document.body);
           await framePromise();
           expect(
@@ -67,14 +424,13 @@
 
       describe('.createKernelNameItem()', () => {
         it("should display the `'display_name'` of the kernel", async () => {
-          const item = Toolbar.createKernelNameItem(
-            sessionContext,
-            new SessionContextDialogs()
-          );
+          const item = Toolbar.createKernelNameItem(sessionContext);
           await sessionContext.initialize();
           Widget.attach(item, document.body);
           await framePromise();
-          const node = item.node.querySelector('.jp-Toolbar-kernelName')!;
+          const node = item.node.querySelector(
+            '.jp-ToolbarButtonComponent-label'
+          )!;
           expect(node.textContent).toBe(sessionContext.kernelDisplayName);
         });
       });
@@ -90,14 +446,13 @@
           let called = false;
           sessionContext.statusChanged.connect((_, status) => {
             if (status === 'busy') {
-              // eslint-disable-next-line jest/no-conditional-expect
               expect(
                 item.node.querySelector("[data-icon$='circle']")
               ).toBeDefined();
               called = true;
             }
           });
-          const future = sessionContext.session!.kernel!.requestExecute({
+          const future = sessionContext.session?.kernel?.requestExecute({
             code: 'a = 109\na'
           })!;
           await future.done;
@@ -109,12 +464,11 @@
           const status = sessionContext.session?.kernel?.status;
           expect(item.node.title.toLowerCase()).toContain(status);
           let called = false;
-          const future = sessionContext.session!.kernel!.requestExecute({
+          const future = sessionContext.session?.kernel?.requestExecute({
             code: 'a = 1'
           })!;
           future.onIOPub = msg => {
             if (sessionContext.session?.kernel?.status === 'busy') {
-              // eslint-disable-next-line jest/no-conditional-expect
               expect(item.node.title.toLowerCase()).toContain('busy');
               called = true;
             }
@@ -140,6 +494,264 @@
     });
   });
 
+  describe('ReactiveToolbar', () => {
+    let toolbar: ReactiveToolbar;
+
+    beforeEach(() => {
+      toolbar = new ReactiveToolbar();
+      Widget.attach(toolbar, document.body);
+    });
+
+    afterEach(() => {
+      toolbar.dispose();
+    });
+
+    describe('#constructor()', () => {
+      it('should append a node to body for the pop-up', () => {
+        const popup = document.body.querySelector(
+          '.jp-Toolbar-responsive-popup'
+        );
+        expect(popup).toBeDefined();
+        expect(popup!.parentNode!.nodeName).toEqual('BODY');
+      });
+    });
+
+    describe('#addItem()', () => {
+      it('should insert item before the toolbar pop-up button', () => {
+        const w = new Widget();
+        toolbar.addItem('test', w);
+        expect(
+          (toolbar.layout as PanelLayout).widgets.findIndex(v => v === w)
+        ).toEqual((toolbar.layout as PanelLayout).widgets.length - 2);
+      });
+    });
+
+    describe('#insertItem()', () => {
+      it('should insert item before the toolbar pop-up button', () => {
+        const w = new Widget();
+        toolbar.insertItem(2, 'test', w);
+        expect(
+          (toolbar.layout as PanelLayout).widgets.findIndex(v => v === w)
+        ).toEqual((toolbar.layout as PanelLayout).widgets.length - 2);
+      });
+    });
+
+    describe('#insertAfter()', () => {
+      it('should not insert item after the toolbar pop-up button', () => {
+        const w = new Widget();
+        const r = toolbar.insertAfter('toolbar-popup-opener', 'test', w);
+        expect(r).toEqual(false);
+        expect(
+          (toolbar.layout as PanelLayout).widgets.findIndex(v => v === w)
+        ).toEqual(-1);
+      });
+    });
+  });
+
+  describe('ToolbarButton', () => {
+    describe('#constructor()', () => {
+      it('should accept no arguments', () => {
+        const widget = new ToolbarButton();
+        expect(widget).toBeInstanceOf(ToolbarButton);
+      });
+
+      it('should accept options', async () => {
+        const widget = new ToolbarButton({
+          className: 'foo',
+          iconClass: 'iconFoo',
+          onClick: () => {
+            return void 0;
+          },
+          tooltip: 'bar'
+        });
+        Widget.attach(widget, document.body);
+        await framePromise();
+        const button = widget.node.firstChild as HTMLElement;
+        expect(button.classList.contains('foo')).toBe(true);
+        expect(button.querySelector('.iconFoo')).toBeDefined();
+        expect(button.title).toBe('bar');
+      });
+    });
+
+    describe('#dispose()', () => {
+      it('should dispose of the resources used by the widget', () => {
+        const button = new ToolbarButton();
+        button.dispose();
+        expect(button.isDisposed).toBe(true);
+      });
+
+      it('should be safe to call more than once', () => {
+        const button = new ToolbarButton();
+        button.dispose();
+        button.dispose();
+        expect(button.isDisposed).toBe(true);
+      });
+    });
+
+    describe('#handleEvent()', () => {
+      describe('click', () => {
+        it('should activate the callback', async () => {
+          let called = false;
+          const button = new ToolbarButton({
+            onClick: () => {
+              called = true;
+            }
+          });
+          Widget.attach(button, document.body);
+          await framePromise();
+          simulate(button.node.firstChild as HTMLElement, 'mousedown');
+          expect(called).toBe(true);
+          button.dispose();
+        });
+      });
+      describe('keydown', () => {
+        it('Enter should activate the callback', async () => {
+          let called = false;
+          const button = new ToolbarButton({
+            onClick: () => {
+              called = true;
+            }
+          });
+          Widget.attach(button, document.body);
+          await framePromise();
+          simulate(button.node.firstChild as HTMLElement, 'keydown', {
+            key: 'Enter'
+          });
+          expect(called).toBe(true);
+          button.dispose();
+        });
+        it('Space should activate the callback', async () => {
+          let called = false;
+          const button = new ToolbarButton({
+            onClick: () => {
+              called = true;
+            }
+          });
+          Widget.attach(button, document.body);
+          await framePromise();
+          simulate(button.node.firstChild as HTMLElement, 'keydown', {
+            key: ' '
+          });
+          expect(called).toBe(true);
+          button.dispose();
+        });
+      });
+    });
+
+    describe('#pressed()', () => {
+      it('should update the pressed state', async () => {
+        const widget = new ToolbarButton({
+          icon: bugIcon,
+          tooltip: 'tooltip',
+          pressedTooltip: 'pressed tooltip',
+          pressedIcon: bugDotIcon
+        });
+        Widget.attach(widget, document.body);
+        await framePromise();
+        const button = widget.node.firstChild as HTMLElement;
+        expect(widget.pressed).toBe(false);
+        expect(button.title).toBe('tooltip');
+        expect(button.getAttribute('aria-pressed')).toEqual('false');
+        let icon = button.querySelectorAll('svg');
+        expect(icon[0].getAttribute('data-icon')).toEqual('ui-components:bug');
+        widget.pressed = true;
+        await framePromise();
+        expect(widget.pressed).toBe(true);
+        expect(button.title).toBe('pressed tooltip');
+        expect(button.getAttribute('aria-pressed')).toEqual('true');
+        icon = button.querySelectorAll('svg');
+        expect(icon[0].getAttribute('data-icon')).toEqual(
+          'ui-components:bug-dot'
+        );
+        widget.dispose();
+      });
+
+      it('should not have the pressed state when not enabled', async () => {
+        const widget = new ToolbarButton({
+          icon: bugIcon,
+          tooltip: 'tooltip',
+          pressedTooltip: 'pressed tooltip',
+          disabledTooltip: 'disabled tooltip',
+          pressedIcon: bugDotIcon,
+          enabled: false
+        });
+        Widget.attach(widget, document.body);
+        await framePromise();
+        const button = widget.node.firstChild as HTMLElement;
+        expect(widget.pressed).toBe(false);
+        expect(button.title).toBe('disabled tooltip');
+        expect(button.getAttribute('aria-pressed')).toEqual('false');
+        widget.pressed = true;
+        await framePromise();
+        expect(widget.pressed).toBe(false);
+        expect(button.title).toBe('disabled tooltip');
+        expect(button.getAttribute('aria-pressed')).toEqual('false');
+        const icon = button.querySelectorAll('svg');
+        expect(icon[0].getAttribute('data-icon')).toEqual('ui-components:bug');
+        widget.dispose();
+      });
+    });
+
+    describe('#enabled()', () => {
+      it('should update the enabled state', async () => {
+        const widget = new ToolbarButton({
+          icon: bugIcon,
+          tooltip: 'tooltip',
+          pressedTooltip: 'pressed tooltip',
+          disabledTooltip: 'disabled tooltip',
+          pressedIcon: bugDotIcon
+        });
+        Widget.attach(widget, document.body);
+        await framePromise();
+        const button = widget.node.firstChild as HTMLElement;
+        expect(widget.enabled).toBe(true);
+        expect(widget.pressed).toBe(false);
+        expect(button.getAttribute('aria-disabled')).toEqual('false');
+
+        widget.pressed = true;
+        await framePromise();
+        expect(widget.pressed).toBe(true);
+
+        widget.enabled = false;
+        await framePromise();
+        expect(widget.enabled).toBe(false);
+        expect(widget.pressed).toBe(false);
+        expect(button.getAttribute('aria-disabled')).toEqual('true');
+        widget.dispose();
+      });
+    });
+
+    describe('#onClick()', () => {
+      it('should update the onClick state', async () => {
+        let mockCalled = false;
+        const mockOnClick = () => {
+          mockCalled = true;
+        };
+        const widget = new ToolbarButton({
+          icon: bugIcon,
+          tooltip: 'tooltip',
+          onClick: mockOnClick
+        });
+        Widget.attach(widget, document.body);
+        await framePromise();
+        simulate(widget.node.firstChild as HTMLElement, 'mousedown');
+        expect(mockCalled).toBe(true);
+
+        mockCalled = false;
+        let mockUpdatedCalled = false;
+        const mockOnClickUpdated = () => {
+          mockUpdatedCalled = true;
+        };
+        widget.onClick = mockOnClickUpdated;
+        await framePromise();
+        simulate(widget.node.firstChild as HTMLElement, 'mousedown');
+        expect(mockCalled).toBe(false);
+        expect(mockUpdatedCalled).toBe(true);
+        widget.dispose();
+      });
+    });
+  });
+
   describe('ToolbarWidgetRegistry', () => {
     describe('#constructor', () => {
       it('should set a default factory', () => {
@@ -182,7 +794,7 @@
         const widget = registry.createWidget('factory', documentWidget, item);
 
         expect(widget).toBe(dummyWidget);
-        expect(dummy).toHaveBeenCalledWith('factory', documentWidget, item);
+        expect(dummy).toBeCalledWith('factory', documentWidget, item);
       });
 
       it('should call the registered factory', () => {
@@ -198,17 +810,17 @@
           name: 'test'
         };
 
-        registry.addFactory('factory', item.name, dummy);
+        registry.registerFactory('factory', item.name, dummy);
 
         const widget = registry.createWidget('factory', documentWidget, item);
 
         expect(widget).toBe(dummyWidget);
-        expect(dummy).toHaveBeenCalledWith(documentWidget);
-        expect(defaultFactory).toHaveBeenCalledTimes(0);
-      });
-    });
-
-    describe('#addFactory', () => {
+        expect(dummy).toBeCalledWith(documentWidget);
+        expect(defaultFactory).toBeCalledTimes(0);
+      });
+    });
+
+    describe('#registerFactory', () => {
       it('should return the previous registered factory', () => {
         const defaultFactory = jest.fn();
         const dummy = jest.fn();
@@ -222,9 +834,11 @@
         };
 
         expect(
-          registry.addFactory('factory', item.name, dummy)
+          registry.registerFactory('factory', item.name, dummy)
         ).toBeUndefined();
-        expect(registry.addFactory('factory', item.name, dummy2)).toBe(dummy);
+        expect(registry.registerFactory('factory', item.name, dummy2)).toBe(
+          dummy
+        );
       });
     });
   });
@@ -297,7 +911,6 @@
       });
 
       const translator: ITranslator = {
-        languageCode: 'en',
         load: jest.fn()
       };
 
@@ -406,7 +1019,6 @@
       });
 
       const translator: ITranslator = {
-        languageCode: 'en',
         load: jest.fn()
       };
 
@@ -507,7 +1119,6 @@
       });
 
       const translator: ITranslator = {
-        languageCode: 'en',
         load: jest.fn()
       };
 
@@ -532,99 +1143,5 @@
       expect(factory(new Widget())).toHaveLength(3);
       expect(factory2(new Widget())).toHaveLength(3);
     });
-
-    it('should update the toolbar items with late item factory', async () => {
-      const factoryName = 'dummyFactory';
-      const pluginId = 'test-plugin:settings';
-
-      const dummyWidget = new Widget();
-      const defaultFactory = jest.fn().mockReturnValue(dummyWidget);
-
-      const textContent = 'This is a test widget';
-      const node = document.createElement('div');
-      node.textContent = textContent;
-      const testWidget = new Widget({ node });
-      const itemFactory = jest.fn().mockReturnValue(testWidget);
-
-      const toolbarRegistry = new ToolbarWidgetRegistry({
-        defaultFactory: defaultFactory
-      });
-
-      const bar: ISettingRegistry.IPlugin = {
-        data: {
-          composite: {},
-          user: {}
-        },
-        id: pluginId,
-        raw: '{}',
-        schema: {
-          'jupyter.lab.toolbars': {
-            dummyFactory: [
-              {
-                name: 'test',
-                rank: 20
-              }
-            ]
-          },
-          'jupyter.lab.transform': true,
-          properties: {
-            toolbar: {
-              type: 'array'
-            }
-          },
-          type: 'object'
-        },
-        version: 'test'
-      };
-
-      const connector: IDataConnector<
-        ISettingRegistry.IPlugin,
-        string,
-        string,
-        string
-      > = {
-        fetch: jest.fn().mockImplementation((id: string) => {
-          switch (id) {
-            case bar.id:
-              return bar;
-            default:
-              return {};
-          }
-        }),
-        list: jest.fn(),
-        save: jest.fn(),
-        remove: jest.fn()
-      };
-
-      const settingRegistry = new SettingRegistry({
-        connector
-      });
-
-      const translator: ITranslator = {
-        languageCode: 'en',
-        load: jest.fn()
-      };
-
-      const factory = createToolbarFactory(
-        toolbarRegistry,
-        settingRegistry,
-        factoryName,
-        pluginId,
-        translator
-      );
-
-      await settingRegistry.load(bar.id);
-
-      const toolbar = factory(new Widget());
-
-      // Should contain the defaultFactory widget
-      expect(toolbar).toHaveLength(1);
-      expect(toolbar.get(0).widget.node.textContent).not.toContain(textContent);
-
-      // Add a factory item to the toolbar should re-render the widget.
-      toolbarRegistry.addFactory(factoryName, 'test', itemFactory);
-      expect(toolbar).toHaveLength(1);
-      expect(toolbar.get(0).widget.node.textContent).toContain(textContent);
-    });
   });
 });