--- packages\apputils\test\sessioncontext.spec.ts (old)
+++ packages\apputils\test\sessioncontext.spec.ts (new)
@@ -4,9 +4,8 @@
 import {
   Dialog,
   ISessionContext,
-  ISessionContextDialogs,
   SessionContext,
-  SessionContextDialogs
+  sessionContextDialogs
 } from '@jupyterlab/apputils';
 import {
   KernelManager,
@@ -14,29 +13,26 @@
   SessionAPI,
   SessionManager
 } from '@jupyterlab/services';
-import { IKernelConnection } from '@jupyterlab/services/lib/kernel/kernel';
 import {
   acceptDialog,
   dismissDialog,
+  flakyIt as it,
   JupyterServer,
   testEmission
-} from '@jupyterlab/testing';
+} from '@jupyterlab/testutils';
 import { PromiseDelegate, UUID } from '@lumino/coreutils';
 
+const server = new JupyterServer();
+
+beforeAll(async () => {
+  await server.start();
+});
+
+afterAll(async () => {
+  await server.shutdown();
+});
+
 describe('@jupyterlab/apputils', () => {
-  let server: JupyterServer;
-
-  beforeAll(async () => {
-    server = new JupyterServer();
-    await server.start();
-  }, 30000);
-
-  afterAll(async () => {
-    await server.shutdown();
-  });
-
-  jest.retryTimes(3);
-
   describe('SessionContext', () => {
     let kernelManager: KernelManager;
     let sessionManager: SessionManager;
@@ -45,6 +41,7 @@
     let sessionContext: SessionContext;
 
     beforeAll(async () => {
+      jest.setTimeout(20000);
       kernelManager = new KernelManager();
       sessionManager = new SessionManager({ kernelManager });
       specsManager = new KernelSpecManager();
@@ -53,7 +50,7 @@
         kernelManager.ready,
         specsManager.ready
       ]);
-    }, 30000);
+    });
 
     beforeEach(async () => {
       Dialog.flush();
@@ -339,6 +336,15 @@
         };
         expect(sessionContext.kernelDisplayName).toBe('No Kernel');
       });
+
+      it('should display the pending kernel name when it looks like we are starting a kernel', async () => {
+        sessionContext.kernelPreference = {
+          autoStartDefault: true,
+          canStart: true,
+          shouldStart: true
+        };
+        expect(sessionContext.kernelDisplayName).toBe('Echo Kernel');
+      });
     });
 
     describe('#kernelDisplayStatus', () => {
@@ -412,7 +418,7 @@
           }
         });
         sessionContext.dispose();
-        await expect(delegate.promise).resolves.not.toThrow();
+        return delegate.promise;
       });
     });
 
@@ -433,7 +439,7 @@
         const name = 'echo';
         const kernelPromise = sessionContext.changeKernel({ name });
 
-        let lastKernel: IKernelConnection | null | undefined = null;
+        let lastKernel = null;
         sessionContext.kernelChanged.connect(() => {
           lastKernel = sessionContext.session?.kernel;
         });
@@ -451,7 +457,7 @@
         // The last launched kernel should win.
         const kernelPromise1 = sessionContext.changeKernel({ name });
 
-        let lastKernel: IKernelConnection | null | undefined = null;
+        let lastKernel = null;
         sessionContext.kernelChanged.connect(() => {
           lastKernel = sessionContext.session?.kernel;
         });
@@ -490,8 +496,9 @@
       });
 
       it('should return a matching name', () => {
-        const spec =
-          specsManager.specs!.kernelspecs[specsManager.specs!.default]!;
+        const spec = specsManager.specs!.kernelspecs[
+          specsManager.specs!.default
+        ]!;
 
         expect(
           SessionContext.getDefaultKernel({
@@ -511,8 +518,9 @@
       });
 
       it('should return a matching language', () => {
-        const spec =
-          specsManager.specs!.kernelspecs[specsManager.specs!.default]!;
+        const spec = specsManager.specs!.kernelspecs[
+          specsManager.specs!.default
+        ]!;
         const kernelspecs: any = {};
 
         kernelspecs[spec.name] = spec;
@@ -528,8 +536,9 @@
       });
 
       it('should return null if a language matches twice', () => {
-        const spec =
-          specsManager.specs!.kernelspecs[specsManager.specs!.default]!;
+        const spec = specsManager.specs!.kernelspecs[
+          specsManager.specs!.default
+        ]!;
         const kernelspecs: any = {};
 
         kernelspecs['foo'] = spec;
@@ -545,116 +554,74 @@
         ).toBeNull();
       });
     });
-  });
-  describe('SessionContextDialogs', () => {
-    let sessionContextDialogs: ISessionContextDialogs;
-    let kernelManager: KernelManager;
-    let sessionManager: SessionManager;
-    let specsManager: KernelSpecManager;
-    let path = '';
-    let sessionContext: SessionContext;
-
-    beforeAll(async () => {
-      kernelManager = new KernelManager();
-      sessionManager = new SessionManager({ kernelManager });
-      specsManager = new KernelSpecManager();
-      await Promise.all([
-        sessionManager.ready,
-        kernelManager.ready,
-        specsManager.ready
-      ]);
-    }, 30000);
-
-    beforeEach(async () => {
-      Dialog.flush();
-      path = UUID.uuid4();
-      sessionContext = new SessionContext({
-        path,
-        sessionManager,
-        specsManager,
-        kernelPreference: { name: specsManager.specs?.default }
-      });
-
-      sessionContextDialogs = new SessionContextDialogs();
-    });
-
-    afterEach(async () => {
-      Dialog.flush();
-      try {
-        if (sessionContext.session) {
+
+    describe('.sessionContextDialogs', () => {
+      describe('#selectKernel()', () => {
+        it('should select a kernel for the session', async () => {
+          await sessionContext.initialize();
+
+          const { id, name } = sessionContext?.session!.kernel!;
+          const accept = acceptDialog();
+
+          await sessionContextDialogs.selectKernel(sessionContext);
+          await accept;
+
+          const session = sessionContext?.session;
+          expect(session!.kernel!.id).not.toBe(id);
+          expect(session!.kernel!.name).toBe(name);
+        });
+
+        it('should keep the existing kernel if dismissed', async () => {
+          await sessionContext.initialize();
+
+          const { id, name } = sessionContext!.session!.kernel!;
+          const dismiss = dismissDialog();
+
+          await sessionContextDialogs.selectKernel(sessionContext);
+          await dismiss;
+
+          const session = sessionContext.session;
+          expect(session!.kernel!.id).toBe(id);
+          expect(session!.kernel!.name).toBe(name);
+        });
+      });
+
+      describe('#restart()', () => {
+        it('should restart if the user accepts the dialog', async () => {
+          const emission = testEmission(sessionContext.statusChanged, {
+            find: (_, args) => args === 'restarting'
+          });
+          await sessionContext.initialize();
+          await sessionContext!.session?.kernel?.info;
+          const restart = sessionContextDialogs.restart(sessionContext);
+
+          await acceptDialog();
+          expect(await restart).toBe(true);
+          await emission;
+        });
+
+        it('should not restart if the user rejects the dialog', async () => {
+          let called = false;
+
+          await sessionContext.initialize();
+          sessionContext.statusChanged.connect((sender, args) => {
+            if (args === 'restarting') {
+              called = true;
+            }
+          });
+
+          const restart = sessionContextDialogs.restart(sessionContext);
+          await dismissDialog();
+          expect(await restart).toBe(false);
+          expect(called).toBe(false);
+        });
+
+        it('should start the same kernel as the previously started kernel', async () => {
+          await sessionContext.initialize();
           await sessionContext.shutdown();
-        }
-      } catch (error) {
-        console.warn('Session shutdown failed.', error);
-      }
-      sessionContext.dispose();
-    });
-
-    describe('#selectKernel()', () => {
-      it('should select a kernel for the session', async () => {
-        await sessionContext.initialize();
-
-        const { id, name } = sessionContext!.session!.kernel!;
-        const accept = acceptDialog();
-
-        await sessionContextDialogs.selectKernel(sessionContext);
-        await accept;
-
-        const session = sessionContext?.session;
-        expect(session!.kernel!.id).not.toBe(id);
-        expect(session!.kernel!.name).toBe(name);
-      });
-
-      it('should keep the existing kernel if dismissed', async () => {
-        await sessionContext.initialize();
-
-        const { id, name } = sessionContext!.session!.kernel!;
-        const dismiss = dismissDialog();
-
-        await sessionContextDialogs.selectKernel(sessionContext);
-        await dismiss;
-
-        const session = sessionContext.session;
-        expect(session!.kernel!.id).toBe(id);
-        expect(session!.kernel!.name).toBe(name);
-      });
-    });
-
-    describe('#restart()', () => {
-      it('should restart if the user accepts the dialog', async () => {
-        const emission = testEmission(sessionContext.statusChanged, {
-          find: (_, args) => args === 'restarting'
-        });
-        await sessionContext.initialize();
-        await sessionContext!.session?.kernel?.info;
-        const restart = sessionContextDialogs.restart(sessionContext);
-
-        await acceptDialog();
-        expect(await restart).toBe(true);
-        await emission;
-      });
-
-      it('should not restart if the user rejects the dialog', async () => {
-        let called = false;
-
-        await sessionContext.initialize();
-        sessionContext.statusChanged.connect((sender, args) => {
-          if (args === 'restarting') {
-            called = true;
-          }
-        });
-
-        const restart = sessionContextDialogs.restart(sessionContext);
-        await dismissDialog();
-        expect(await restart).toBe(false);
-        expect(called).toBe(false);
-      });
-
-      it('should start the same kernel as the previously started kernel', async () => {
-        await sessionContext.initialize();
-        await sessionContext.shutdown();
-        await sessionContextDialogs.restart(sessionContext);
-        expect(sessionContext?.session?.kernel).toBeTruthy();
+          await sessionContextDialogs.restart(sessionContext);
+          expect(sessionContext?.session?.kernel).toBeTruthy();
+        });
       });
     });
   });