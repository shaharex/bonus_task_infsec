--- packages\console\src\widget.ts (old)
+++ packages\console\src\widget.ts (new)
@@ -1,12 +1,11 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
-import { createStandaloneCell, ISharedRawCell } from '@jupyter/ydoc';
-import { DOMUtils, ISessionContext } from '@jupyterlab/apputils';
+import { ISessionContext } from '@jupyterlab/apputils';
 import {
-  AttachmentsCellModel,
   Cell,
   CellDragUtils,
+  CellModel,
   CodeCell,
   CodeCellModel,
   ICodeCellModel,
@@ -15,20 +14,18 @@
   RawCell,
   RawCellModel
 } from '@jupyterlab/cells';
-import { IEditorMimeTypeService } from '@jupyterlab/codeeditor';
+import { CodeEditor, IEditorMimeTypeService } from '@jupyterlab/codeeditor';
 import * as nbformat from '@jupyterlab/nbformat';
 import { IObservableList, ObservableList } from '@jupyterlab/observables';
 import { IRenderMimeRegistry } from '@jupyterlab/rendermime';
 import { KernelMessage } from '@jupyterlab/services';
-import { ITranslator, nullTranslator } from '@jupyterlab/translation';
+import { each } from '@lumino/algorithm';
 import { JSONObject, MimeData } from '@lumino/coreutils';
 import { Drag } from '@lumino/dragdrop';
 import { Message } from '@lumino/messaging';
 import { ISignal, Signal } from '@lumino/signaling';
 import { Panel, PanelLayout, Widget } from '@lumino/widgets';
-import { runCell } from './cellexecutor';
 import { ConsoleHistory, IConsoleHistory } from './history';
-import type { IConsoleCellExecutor } from './tokens';
 
 /**
  * The data attribute added to a widget that has an active kernel.
@@ -71,14 +68,6 @@
 const INPUT_CLASS = 'jp-CodeConsole-input';
 
 /**
- * The class name added to the console when an element within it is focused
- * and takes keyboard input, such as <input> and <div contenteditable>
- *
- * This class is also effective when the focused element is in shadow DOM.
- */
-const READ_WRITE_CLASS = 'jp-mod-readWrite';
-
-/**
  * The timeout in ms for execution requests to the kernel.
  */
 const EXECUTION_TIMEOUT = 250;
@@ -87,11 +76,6 @@
  * The mimetype used for Jupyter cell data.
  */
 const JUPYTER_CELL_MIME = 'application/vnd.jupyter.cells';
-
-/**
- * The data attribute added to a widget that can undo.
- */
-const UNDOER = 'jpUndoer';
 
 /**
  * A widget containing a Jupyter console.
@@ -106,12 +90,9 @@
    */
   constructor(options: CodeConsole.IOptions) {
     super();
-    this._translator = options.translator ?? nullTranslator;
-    this._executor = options.executor ?? Object.freeze({ runCell });
     this.addClass(CONSOLE_CLASS);
     this.node.dataset[KERNEL_USER] = 'true';
     this.node.dataset[CODE_RUNNER] = 'true';
-    this.node.dataset[UNDOER] = 'true';
     this.node.tabIndex = -1; // Allow the widget to take focus.
 
     // Create the panels that hold the content and input.
@@ -120,8 +101,9 @@
     this._content = new Panel();
     this._input = new Panel();
 
-    this.contentFactory = options.contentFactory;
-    this.modelFactory = options.modelFactory ?? CodeConsole.defaultModelFactory;
+    this.contentFactory =
+      options.contentFactory || CodeConsole.defaultContentFactory;
+    this.modelFactory = options.modelFactory || CodeConsole.defaultModelFactory;
     this.rendermime = options.rendermime;
     this.sessionContext = options.sessionContext;
     this._mimeTypeService = options.mimeTypeService;
@@ -184,7 +166,7 @@
   /**
    * The configuration options for the text editor widget.
    */
-  editorConfig: Record<string, any> = CodeConsole.defaultEditorConfig;
+  editorConfig?: Partial<CodeEditor.IConfig>;
 
   /**
    * The list of content cells in the console.
@@ -218,7 +200,7 @@
    * rendered code cell widgets and does not execute them (though it can store
    * the execution message id).
    */
-  addCell(cell: CodeCell, msgId?: string): void {
+  addCell(cell: CodeCell, msgId?: string) {
     cell.addClass(CONSOLE_CELL_CLASS);
     this._content.addWidget(cell);
     this._cells.push(cell);
@@ -233,7 +215,7 @@
   /**
    * Add a banner cell.
    */
-  addBanner(): void {
+  addBanner() {
     if (this._banner) {
       // An old banner just becomes a normal cell now.
       const cell = this._banner;
@@ -241,33 +223,12 @@
       cell.disposed.connect(this._onCellDisposed, this);
     }
     // Create the banner.
-    const model = this.modelFactory.createRawCell({
-      sharedModel: createStandaloneCell({
-        cell_type: 'raw',
-        source: '...'
-      }) as ISharedRawCell
-    });
+    const model = this.modelFactory.createRawCell({});
+    model.value.text = '...';
     const banner = (this._banner = new RawCell({
       model,
       contentFactory: this.contentFactory,
-      placeholder: false,
-      editorConfig: {
-        autoClosingBrackets: false,
-        codeFolding: false,
-        highlightActiveLine: false,
-        highlightTrailingWhitespace: false,
-        highlightWhitespace: false,
-        indentUnit: '4',
-        lineNumbers: false,
-        lineWrap: true,
-        matchBrackets: false,
-        readOnly: true,
-        rulers: [],
-        scrollPastEnd: false,
-        smartIndent: false,
-        tabSize: 4,
-        theme: 'jupyter'
-      }
+      placeholder: false
     })).initializeState();
     banner.addClass(BANNER_CLASS);
     banner.readOnly = true;
@@ -300,14 +261,16 @@
   /**
    * Dispose of the resources held by the widget.
    */
-  dispose(): void {
+  dispose() {
     // Do nothing if already disposed.
     if (this.isDisposed) {
       return;
     }
+    this._cells.clear();
     this._msgIdCells = null!;
     this._msgIds = null!;
     this._history.dispose();
+
     super.dispose();
   }
 
@@ -347,11 +310,11 @@
     if (shouldExecute) {
       // Create a new prompt cell before kernel execution to allow typeahead.
       this.newPromptCell();
-      this.promptCell!.editor!.focus();
+      this.promptCell!.editor.focus();
       await this._execute(promptCell);
     } else {
       // add a newline if we shouldn't execute
-      promptCell.editor!.newIndentedLine();
+      promptCell.editor.newIndentedLine();
     }
   }
 
@@ -373,9 +336,9 @@
    */
   inject(code: string, metadata: JSONObject = {}): Promise<void> {
     const cell = this.createCodeCell();
-    cell.model.sharedModel.setSource(code);
+    cell.model.value.text = code;
     for (const key of Object.keys(metadata)) {
-      cell.model.setMetadata(key, metadata[key]);
+      cell.model.metadata.set(key, metadata[key]);
     }
     this.addCell(cell);
     return this._execute(cell);
@@ -389,7 +352,7 @@
     if (!promptCell) {
       return;
     }
-    promptCell.editor!.newIndentedLine();
+    promptCell.editor.newIndentedLine();
   }
 
   /**
@@ -402,7 +365,7 @@
     if (!promptCell) {
       return;
     }
-    promptCell.editor!.replaceSelection?.(text);
+    promptCell.editor.replaceSelection?.(text);
   }
 
   /**
@@ -414,12 +377,12 @@
    */
   serialize(): nbformat.ICodeCell[] {
     const cells: nbformat.ICodeCell[] = [];
-    for (const cell of this._cells) {
+    each(this._cells, cell => {
       const model = cell.model;
       if (isCodeCellModel(model)) {
         cells.push(model.toJSON());
       }
-    }
+    });
 
     if (this.promptCell) {
       cells.push(this.promptCell.model.toJSON());
@@ -465,8 +428,10 @@
 
     const cell = this._cells.get(cellIndex);
 
-    const targetArea: CellDragUtils.ICellTargetArea =
-      CellDragUtils.detectTargetArea(cell, event.target as HTMLElement);
+    const targetArea: CellDragUtils.ICellTargetArea = CellDragUtils.detectTargetArea(
+      cell,
+      event.target as HTMLElement
+    );
 
     if (targetArea === 'prompt') {
       this._dragData = {
@@ -526,7 +491,7 @@
     });
 
     this._drag.mimeData.setData(JUPYTER_CELL_MIME, selected);
-    const textContent = cellModel.sharedModel.getSource();
+    const textContent = cellModel.value.text;
     this._drag.mimeData.setData('text/plain', textContent);
 
     this._focusedCell = null;
@@ -566,12 +531,6 @@
       case 'mouseup':
         this._evtMouseUp(event as MouseEvent);
         break;
-      case 'focusin':
-        this._evtFocusIn(event as MouseEvent);
-        break;
-      case 'focusout':
-        this._evtFocusOut(event as MouseEvent);
-        break;
       default:
         break;
     }
@@ -585,13 +544,11 @@
     node.addEventListener('keydown', this, true);
     node.addEventListener('click', this);
     node.addEventListener('mousedown', this);
-    node.addEventListener('focusin', this);
-    node.addEventListener('focusout', this);
     // Create a prompt if necessary.
     if (!this.promptCell) {
       this.newPromptCell();
     } else {
-      this.promptCell.editor!.focus();
+      this.promptCell.editor.focus();
       this.update();
     }
   }
@@ -603,8 +560,6 @@
     const node = this.node;
     node.removeEventListener('keydown', this, true);
     node.removeEventListener('click', this);
-    node.removeEventListener('focusin', this);
-    node.removeEventListener('focusout', this);
   }
 
   /**
@@ -629,18 +584,7 @@
     if (promptCell) {
       promptCell.readOnly = true;
       promptCell.removeClass(PROMPT_CLASS);
-
-      // Schedule execution of signal clearance to happen later so that
-      // the `readOnly` configuration gets updated before editor signals
-      // get disconnected (see `Cell.onUpdateRequest`).
-      const oldCell = promptCell;
-      requestIdleCallback(() => {
-        // Clear the signals to avoid memory leaks
-        Signal.clearData(oldCell.editor);
-      });
-
-      // Ensure to clear the cursor
-      promptCell.editor?.blur();
+      Signal.clearData(promptCell.editor);
       const child = input.widgets[0];
       child.parent = null;
       this.addCell(promptCell);
@@ -656,7 +600,11 @@
     // Add the prompt cell to the DOM, making `this.promptCell` valid again.
     this._input.addWidget(promptCell);
 
-    this._history.editor = promptCell.editor;
+    // Suppress the default "Enter" key handling.
+    const editor = promptCell.editor;
+    editor.addKeydownHandler(this._onEditorKeydown);
+
+    this._history.editor = editor;
     this._promptCellCreated.emit(promptCell);
   }
 
@@ -694,31 +642,15 @@
       this.promptCell &&
       this.promptCell.node.contains(event.target as HTMLElement)
     ) {
-      this.promptCell.editor!.focus();
-    }
-  }
-
-  /**
-   * Handle `focus` events for the widget.
-   */
-  private _evtFocusIn(event: FocusEvent): void {
-    // Update read-write class state.
-    this._updateReadWrite();
-  }
-
-  /**
-   * Handle `focusout` events for the widget.
-   */
-  private _evtFocusOut(event: FocusEvent): void {
-    // Update read-write class state.
-    this._updateReadWrite();
+      this.promptCell.editor.focus();
+    }
   }
 
   /**
    * Execute the code in the current prompt cell.
    */
-  private async _execute(cell: CodeCell): Promise<void> {
-    const source = cell.model.sharedModel.getSource();
+  private _execute(cell: CodeCell): Promise<void> {
+    const source = cell.model.value.text;
     this._history.push(source);
     // If the source of the console is just "clear", clear the console as we
     // do in IPython or QtConsole.
@@ -727,36 +659,45 @@
       return Promise.resolve(void 0);
     }
     cell.model.contentChanged.connect(this.update, this);
-
-    const options = {
-      cell,
-      sessionContext: this.sessionContext,
-      onCellExecuted: (args: {
-        cell: CodeCell;
-        executionDate: Date;
-        success: boolean;
-        error?: Error | null;
-      }) => {
-        this._executed.emit(args.executionDate);
-
-        if (args.error) {
-          for (const cell of this._cells) {
-            if ((cell.model as ICodeCellModel).executionCount === null) {
-              cell.setPrompt('');
-            }
+    const onSuccess = (value: KernelMessage.IExecuteReplyMsg) => {
+      if (this.isDisposed) {
+        return;
+      }
+      if (value && value.content.status === 'ok') {
+        const content = value.content;
+        // Use deprecated payloads for backwards compatibility.
+        if (content.payload && content.payload.length) {
+          const setNextInput = content.payload.filter(i => {
+            return (i as any).source === 'set_next_input';
+          })[0];
+          if (setNextInput) {
+            const text = (setNextInput as any).text;
+            // Ignore the `replace` value and always set the next cell.
+            cell.model.value.text = text;
           }
         }
+      } else if (value && value.content.status === 'error') {
+        each(this._cells, (cell: CodeCell) => {
+          if (cell.model.executionCount === null) {
+            cell.setPrompt('');
+          }
+        });
       }
-    } satisfies IConsoleCellExecutor.IRunCellOptions;
-
-    try {
-      await this._executor.runCell(options);
-    } finally {
-      if (!this.isDisposed) {
-        cell.model.contentChanged.disconnect(this.update, this);
-        this.update();
+      cell.model.contentChanged.disconnect(this.update, this);
+      this.update();
+      this._executed.emit(new Date());
+    };
+    const onFailure = () => {
+      if (this.isDisposed) {
+        return;
       }
-    }
+      cell.model.contentChanged.disconnect(this.update, this);
+      this.update();
+    };
+    return CodeCell.execute(cell, this.sessionContext).then(
+      onSuccess,
+      onFailure
+    );
   }
 
   /**
@@ -764,12 +705,10 @@
    */
   private _handleInfo(info: KernelMessage.IInfoReplyMsg['content']): void {
     if (info.status !== 'ok') {
-      this._banner!.model.sharedModel.setSource(
-        'Error in getting kernel banner'
-      );
+      this._banner!.model.value.text = 'Error in getting kernel banner';
       return;
     }
-    this._banner!.model.sharedModel.setSource(info.banner);
+    this._banner!.model.value.text = info.banner;
     const lang = info.language_info as nbformat.ILanguageInfoMetadata;
     this._mimetype = this._mimeTypeService.getMimeTypeByLanguage(lang);
     if (this.promptCell) {
@@ -786,14 +725,12 @@
     const model = modelFactory.createCodeCell({});
     const rendermime = this.rendermime;
     const editorConfig = this.editorConfig;
-
     return {
       model,
       rendermime,
       contentFactory,
       editorConfig,
-      placeholder: false,
-      translator: this._translator
+      placeholder: false
     };
   }
 
@@ -820,7 +757,7 @@
       return Promise.resolve(false);
     }
     const model = promptCell.model;
-    const code = model.sharedModel.getSource();
+    const code = model.value.text;
     return new Promise<boolean>((resolve, reject) => {
       const timer = setTimeout(() => {
         resolve(true);
@@ -850,6 +787,14 @@
   }
 
   /**
+   * Handle a keydown event on an editor.
+   */
+  private _onEditorKeydown(editor: CodeEditor.IEditor, event: KeyboardEvent) {
+    // Suppress "Enter" events.
+    return event.keyCode === 13;
+  }
+
+  /**
    * Handle a change to the kernel.
    */
   private async _onKernelChanged(): Promise<void> {
@@ -875,19 +820,9 @@
     }
   }
 
-  /**
-   * Update the console node with class indicating read-write state.
-   */
-  private _updateReadWrite(): void {
-    // TODO: de-duplicate with code in notebook/src/widget.ts
-    const inReadWrite = DOMUtils.hasActiveEditableElement(this.node);
-    this.node.classList.toggle(READ_WRITE_CLASS, inReadWrite);
-  }
-
   private _banner: RawCell | null = null;
   private _cells: IObservableList<Cell>;
   private _content: Panel;
-  private _executor: IConsoleCellExecutor;
   private _executed = new Signal<this, Date>(this);
   private _history: IConsoleHistory;
   private _input: Panel;
@@ -903,7 +838,6 @@
   } | null = null;
   private _drag: Drag | null = null;
   private _focusedCell: Cell | null = null;
-  private _translator: ITranslator;
 }
 
 /**
@@ -920,11 +854,6 @@
     contentFactory: IContentFactory;
 
     /**
-     * Console cell executor
-     */
-    executor?: IConsoleCellExecutor;
-
-    /**
      * The model factory for the console widget.
      */
     modelFactory?: IModelFactory;
@@ -943,20 +872,7 @@
      * The service used to look up mime types.
      */
     mimeTypeService: IEditorMimeTypeService;
-
-    /**
-     * The application language translator.
-     */
-    translator?: ITranslator;
-  }
-
-  /**
-   * Default console editor configuration
-   */
-  export const defaultEditorConfig: Record<string, any> = {
-    codeFolding: false,
-    lineNumbers: false
-  };
+  }
 
   /**
    * A content factory for console children.
@@ -978,8 +894,7 @@
    */
   export class ContentFactory
     extends Cell.ContentFactory
-    implements IContentFactory
-  {
+    implements IContentFactory {
     /**
      * Create a new code cell widget.
      *
@@ -988,6 +903,9 @@
      * notebook content factory is used.
      */
     createCodeCell(options: CodeCell.IOptions): CodeCell {
+      if (!options.contentFactory) {
+        options.contentFactory = this;
+      }
       return new CodeCell(options).initializeState();
     }
 
@@ -999,6 +917,9 @@
      * notebook content factory is used.
      */
     createRawCell(options: RawCell.IOptions): RawCell {
+      if (!options.contentFactory) {
+        options.contentFactory = this;
+      }
       return new RawCell(options).initializeState();
     }
   }
@@ -1012,6 +933,11 @@
      */
     export interface IOptions extends Cell.IContentFactory {}
   }
+
+  /**
+   * A default content factory for the code console.
+   */
+  export const defaultContentFactory: IContentFactory = new ContentFactory();
 
   /**
    * A model factory for a console widget.
@@ -1040,9 +966,7 @@
      * @returns A new raw cell. If a source cell is provided, the
      *   new cell will be initialized with the data from the source.
      */
-    createRawCell(
-      options: AttachmentsCellModel.IOptions<ISharedRawCell>
-    ): IRawCellModel;
+    createRawCell(options: CellModel.IOptions): IRawCellModel;
   }
 
   /**
@@ -1064,13 +988,15 @@
 
     /**
      * Create a new code cell.
-     * @param options - The data to use for the original source data.
+     *
+     * @param source - The data to use for the original source data.
+     *
      * @returns A new code cell. If a source cell is provided, the
-    new cell will be initialized with the data from the source.
-    If the contentFactory is not provided, the instance
-    `codeCellContentFactory` will be used.
-     */
-    createCodeCell(options: CodeCellModel.IOptions = {}): ICodeCellModel {
+     *   new cell will be initialized with the data from the source.
+     *   If the contentFactory is not provided, the instance
+     *   `codeCellContentFactory` will be used.
+     */
+    createCodeCell(options: CodeCellModel.IOptions): ICodeCellModel {
       if (!options.contentFactory) {
         options.contentFactory = this.codeCellContentFactory;
       }
@@ -1079,13 +1005,13 @@
 
     /**
      * Create a new raw cell.
-     * @param options - The data to use for the original source data.
+     *
+     * @param source - The data to use for the original source data.
+     *
      * @returns A new raw cell. If a source cell is provided, the
-    new cell will be initialized with the data from the source.
-     */
-    createRawCell(
-      options: AttachmentsCellModel.IOptions<ISharedRawCell>
-    ): IRawCellModel {
+     *   new cell will be initialized with the data from the source.
+     */
+    createRawCell(options: CellModel.IOptions): IRawCellModel {
       return new RawCellModel(options);
     }
   }