--- packages\inspector-extension\src\index.ts (old)
+++ packages\inspector-extension\src\index.ts (new)
@@ -27,15 +27,12 @@
 import { INotebookTracker } from '@jupyterlab/notebook';
 import { ITranslator } from '@jupyterlab/translation';
 import { inspectorIcon } from '@jupyterlab/ui-components';
-import { Widget } from '@lumino/widgets';
 
 /**
  * The command IDs used by the inspector plugin.
  */
 namespace CommandIDs {
   export const open = 'inspector:open';
-  export const close = 'inspector:close';
-  export const toggle = 'inspector:toggle';
 }
 
 /**
@@ -43,7 +40,6 @@
  */
 const inspector: JupyterFrontEndPlugin<IInspector> = {
   id: '@jupyterlab/inspector-extension:inspector',
-  description: 'Provides the code introspection widget.',
   requires: [ITranslator],
   optional: [ICommandPalette, ILauncher, ILayoutRestorer],
   provides: IInspector,
@@ -57,12 +53,9 @@
   ): IInspector => {
     const trans = translator.load('jupyterlab');
     const { commands, shell } = app;
-    const caption = trans.__(
-      'Live updating code documentation from the active kernel'
-    );
-    const openedLabel = trans.__('Contextual Help');
+    const command = CommandIDs.open;
+    const label = trans.__('Show Contextual Help');
     const namespace = 'inspector';
-    const datasetKey = 'jpInspector';
     const tracker = new WidgetTracker<MainAreaWidget<InspectorPanel>>({
       namespace
     });
@@ -79,7 +72,7 @@
           content: new InspectorPanel({ translator })
         });
         inspector.id = 'jp-inspector';
-        inspector.title.label = openedLabel;
+        inspector.title.label = label;
         inspector.title.icon = inspectorIcon;
         void tracker.add(inspector);
         source = source && !source.isDisposed ? source : null;
@@ -87,31 +80,23 @@
         inspector.content.source?.onEditorChange(args);
       }
       if (!inspector.isAttached) {
-        shell.add(inspector, 'main', {
-          activate: false,
-          mode: 'split-right',
-          type: 'Inspector'
-        });
+        shell.add(inspector, 'main', { activate: false, mode: 'split-right' });
       }
       shell.activateById(inspector.id);
-      document.body.dataset[datasetKey] = 'open';
       return inspector;
     }
-    function closeInspector(): void {
-      inspector.dispose();
-      delete document.body.dataset[datasetKey];
-    }
-
-    // Add inspector:open command to registry.
-    const showLabel = trans.__('Show Contextual Help');
-    commands.addCommand(CommandIDs.open, {
-      caption,
+
+    // Add command to registry.
+    commands.addCommand(command, {
+      caption: trans.__(
+        'Live updating code documentation from the active kernel'
+      ),
       isEnabled: () =>
         !inspector ||
         inspector.isDisposed ||
         !inspector.isAttached ||
         !inspector.isVisible,
-      label: showLabel,
+      label,
       icon: args => (args.isLauncher ? inspectorIcon : undefined),
       execute: args => {
         const text = args && (args.text as string);
@@ -123,52 +108,21 @@
       }
     });
 
-    // Add inspector:close command to registry.
-    const closeLabel = trans.__('Hide Contextual Help');
-    commands.addCommand(CommandIDs.close, {
-      caption,
-      isEnabled: () => isInspectorOpen(),
-      label: closeLabel,
-      icon: args => (args.isLauncher ? inspectorIcon : undefined),
-      execute: () => closeInspector()
-    });
-
-    // Add inspector:toggle command to registry.
-    const toggleLabel = trans.__('Show Contextual Help');
-    commands.addCommand(CommandIDs.toggle, {
-      caption,
-      label: toggleLabel,
-      isToggled: () => isInspectorOpen(),
-      execute: args => {
-        if (isInspectorOpen()) {
-          closeInspector();
-        } else {
-          const text = args && (args.text as string);
-          openInspector(text);
-        }
-      }
-    });
-
-    // Add open command to launcher if possible.
+    // Add command to UI where possible.
+    if (palette) {
+      palette.addItem({ command, category: label });
+    }
     if (launcher) {
-      launcher.add({ command: CommandIDs.open, args: { isLauncher: true } });
-    }
-
-    // Add toggle command to command palette if possible.
-    if (palette) {
-      palette.addItem({ command: CommandIDs.toggle, category: toggleLabel });
+      launcher.add({ command, args: { isLauncher: true } });
     }
 
     // Handle state restoration.
     if (restorer) {
-      void restorer.restore(tracker, {
-        command: CommandIDs.toggle,
-        name: () => 'inspector'
-      });
+      void restorer.restore(tracker, { command, name: () => 'inspector' });
     }
 
     // Create a proxy to pass the `source` to the current inspector.
-    const proxy = Object.defineProperty({} as IInspector, 'source', {
+    const proxy: IInspector = Object.defineProperty({}, 'source', {
       get: (): IInspector.IInspectable | null =>
         !inspector || inspector.isDisposed ? null : inspector.content.source,
       set: (src: IInspector.IInspectable | null) => {
@@ -187,9 +141,7 @@
  * An extension that registers consoles for inspection.
  */
 const consoles: JupyterFrontEndPlugin<void> = {
-  // FIXME This should be in @jupyterlab/console-extension
   id: '@jupyterlab/inspector-extension:consoles',
-  description: 'Adds code introspection support to consoles.',
   requires: [IInspector, IConsoleTracker, ILabShell],
   autoStart: true,
   activate: (
@@ -229,13 +181,16 @@
     });
 
     // Keep track of console instances and set inspector source.
-    const setSource = (widget: Widget | null): void => {
-      if (widget && consoles.has(widget) && handlers[widget.id]) {
-        manager.source = handlers[widget.id];
-      }
-    };
-    labShell.currentChanged.connect((_, args) => setSource(args.newValue));
-    void app.restored.then(() => setSource(labShell.currentWidget));
+    labShell.currentChanged.connect((_, args) => {
+      const widget = args.newValue;
+      if (!widget || !consoles.has(widget)) {
+        return;
+      }
+      const source = handlers[widget.id];
+      if (source) {
+        manager.source = source;
+      }
+    });
   }
 };
 
@@ -243,9 +198,7 @@
  * An extension that registers notebooks for inspection.
  */
 const notebooks: JupyterFrontEndPlugin<void> = {
-  // FIXME This should be in @jupyterlab/notebook-extension
   id: '@jupyterlab/inspector-extension:notebooks',
-  description: 'Adds code introspection to notebooks.',
   requires: [IInspector, INotebookTracker, ILabShell],
   autoStart: true,
   activate: (
@@ -273,11 +226,7 @@
 
       // Listen for active cell changes.
       parent.content.activeCellChanged.connect((sender, cell) => {
-        void cell?.ready.then(() => {
-          if (cell === parent.content.activeCell) {
-            handler.editor = cell!.editor;
-          }
-        });
+        handler.editor = cell && cell.editor;
       });
 
       // Listen for parent disposal.
@@ -288,13 +237,16 @@
     });
 
     // Keep track of notebook instances and set inspector source.
-    const setSource = (widget: Widget | null): void => {
-      if (widget && notebooks.has(widget) && handlers[widget.id]) {
-        manager.source = handlers[widget.id];
-      }
-    };
-    labShell.currentChanged.connect((_, args) => setSource(args.newValue));
-    void app.restored.then(() => setSource(labShell.currentWidget));
+    labShell.currentChanged.connect((sender, args) => {
+      const widget = args.newValue;
+      if (!widget || !notebooks.has(widget)) {
+        return;
+      }
+      const source = handlers[widget.id];
+      if (source) {
+        manager.source = source;
+      }
+    });
   }
 };
 