--- packages\codeeditor\test\editor.spec.ts (old)
+++ packages\codeeditor\test\editor.spec.ts (new)
@@ -2,14 +2,13 @@
 // Distributed under the terms of the Modified BSD License.
 
 import { CodeEditor } from '@jupyterlab/codeeditor';
-import { ISharedText, SourceChange, YFile } from '@jupyter/ydoc';
+import { IObservableString } from '@jupyterlab/observables';
 
 describe('CodeEditor.Model', () => {
   let model: CodeEditor.Model;
 
   beforeEach(() => {
-    const sharedModel = new YFile();
-    model = new CodeEditor.Model({ sharedModel });
+    model = new CodeEditor.Model();
   });
 
   afterEach(() => {
@@ -19,28 +18,24 @@
   describe('#constructor()', () => {
     it('should create a CodeEditor Model', () => {
       expect(model).toBeInstanceOf(CodeEditor.Model);
-      expect(model.sharedModel.getSource()).toBe('');
+      expect(model.value.text).toBe('');
     });
 
     it('should create a CodeEditor Model with an initial value', () => {
-      const sharedEditorModel = new YFile();
-      sharedEditorModel.setSource('Initial text here');
-      const other = new CodeEditor.Model({ sharedModel: sharedEditorModel });
+      const other = new CodeEditor.Model({ value: 'Initial text here' });
       expect(other).toBeInstanceOf(CodeEditor.Model);
-      expect(other.sharedModel.getSource()).toBe('Initial text here');
+      expect(other.value.text).toBe('Initial text here');
       other.dispose();
     });
 
     it('should create a CodeEditor Model with an initial mimetype', () => {
-      const sharedEditorModel = new YFile();
-      sharedEditorModel.setSource('import this');
       const other = new CodeEditor.Model({
-        sharedModel: sharedEditorModel,
+        value: 'import this',
         mimeType: 'text/x-python'
       });
       expect(other).toBeInstanceOf(CodeEditor.Model);
       expect(other.mimeType).toBe('text/x-python');
-      expect(other.sharedModel.getSource()).toBe('import this');
+      expect(other.value.text).toBe('import this');
       other.dispose();
     });
   });
@@ -62,40 +57,52 @@
   describe('#value', () => {
     it('should be the observable value of the model', () => {
       let called = false;
-      const handler = (sender: ISharedText, args: SourceChange) => {
-        expect(sender).toBe(model.sharedModel);
-        expect(args.sourceChange).toEqual([{ insert: 'foo' }]);
+      const handler = (
+        sender: IObservableString,
+        args: IObservableString.IChangedArgs
+      ) => {
+        expect(sender).toBe(model.value);
+        expect(args.type).toBe('set');
+        expect(args.value).toBe('foo');
         called = true;
       };
-      model.sharedModel.changed.connect(handler);
-      model.sharedModel.setSource('foo');
+      model.value.changed.connect(handler);
+      model.value.text = 'foo';
       expect(called).toBe(true);
-      model.sharedModel.changed.disconnect(handler);
+      model.value.changed.disconnect(handler);
     });
 
     it('should handle an insert', () => {
       let called = false;
-      const handler = (sender: ISharedText, args: SourceChange) => {
-        expect(args.sourceChange).toEqual([{ insert: 'foo' }]);
+      const handler = (
+        sender: IObservableString,
+        args: IObservableString.IChangedArgs
+      ) => {
+        expect(args.type).toBe('insert');
+        expect(args.value).toBe('foo');
         called = true;
       };
-      model.sharedModel.changed.connect(handler);
-      model.sharedModel.updateSource(0, 0, 'foo');
+      model.value.changed.connect(handler);
+      model.value.insert(0, 'foo');
       expect(called).toBe(true);
-      model.sharedModel.changed.disconnect(handler);
+      model.value.changed.disconnect(handler);
     });
 
     it('should handle a remove', () => {
       let called = false;
-      model.sharedModel.setSource('foo');
-      const handler = (sender: ISharedText, args: SourceChange) => {
-        expect(args.sourceChange).toEqual([{ delete: 1 }]);
+      model.value.text = 'foo';
+      const handler = (
+        sender: IObservableString,
+        args: IObservableString.IChangedArgs
+      ) => {
+        expect(args.type).toBe('remove');
+        expect(args.value).toBe('f');
         called = true;
       };
-      model.sharedModel.changed.connect(handler);
-      model.sharedModel.updateSource(0, 1);
+      model.value.changed.connect(handler);
+      model.value.remove(0, 1);
       expect(called).toBe(true);
-      model.sharedModel.changed.disconnect(handler);
+      model.value.changed.disconnect(handler);
     });
   });
 
@@ -113,6 +120,12 @@
     });
   });
 
+  describe('#modelDB', () => {
+    it('should get the modelDB object associated with the model', () => {
+      expect(model.modelDB.has('value')).toBe(true);
+    });
+  });
+
   describe('#isDisposed', () => {
     it('should test whether the model is disposed', () => {
       expect(model.isDisposed).toBe(false);