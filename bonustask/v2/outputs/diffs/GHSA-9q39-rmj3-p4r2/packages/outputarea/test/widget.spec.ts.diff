--- packages\outputarea\test\widget.spec.ts (old)
+++ packages\outputarea\test\widget.spec.ts (new)
@@ -2,20 +2,19 @@
 // Distributed under the terms of the Modified BSD License.
 
 import { SessionContext } from '@jupyterlab/apputils';
-import { createSessionContext } from '@jupyterlab/apputils/lib/testutils';
 import {
   IOutputAreaModel,
   OutputArea,
-  OutputAreaModel,
-  SimplifiedOutputArea,
-  Stdin
+  OutputAreaModel
 } from '@jupyterlab/outputarea';
-import { Kernel, KernelManager } from '@jupyterlab/services';
-import { JupyterServer, signalToPromise } from '@jupyterlab/testing';
+import { KernelManager } from '@jupyterlab/services';
 import {
-  DEFAULT_OUTPUTS,
-  defaultRenderMime
-} from '@jupyterlab/rendermime/lib/testutils';
+  createSessionContext,
+  defaultRenderMime,
+  flakyIt as it,
+  JupyterServer,
+  NBTestUtils
+} from '@jupyterlab/testutils';
 import { Message } from '@lumino/messaging';
 import { Widget } from '@lumino/widgets';
 import { simulate } from 'simulate-event';
@@ -44,26 +43,24 @@
   }
 }
 
+const server = new JupyterServer();
+
+beforeAll(async () => {
+  jest.setTimeout(20000);
+  await server.start();
+});
+
+afterAll(async () => {
+  await server.shutdown();
+});
+
 describe('outputarea/widget', () => {
-  let server: JupyterServer;
-
-  jest.retryTimes(3);
-
-  beforeAll(async () => {
-    server = new JupyterServer();
-    await server.start();
-  }, 30000);
-
-  afterAll(async () => {
-    await server.shutdown();
-  });
-
   let widget: LogOutputArea;
   let model: OutputAreaModel;
 
   beforeEach(() => {
     model = new OutputAreaModel({
-      values: DEFAULT_OUTPUTS,
+      values: NBTestUtils.DEFAULT_OUTPUTS,
       trusted: true
     });
     widget = new LogOutputArea({ rendermime, model });
@@ -122,14 +119,20 @@
 
           if (widget.widgets.length > maxNumberOutputs) {
             // eslint-disable-next-line jest/no-conditional-expect
-            expect(
-              widget.widgets[widget.widgets.length - 1].node.textContent
-            ).toContain('Show more outputs');
+            expect(widget.widgets[widget.widgets.length - 1].node.textContent)
+              .toContain(`
+          Output of this cell has been trimmed on the initial display.
+          Displaying the first 2 top outputs.
+          Click on this message to get the complete output.
+        `);
           } else {
             // eslint-disable-next-line jest/no-conditional-expect
-            expect(
-              widget.widgets[widget.widgets.length - 1].node.textContent
-            ).not.toContain('Show more outputs');
+            expect(widget.widgets[widget.widgets.length - 1].node.textContent)
+              .not.toContain(`
+          Output of this cell has been trimmed on the initial display.
+          Displaying the first 2 top outputs.
+          Click on this message to get the complete output.
+        `);
           }
         }
       );
@@ -189,79 +192,11 @@
       });
 
       it('should get the number of child widgets', () => {
-        expect(widget.widgets.length).toBe(DEFAULT_OUTPUTS.length - 1);
+        expect(widget.widgets.length).toBe(
+          NBTestUtils.DEFAULT_OUTPUTS.length - 1
+        );
         widget.model.clear();
         expect(widget.widgets.length).toBe(0);
-      });
-    });
-
-    describe('#pendingInput', () => {
-      let kernel: Kernel.IKernelConnection;
-
-      beforeEach(async () => {
-        const manager = new KernelManager();
-        kernel = await manager.startNew({ name: 'ipython' });
-      });
-
-      afterEach(async () => {
-        await kernel.shutdown();
-      });
-
-      it('should default to `false`', () => {
-        expect(widget.pendingInput).toBe(false);
-      });
-
-      it('should be `true` when pending user input', async () => {
-        // Prompt kernel to request input and wait until it is requested
-        const future = kernel.requestExecute({ code: 'input()' });
-        const inputRequested = signalToPromise(widget.inputRequested);
-        widget.future = future;
-        const input = (await inputRequested)[1];
-
-        // Input is now pending
-        expect(widget.pendingInput).toBe(true);
-
-        // Submit input
-        (input as Stdin).handleEvent(
-          new KeyboardEvent('keydown', { key: 'Enter' })
-        );
-        await future.done;
-
-        // Input should no longer be flagged as pending.
-        expect(widget.pendingInput).toBe(false);
-      });
-
-      it('should reset to `false` when kernel gets shut down', async () => {
-        const future = kernel.requestExecute({ code: 'input()' });
-        const inputRequested = signalToPromise(widget.inputRequested);
-        widget.future = future;
-        await inputRequested;
-        await kernel.shutdown();
-        expect(widget.pendingInput).toBe(false);
-      });
-
-      it('should reset to `false` when kernel restarts', async () => {
-        const future = kernel.requestExecute({ code: 'input()' });
-        const inputRequested = signalToPromise(widget.inputRequested);
-        widget.future = future;
-        await inputRequested;
-        await kernel.restart();
-        expect(widget.pendingInput).toBe(false);
-      });
-
-      it('should reset to `false` when kernel cancels input after getting interrupted', async () => {
-        // This test requires an ipython kernel because the default echo kernel
-        // does not actually do anything on getting interrupted.
-        const future = kernel.requestExecute({ code: 'input()' });
-        const inputRequested = signalToPromise(widget.inputRequested);
-        widget.future = future;
-        await inputRequested;
-        // Need to wait for status change because futures are not disposed on
-        // interrupt (differently to shutdown and restart).
-        const statusChanged = signalToPromise(kernel.statusChanged);
-        await kernel.interrupt();
-        await statusChanged;
-        expect(widget.pendingInput).toBe(false);
       });
     });
 
@@ -280,9 +215,9 @@
       });
 
       it('should execute code on a kernel and send outputs to the model', async () => {
-        const future = sessionContext.session!.kernel!.requestExecute({
+        const future = sessionContext.session?.kernel?.requestExecute({
           code: CODE
-        });
+        })!;
         widget.future = future;
         const reply = await future.done;
         expect(reply!.content.execution_count).toBeTruthy();
@@ -291,10 +226,10 @@
       });
 
       it('should clear existing outputs', async () => {
-        widget.model.fromJSON(DEFAULT_OUTPUTS);
-        const future = sessionContext.session!.kernel!.requestExecute({
+        widget.model.fromJSON(NBTestUtils.DEFAULT_OUTPUTS);
+        const future = sessionContext.session?.kernel?.requestExecute({
           code: CODE
-        });
+        })!;
         widget.future = future;
         const reply = await future.done;
         expect(reply!.content.execution_count).toBeTruthy();
@@ -306,7 +241,7 @@
       it('should handle an added output', () => {
         widget.model.clear();
         widget.methods = [];
-        widget.model.add(DEFAULT_OUTPUTS[0]);
+        widget.model.add(NBTestUtils.DEFAULT_OUTPUTS[0]);
         expect(widget.methods).toEqual(
           expect.arrayContaining(['onModelChanged'])
         );
@@ -314,7 +249,7 @@
       });
 
       it('should handle a clear', () => {
-        widget.model.fromJSON(DEFAULT_OUTPUTS);
+        widget.model.fromJSON(NBTestUtils.DEFAULT_OUTPUTS);
         widget.methods = [];
         widget.model.clear();
         expect(widget.methods).toEqual(
@@ -325,9 +260,9 @@
 
       it('should handle a set', () => {
         widget.model.clear();
-        widget.model.add(DEFAULT_OUTPUTS[0]);
+        widget.model.add(NBTestUtils.DEFAULT_OUTPUTS[0]);
         widget.methods = [];
-        widget.model.add(DEFAULT_OUTPUTS[0]);
+        widget.model.add(NBTestUtils.DEFAULT_OUTPUTS[0]);
         expect(widget.methods).toEqual(
           expect.arrayContaining(['onModelChanged'])
         );
@@ -409,7 +344,7 @@
       });
 
       it('should clear existing outputs', async () => {
-        widget.model.fromJSON(DEFAULT_OUTPUTS);
+        widget.model.fromJSON(NBTestUtils.DEFAULT_OUTPUTS);
         const reply = await OutputArea.execute(CODE, widget, sessionContext);
         expect(reply!.content.execution_count).toBeTruthy();
         expect(model.length).toBe(1);
@@ -508,27 +443,6 @@
         widget1.dispose();
         await ipySessionContext.shutdown();
       });
-
-      it('should continuously render delayed outputs', async () => {
-        const model0 = new OutputAreaModel({ trusted: true });
-        const widget0 = new SimplifiedOutputArea({
-          model: model0,
-          rendermime: rendermime
-        });
-        let ipySessionContext: SessionContext;
-        ipySessionContext = await createSessionContext({
-          kernelPreference: { name: 'python3' }
-        });
-        await ipySessionContext.initialize();
-        const code = [
-          'import time',
-          'for i in range(3):',
-          '    print(f"Hello Jupyter! {i}")',
-          '    time.sleep(1)'
-        ].join('\n');
-        await SimplifiedOutputArea.execute(code, widget0, ipySessionContext);
-        expect(model0.toJSON()[0].text).toBe(widget0.node.textContent);
-      });
     });
 
     describe('.ContentFactory', () => {
@@ -562,6 +476,21 @@
           await kernel.shutdown();
           kernel.dispose();
         });
+
+        it('should create a stdin widget without parent header', async () => {
+          const manager = new KernelManager();
+          const kernel = await manager.startNew();
+          const factory = new OutputArea.ContentFactory();
+          const future = kernel.requestExecute({ code: CODE });
+          const options = {
+            prompt: 'hello',
+            password: false,
+            future
+          };
+          expect(factory.createStdin(options)).toBeInstanceOf(Widget);
+          await kernel.shutdown();
+          kernel.dispose();
+        });
       });
     });
 