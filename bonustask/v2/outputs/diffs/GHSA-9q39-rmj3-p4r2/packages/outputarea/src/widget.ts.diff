--- packages\outputarea\src\widget.ts (old)
+++ packages\outputarea\src\widget.ts (new)
@@ -6,11 +6,6 @@
 import { IOutputModel, IRenderMimeRegistry } from '@jupyterlab/rendermime';
 import { IRenderMime } from '@jupyterlab/rendermime-interfaces';
 import { Kernel, KernelMessage } from '@jupyterlab/services';
-import {
-  ITranslator,
-  nullTranslator,
-  TranslationBundle
-} from '@jupyterlab/translation';
 import {
   JSONObject,
   PromiseDelegate,
@@ -20,8 +15,9 @@
 } from '@lumino/coreutils';
 import { Message } from '@lumino/messaging';
 import { AttachedProperty } from '@lumino/properties';
-import { ISignal, Signal } from '@lumino/signaling';
+import { Signal } from '@lumino/signaling';
 import { Panel, PanelLayout, Widget } from '@lumino/widgets';
+import ResizeObserver from 'resize-observer-polyfill';
 import { IOutputAreaModel } from './model';
 
 /**
@@ -44,8 +40,6 @@
  */
 const OUTPUT_AREA_PROMPT_CLASS = 'jp-OutputArea-prompt';
 
-const OUTPUT_AREA_STDIN_HIDING_CLASS = 'jp-OutputArea-stdin-hiding';
-
 /**
  * The class name added to OutputPrompt.
  */
@@ -75,11 +69,6 @@
  * The class name added to stdin data input nodes.
  */
 const STDIN_INPUT_CLASS = 'jp-Stdin-input';
-
-/**
- * The overlay that can be clicked to switch between output scrolling modes.
- */
-const OUTPUT_PROMPT_OVERLAY = 'jp-OutputArea-promptOverlay';
 
 /** ****************************************************************************
  * OutputArea
@@ -100,14 +89,13 @@
    */
   constructor(options: OutputArea.IOptions) {
     super();
-    super.layout = new PanelLayout();
     this.addClass(OUTPUT_AREA_CLASS);
+
     this.contentFactory =
-      options.contentFactory ?? OutputArea.defaultContentFactory;
+      options.contentFactory || OutputArea.defaultContentFactory;
+    this.layout = new PanelLayout();
     this.rendermime = options.rendermime;
     this._maxNumberOutputs = options.maxNumberOutputs ?? Infinity;
-    this._translator = options.translator ?? nullTranslator;
-    this._inputHistoryScope = options.inputHistoryScope ?? 'global';
 
     const model = (this.model = options.model);
     for (
@@ -120,9 +108,6 @@
     }
     model.changed.connect(this.onModelChanged, this);
     model.stateChanged.connect(this.onStateChanged, this);
-    if (options.promptOverlay) {
-      this._addPromptOverlay();
-    }
   }
 
   /**
@@ -131,6 +116,11 @@
   readonly contentFactory: OutputArea.IContentFactory;
 
   /**
+   * Narrow the type of OutputArea's layout prop
+   */
+  readonly layout: PanelLayout;
+
+  /**
    * The model used by the widget.
    */
   readonly model: IOutputAreaModel;
@@ -139,13 +129,6 @@
    * The rendermime instance used by the widget.
    */
   readonly rendermime: IRenderMimeRegistry;
-
-  /**
-   * Narrow the type of OutputArea's layout prop
-   */
-  get layout(): PanelLayout {
-    return super.layout as PanelLayout;
-  }
 
   /**
    * A read-only sequence of the children widgets in the output area.
@@ -155,7 +138,7 @@
   }
 
   /**
-   * A public signal used to indicate the number of displayed outputs has changed.
+   * A public signal used to indicate the number of outputs has changed.
    *
    * #### Notes
    * This is useful for parents who want to apply styling based on the number
@@ -191,23 +174,12 @@
     }
     this._future = value;
 
-    value.done
-      .finally(() => {
-        this._pendingInput = false;
-      })
-      .catch(() => {
-        // No-op, required because `finally` re-raises any rejections,
-        // even if caught on the `done` promise level before.
-      });
-
     this.model.clear();
 
     // Make sure there were no input widgets.
     if (this.widgets.length) {
       this._clear();
-      this.outputLengthChanged.emit(
-        Math.min(this.model.length, this._maxNumberOutputs)
-      );
+      this.outputLengthChanged.emit(this.model.length);
     }
 
     // Handle published messages.
@@ -222,22 +194,6 @@
         this.onInputRequest(msg, value);
       }
     };
-  }
-
-  /**
-   * Signal emitted when an output area is requesting an input. The signal
-   * carries the input widget that this class creates in response to the input
-   * request.
-   */
-  get inputRequested(): ISignal<OutputArea, IStdin> {
-    return this._inputRequested;
-  }
-
-  /**
-   * A flag indicating if the output area has pending input.
-   */
-  get pendingInput(): boolean {
-    return this._pendingInput;
   }
 
   /**
@@ -324,34 +280,8 @@
   }
 
   /**
-   * Emitted when user requests toggling of the output scrolling mode.
-   */
-  get toggleScrolling(): ISignal<OutputArea, void> {
-    return this._toggleScrolling;
-  }
-
-  get initialize(): ISignal<OutputArea, void> {
-    return this._initialize;
-  }
-
-  /**
-   * Add overlay allowing to toggle scrolling.
-   */
-  private _addPromptOverlay() {
-    const overlay = document.createElement('div');
-    overlay.className = OUTPUT_PROMPT_OVERLAY;
-    overlay.addEventListener('click', () => {
-      this._toggleScrolling.emit();
-    });
-    this.node.appendChild(overlay);
-    requestAnimationFrame(() => {
-      this._initialize.emit();
-    });
-  }
-
-  /**
    * Update indices in _displayIdMap in response to element remove from model items
-   *
+   * *
    * @param startIndex - The index of first element removed
    *
    * @param count - The number of elements removed from model items
@@ -378,27 +308,16 @@
   /**
    * Follow changes on the output model state.
    */
-  protected onStateChanged(
-    sender: IOutputAreaModel,
-    change: number | void
-  ): void {
+  protected onStateChanged(sender: IOutputAreaModel): void {
     const outputLength = Math.min(this.model.length, this._maxNumberOutputs);
-    if (change) {
-      if (change >= this._maxNumberOutputs) {
-        // Bail early
-        return;
-      }
-      this._setOutput(change, this.model.get(change));
-    } else {
-      for (let i = 0; i < outputLength; i++) {
-        this._setOutput(i, this.model.get(i));
-      }
+    for (let i = 0; i < outputLength; i++) {
+      this._setOutput(i, this.model.get(i));
     }
     this.outputLengthChanged.emit(outputLength);
   }
 
   /**
-   * Clear the widget outputs.
+   * Clear the widget inputs and outputs.
    */
   private _clear(): void {
     // Bail if there is no work to do.
@@ -460,16 +379,11 @@
     prompt.addClass(OUTPUT_AREA_PROMPT_CLASS);
     panel.addWidget(prompt);
 
-    // Indicate that input is pending
-    this._pendingInput = true;
-
     const input = factory.createStdin({
       parent_header: msg.header,
       prompt: stdinPrompt,
       password,
-      future,
-      translator: this._translator,
-      inputHistoryScope: this._inputHistoryScope
+      future
     });
     input.addClass(OUTPUT_AREA_OUTPUT_CLASS);
     panel.addWidget(input);
@@ -478,10 +392,7 @@
     if (this.model.length >= this.maxNumberOutputs) {
       this.maxNumberOutputs = this.model.length;
     }
-    this._inputRequested.emit(input);
-
-    // Get the input node to ensure focus after updating the model upon user reply.
-    const inputNode = input.node.getElementsByTagName('input')[0];
+    this.layout.addWidget(panel);
 
     /**
      * Wait for the stdin to complete, add it to the model (so it persists)
@@ -492,40 +403,14 @@
       if (this.model.length >= this.maxNumberOutputs) {
         this.maxNumberOutputs = this.model.length + 1;
       }
-      panel.addClass(OUTPUT_AREA_STDIN_HIDING_CLASS);
       // Use stdin as the stream so it does not get combined with stdout.
-      // Note: because it modifies DOM it may (will) shift focus away from the input node.
       this.model.add({
         output_type: 'stream',
         name: 'stdin',
         text: value + '\n'
       });
-      // Refocus the input node after it lost focus due to update of the model.
-      inputNode.focus();
-
-      // Indicate that input is no longer pending
-      this._pendingInput = false;
-
-      // Keep the input in view for a little while; this (along refocusing)
-      // ensures that we can avoid the cell editor stealing the focus, and
-      // leading to user inadvertently modifying editor content when executing
-      // consecutive commands in short succession.
-      window.setTimeout(() => {
-        // Tack currently focused element to ensure that it remains on it
-        // after disposal of the panel with the old input
-        // (which modifies DOM and can lead to focus jump).
-        const focusedElement = document.activeElement;
-        // Dispose the old panel with no longer needed input box.
-        panel.dispose();
-        // Refocus the element that was focused before.
-        if (focusedElement && focusedElement instanceof HTMLElement) {
-          focusedElement.focus();
-        }
-      }, 500);
+      panel.dispose();
     });
-
-    // Note: the `input.value` promise must be listened to before we attach the panel
-    this.layout.addWidget(panel);
   }
 
   /**
@@ -535,12 +420,12 @@
     if (index >= this._maxNumberOutputs) {
       return;
     }
+
     const panel = this.layout.widgets[index] as Panel;
-    const renderer = (
-      panel.widgets
-        ? panel.widgets.filter(it => 'renderModel' in it).pop()
-        : panel
-    ) as IRenderMime.IRenderer;
+    const renderer = (panel.widgets
+      ? panel.widgets[1]
+      : panel) as IRenderMime.IRenderer;
+
     // Check whether it is safe to reuse renderer:
     // - Preferred mime type has not changed
     // - Isolation has not changed
@@ -549,6 +434,7 @@
       model.trusted ? 'any' : 'ensure'
     );
     if (
+      renderer.renderModel &&
       Private.currentPreferredMimetype.get(renderer) === mimeType &&
       OutputArea.isIsolated(mimeType, model.metadata) ===
         renderer instanceof Private.IsolatedRenderer
@@ -570,7 +456,6 @@
     if (index > this._maxNumberOutputs) {
       return;
     }
-
     const layout = this.layout as PanelLayout;
 
     if (index === this._maxNumberOutputs) {
@@ -658,8 +543,7 @@
     output.renderModel(model).catch(error => {
       // Manually append error message to output
       const pre = document.createElement('pre');
-      const trans = this._translator.load('jupyterlab');
-      pre.textContent = trans.__('Javascript Error: %1', error.message);
+      pre.textContent = `Javascript Error: ${error.message}`;
       output.node.appendChild(pre);
 
       // Remove mime-type-specific CSS classes
@@ -682,6 +566,7 @@
     const transient = ((msg.content as any).transient || {}) as JSONObject;
     const displayId = transient['display_id'] as string;
     let targets: number[] | undefined;
+
     switch (msgType) {
       case 'execute_result':
       case 'display_data':
@@ -704,15 +589,6 @@
           }
         }
         break;
-      case 'status': {
-        const executionState = (msg as KernelMessage.IStatusMsg).content
-          .execution_state;
-        if (executionState === 'idle') {
-          // If status is idle, the kernel is no longer blocked by the input
-          this._pendingInput = false;
-        }
-        break;
-      }
       default:
         break;
     }
@@ -764,6 +640,7 @@
     executionCount: number | null = null
   ): Panel {
     const panel = new Private.OutputPanel();
+
     panel.addClass(OUTPUT_AREA_ITEM_CLASS);
 
     const prompt = this.contentFactory.createOutputPrompt();
@@ -776,26 +653,21 @@
     return panel;
   }
 
-  private _displayIdMap = new Map<string, number[]>();
+  private _minHeightTimeout: number | null = null;
   private _future: Kernel.IShellFuture<
     KernelMessage.IExecuteRequestMsg,
     KernelMessage.IExecuteReplyMsg
   >;
-  /**
-   * The maximum outputs to show in the trimmed
-   * output area.
-   */
-  private _maxNumberOutputs: number;
-  private _minHeightTimeout: number | null = null;
-  private _inputRequested = new Signal<OutputArea, IStdin>(this);
-  private _toggleScrolling = new Signal<OutputArea, void>(this);
-  private _initialize = new Signal<OutputArea, void>(this);
+  private _displayIdMap = new Map<string, number[]>();
   private _outputTracker = new WidgetTracker<Widget>({
     namespace: UUID.uuid4()
   });
-  private _translator: ITranslator;
-  private _inputHistoryScope: 'global' | 'session' = 'global';
-  private _pendingInput: boolean = false;
+
+  /**
+   * The maximum outputs to show in the trimmed
+   * output area.
+   */
+  private _maxNumberOutputs: number;
 }
 
 export class SimplifiedOutputArea extends OutputArea {
@@ -814,17 +686,10 @@
    */
   protected createOutputItem(model: IOutputModel): Widget | null {
     const output = this.createRenderedMimetype(model);
-
-    if (!output) {
-      return null;
-    }
-
-    const panel = new Private.OutputPanel();
-    panel.addClass(OUTPUT_AREA_ITEM_CLASS);
-
-    output.addClass(OUTPUT_AREA_OUTPUT_CLASS);
-    panel.addWidget(output);
-    return panel;
+    if (output) {
+      output.addClass(OUTPUT_AREA_OUTPUT_CLASS);
+    }
+    return output;
   }
 }
 
@@ -855,21 +720,6 @@
      * The maximum number of output items to display on top and bottom of cell output.
      */
     maxNumberOutputs?: number;
-
-    /**
-     * Whether to show prompt overlay emitting `toggleScrolling` signal.
-     */
-    promptOverlay?: boolean;
-
-    /**
-     * Translator
-     */
-    readonly translator?: ITranslator;
-
-    /**
-     * Whether to split stdin line history by kernel session or keep globally accessible.
-     */
-    inputHistoryScope?: 'global' | 'session';
   }
 
   /**
@@ -1023,82 +873,24 @@
  * The default stdin widget.
  */
 export class Stdin extends Widget implements IStdin {
-  private static _history: Map<string, string[]> = new Map();
-
-  private static _historyIx(key: string, ix: number): number | undefined {
-    const history = Stdin._history.get(key);
-    if (!history) {
-      return undefined;
-    }
-    const len = history.length;
-    // wrap nonpositive ix to nonnegative ix
-    if (ix <= 0) {
-      return len + ix;
-    }
-  }
-
-  private static _historyAt(key: string, ix: number): string | undefined {
-    const history = Stdin._history.get(key);
-    if (!history) {
-      return undefined;
-    }
-    const len = history.length;
-    const ixpos = Stdin._historyIx(key, ix);
-
-    if (ixpos !== undefined && ixpos < len) {
-      return history[ixpos];
+  private static _history: string[] = [];
+
+  private static _historyAt(ix: number): string | undefined {
+    const len = Stdin._history.length;
+    // interpret negative ix exactly like Array.at
+    ix = ix < 0 ? len + ix : ix;
+
+    if (ix < len) {
+      return Stdin._history[ix];
     }
     // return undefined if ix is out of bounds
   }
 
-  private static _historyPush(key: string, line: string): void {
-    const history = Stdin._history.get(key)!;
-    history.push(line);
-    if (history.length > 1000) {
+  private static _historyPush(line: string): void {
+    Stdin._history.push(line);
+    if (Stdin._history.length > 1000) {
       // truncate line history if it's too long
-      history.shift();
-    }
-  }
-
-  private static _historySearch(
-    key: string,
-    pat: string,
-    ix: number,
-    reverse = true
-  ): number | undefined {
-    const history = Stdin._history.get(key)!;
-    const len = history.length;
-    const ixpos = Stdin._historyIx(key, ix);
-    const substrFound = (x: string) => x.search(pat) !== -1;
-
-    if (ixpos === undefined) {
-      return;
-    }
-
-    if (reverse) {
-      if (ixpos === 0) {
-        // reverse search fails if already at start of history
-        return;
-      }
-
-      const ixFound = (history.slice(0, ixpos) as any).findLastIndex(
-        substrFound
-      );
-      if (ixFound !== -1) {
-        // wrap ix to negative
-        return ixFound - len;
-      }
-    } else {
-      if (ixpos >= len - 1) {
-        // forward search fails if already at end of history
-        return;
-      }
-
-      const ixFound = history.slice(ixpos + 1).findIndex(substrFound);
-      if (ixFound !== -1) {
-        // wrap ix to negative and adjust for slice
-        return ixFound - len + ixpos + 1;
-      }
+      Stdin._history.shift();
     }
   }
 
@@ -1110,32 +902,15 @@
       node: Private.createInputWidgetNode(options.prompt, options.password)
     });
     this.addClass(STDIN_CLASS);
+    this._history_ix = 0;
+    this._input = this.node.getElementsByTagName('input')[0];
+    this._input.focus();
+    // make users aware of the line history feature
+    this._input.placeholder = '↑↓ for history';
     this._future = options.future;
-    this._historyIndex = 0;
-    this._historyKey =
-      options.inputHistoryScope === 'session'
-        ? options.parent_header.session
-        : '';
-    this._historyPat = '';
     this._parentHeader = options.parent_header;
+    this._value = options.prompt + ' ';
     this._password = options.password;
-    this._trans = (options.translator ?? nullTranslator).load('jupyterlab');
-    this._value = options.prompt + ' ';
-
-    this._input = this.node.getElementsByTagName('input')[0];
-    // make users aware of the line history feature
-    if (!this._password) {
-      this._input.placeholder = this._trans.__(
-        '↑↓ for history. Search history with c-↑/c-↓'
-      );
-    } else {
-      this._input.placeholder = '';
-    }
-
-    // initialize line history
-    if (!Stdin._history.has(this._historyKey)) {
-      Stdin._history.set(this._historyKey, []);
-    }
   }
 
   /**
@@ -1156,17 +931,34 @@
    * not be called directly by user code.
    */
   handleEvent(event: KeyboardEvent): void {
-    if (this._resolved) {
-      // Do not handle any more key events if the promise was resolved.
-      event.preventDefault();
-      return;
-    }
     const input = this._input;
-
     if (event.type === 'keydown') {
-      if (event.key === 'Enter') {
-        this.resetSearch();
-
+      if (event.key === 'ArrowUp') {
+        const historyLine = Stdin._historyAt(this._history_ix - 1);
+        if (historyLine) {
+          if (this._history_ix === 0) {
+            this._value_cache = input.value;
+          }
+          this._setInputValue(historyLine);
+          --this._history_ix;
+          // The default action for ArrowUp is moving to first character
+          // but we want to keep the cursor at the end.
+          event.preventDefault();
+        }
+      } else if (event.key === 'ArrowDown') {
+        if (this._history_ix === 0) {
+          // do nothing
+        } else if (this._history_ix === -1) {
+          this._setInputValue(this._value_cache);
+          ++this._history_ix;
+        } else {
+          const historyLine = Stdin._historyAt(this._history_ix + 1);
+          if (historyLine) {
+            this._setInputValue(historyLine);
+            ++this._history_ix;
+          }
+        }
+      } else if (event.key === 'Enter') {
         this._future.sendInputReply(
           {
             status: 'ok',
@@ -1178,89 +970,11 @@
           this._value += '········';
         } else {
           this._value += input.value;
-          Stdin._historyPush(this._historyKey, input.value);
+          Stdin._historyPush(input.value);
         }
-        this._resolved = true;
         this._promise.resolve(void 0);
-      } else if (event.key === 'Escape') {
-        // currently this gets clobbered by the documentsearch:end command at the notebook level
-        this.resetSearch();
-        input.blur();
-      } else if (
-        event.ctrlKey &&
-        (event.key === 'ArrowUp' || event.key === 'ArrowDown')
-      ) {
-        // if _historyPat is blank, use input as search pattern. Otherwise, reuse the current search pattern
-        if (this._historyPat === '') {
-          this._historyPat = input.value;
-        }
-
-        const reverse = event.key === 'ArrowUp';
-        const searchHistoryIx = Stdin._historySearch(
-          this._historyKey,
-          this._historyPat,
-          this._historyIndex,
-          reverse
-        );
-
-        if (searchHistoryIx !== undefined) {
-          const historyLine = Stdin._historyAt(
-            this._historyKey,
-            searchHistoryIx
-          );
-          if (historyLine !== undefined) {
-            if (this._historyIndex === 0) {
-              this._valueCache = input.value;
-            }
-
-            this._setInputValue(historyLine);
-            this._historyIndex = searchHistoryIx;
-            // The default action for ArrowUp is moving to first character
-            // but we want to keep the cursor at the end.
-            event.preventDefault();
-          }
-        }
-      } else if (event.key === 'ArrowUp') {
-        this.resetSearch();
-
-        const historyLine = Stdin._historyAt(
-          this._historyKey,
-          this._historyIndex - 1
-        );
-        if (historyLine) {
-          if (this._historyIndex === 0) {
-            this._valueCache = input.value;
-          }
-          this._setInputValue(historyLine);
-          --this._historyIndex;
-          // The default action for ArrowUp is moving to first character
-          // but we want to keep the cursor at the end.
-          event.preventDefault();
-        }
-      } else if (event.key === 'ArrowDown') {
-        this.resetSearch();
-
-        if (this._historyIndex === 0) {
-          // do nothing
-        } else if (this._historyIndex === -1) {
-          this._setInputValue(this._valueCache);
-          ++this._historyIndex;
-        } else {
-          const historyLine = Stdin._historyAt(
-            this._historyKey,
-            this._historyIndex + 1
-          );
-          if (historyLine) {
-            this._setInputValue(historyLine);
-            ++this._historyIndex;
-          }
-        }
       }
     }
-  }
-
-  protected resetSearch(): void {
-    this._historyPat = '';
   }
 
   /**
@@ -1268,6 +982,13 @@
    */
   protected onAfterAttach(msg: Message): void {
     this._input.addEventListener('keydown', this);
+    this.update();
+  }
+
+  /**
+   * Handle `update-request` messages sent to the widget.
+   */
+  protected onUpdateRequest(msg: Message): void {
     this._input.focus();
   }
 
@@ -1285,18 +1006,14 @@
     this._input.setSelectionRange(value.length, value.length);
   }
 
+  private _history_ix: number;
+  private _parentHeader?: KernelMessage.IInputReplyMsg['parent_header'];
   private _future: Kernel.IShellFuture;
-  private _historyIndex: number;
-  private _historyKey: string;
-  private _historyPat: string;
   private _input: HTMLInputElement;
-  private _parentHeader: KernelMessage.IInputReplyMsg['parent_header'];
+  private _value: string;
+  private _value_cache: string;
+  private _promise = new PromiseDelegate<void>();
   private _password: boolean;
-  private _promise = new PromiseDelegate<void>();
-  private _trans: TranslationBundle;
-  private _value: string;
-  private _valueCache: string;
-  private _resolved: boolean = false;
 }
 
 export namespace Stdin {
@@ -1322,17 +1039,7 @@
     /**
      * The header of the input_request message.
      */
-    parent_header: KernelMessage.IInputReplyMsg['parent_header'];
-
-    /**
-     * Translator
-     */
-    readonly translator?: ITranslator;
-
-    /**
-     * Whether to split stdin line history by kernel session or keep globally accessible.
-     */
-    inputHistoryScope?: 'global' | 'session';
+    parent_header?: KernelMessage.IInputReplyMsg['parent_header'];
   }
 }
 
@@ -1370,8 +1077,7 @@
    */
   export class IsolatedRenderer
     extends Widget
-    implements IRenderMime.IRenderer
-  {
+    implements IRenderMime.IRenderer {
     /**
      * Create an isolated renderer.
      */
@@ -1485,19 +1191,19 @@
      * The widget will be disposed on click after calling the callback.
      *
      * @param maxNumberOutputs Maximal number of outputs to display
-     * @param _onClick Callback on click event on the widget
+     * @param onClick Callback on click event on the widget
      */
     constructor(
       maxNumberOutputs: number,
       onClick: (event: MouseEvent) => void
     ) {
       const node = document.createElement('div');
-      const title = `The first ${maxNumberOutputs} are displayed`;
-      const msg = 'Show more outputs';
       node.insertAdjacentHTML(
         'afterbegin',
-        `<a title=${title}>
-          <pre>${msg}</pre>
+        `<a>
+          <pre>Output of this cell has been trimmed on the initial display.</pre>
+          <pre>Displaying the first ${maxNumberOutputs} top outputs.</pre>
+          <pre>Click on this message to get the complete output.</pre>
         </a>`
       );
       super({