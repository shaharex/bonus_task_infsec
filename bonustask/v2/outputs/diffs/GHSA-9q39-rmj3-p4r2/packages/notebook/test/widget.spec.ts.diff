--- packages\notebook\test\widget.spec.ts (old)
+++ packages\notebook\test\widget.spec.ts (new)
@@ -10,28 +10,21 @@
   RawCell,
   RawCellModel
 } from '@jupyterlab/cells';
-import {
-  INotebookModel,
-  Notebook,
-  NotebookModel,
-  StaticNotebook
-} from '@jupyterlab/notebook';
-import {
-  framePromise,
-  JupyterServer,
-  signalToPromise,
-  sleep
-} from '@jupyterlab/testing';
+import { framePromise } from '@jupyterlab/testutils';
+import { JupyterServer } from '@jupyterlab/testutils/lib/start_jupyter_server';
 import { Message, MessageLoop } from '@lumino/messaging';
 import { Widget } from '@lumino/widgets';
 import { generate, simulate } from 'simulate-event';
+import * as nbformat from '@jupyterlab/nbformat';
+import { INotebookModel, Notebook, NotebookModel, StaticNotebook } from '..';
 import * as utils from './utils';
 
 const server = new JupyterServer();
 
 beforeAll(async () => {
+  jest.setTimeout(20000);
   await server.start();
-}, 30000);
+});
 
 afterAll(async () => {
   await server.shutdown();
@@ -40,9 +33,21 @@
 const contentFactory = utils.createNotebookFactory();
 const editorConfig = utils.defaultEditorConfig;
 const rendermime = utils.defaultRenderMime();
-const notebookConfig: StaticNotebook.INotebookConfig = {
-  ...StaticNotebook.defaultNotebookConfig,
-  windowingMode: 'none'
+const notebookConfig = {
+  scrollPastEnd: true,
+  defaultCell: 'code' as nbformat.CellType,
+  recordTiming: false,
+  numberCellsToRenderDirectly: 9999,
+  remainingTimeBeforeRescheduling: 50,
+  renderCellOnIdle: true,
+  observedTopMargin: '1000px',
+  observedBottomMargin: '1000px',
+  maxNumberOutputs: 50,
+  disableDocumentWideUndoRedo: true,
+  renderingLayout: 'default' as 'default' | 'side-by-side',
+  sideBySideLeftMarginOverride: '10px',
+  sideBySideRightMarginOverride: '10px',
+  sideBySideOutputRatio: 1
 };
 
 const options: Notebook.IOptions = {
@@ -86,6 +91,11 @@
     this.methods.push('onCellInserted');
   }
 
+  protected onCellMoved(fromIndex: number, toIndex: number): void {
+    super.onCellMoved(fromIndex, toIndex);
+    this.methods.push('onCellMoved');
+  }
+
   protected onCellRemoved(index: number, cell: Cell): void {
     super.onCellRemoved(index, cell);
     this.methods.push('onCellRemoved');
@@ -125,6 +135,11 @@
   protected onCellInserted(index: number, cell: Cell): void {
     super.onCellInserted(index, cell);
     this.methods.push('onCellInserted');
+  }
+
+  protected onCellMoved(fromIndex: number, toIndex: number): void {
+    super.onCellMoved(fromIndex, toIndex);
+    this.methods.push('onCellMoved');
   }
 
   protected onCellRemoved(index: number, cell: Cell): void {
@@ -141,7 +156,7 @@
 }
 
 function selected(nb: Notebook): number[] {
-  const selected: number[] = [];
+  const selected = [];
   const cells = nb.widgets;
   for (let i = 0; i < cells.length; i++) {
     if (nb.isSelected(cells[i])) {
@@ -198,7 +213,8 @@
         widget.modelContentChanged.connect(() => {
           called = true;
         });
-        widget.model!.sharedModel.insertCell(0, { cell_type: 'code' });
+        const cell = widget.model!.contentFactory.createCodeCell({});
+        widget.model!.cells.push(cell);
         expect(called).toBe(true);
       });
 
@@ -209,7 +225,7 @@
         widget.modelContentChanged.connect(() => {
           called = true;
         });
-        widget.model!.setMetadata('foo', 1);
+        widget.model!.metadata.set('foo', 1);
         expect(called).toBe(true);
       });
     });
@@ -263,7 +279,6 @@
         const widget = new LogStaticNotebook(options);
         const model1 = new NotebookModel();
         expect(model1.cells.length).toBe(0);
-
         widget.model = model1;
         expect(model1.cells.length).toBe(1);
         expect(model1.cells.get(0).type).toBe('code');
@@ -272,11 +287,8 @@
           ...widget.notebookConfig,
           defaultCell: 'markdown'
         };
-        const model2 = new NotebookModel({
-          defaultCell: 'markdown'
-        });
+        const model2 = new NotebookModel();
         expect(model2.cells.length).toBe(0);
-
         widget.model = model2;
         expect(model2.cells.length).toBe(1);
         expect(model2.cells.get(0).type).toBe('markdown');
@@ -286,7 +298,7 @@
         const widget = new LogStaticNotebook(options);
         const model = new NotebookModel();
         const value = { name: 'python', codemirror_mode: 'python' };
-        model.setMetadata('language_info', value);
+        model.metadata.set('language_info', value);
         widget.model = model;
         const child = widget.widgets[0];
         expect(child.model.mimeType).toBe('text/x-python');
@@ -306,9 +318,9 @@
 
         it('should handle changes to the model cell list', async () => {
           widget = createWidget();
-          widget.model!.sharedModel.insertCell(
+          widget.model!.cells.insert(
             widget.model!.sharedModel.cells.length,
-            { cell_type: 'code' }
+            widget.model!.contentFactory.createCell('code', {})
           );
           await framePromise();
           expect(widget.widgets.length).toBe(2);
@@ -317,42 +329,46 @@
         it('should handle a remove', () => {
           const cell = widget.model!.cells.get(1);
           const child = widget.widgets[1];
-          widget.model!.sharedModel.deleteCell(1);
-          expect(cell.isDisposed).toBe(true);
+          widget.model!.cells.removeValue(cell);
+          expect(cell.isDisposed).toBe(false);
           expect(child.isDisposed).toBe(true);
         });
 
         it('should handle an add', () => {
-          widget.model!.sharedModel.insertCell(0, { cell_type: 'code' });
+          const cell = widget.model!.contentFactory.createCodeCell({});
+          widget.model!.cells.push(cell);
           expect(widget.widgets.length).toBe(widget.model!.cells.length);
           const child = widget.widgets[0];
           expect(child.hasClass('jp-Notebook-cell')).toBe(true);
         });
 
         it('should initially render markdown cells with content', () => {
-          widget.model!.sharedModel.insertCells(0, [
-            { cell_type: 'markdown', source: '# Hello' },
-            { cell_type: 'markdown' }
-          ]);
+          const cell1 = widget.model!.contentFactory.createMarkdownCell({});
+          const cell2 = widget.model!.contentFactory.createMarkdownCell({});
+          cell1.value.text = '# Hello';
+          widget.model!.cells.push(cell1);
+          widget.model!.cells.push(cell2);
           expect(widget.widgets.length).toBe(widget.model!.cells.length);
-          const child1 = widget.widgets[0] as MarkdownCell;
-          const child2 = widget.widgets[1] as MarkdownCell;
+          const child1 = widget.widgets[
+            widget.model!.cells.length - 2
+          ] as MarkdownCell;
+          const child2 = widget.widgets[
+            widget.model!.cells.length - 1
+          ] as MarkdownCell;
           expect(child1.rendered).toBe(true);
           expect(child2.rendered).toBe(false);
         });
 
         it('should handle a move', () => {
           const child = widget.widgets[1];
-          widget.model!.sharedModel.moveCell(1, 2);
-          expect(widget.widgets[2].id).toBe(child.id);
+          widget.model!.cells.move(1, 2);
+          expect(widget.widgets[2]).toBe(child);
         });
 
         it('should handle a clear', () => {
-          widget.model!.sharedModel.insertCell(0, { cell_type: 'code' });
-          widget.model!.sharedModel.deleteCellRange(
-            0,
-            widget.model!.sharedModel.cells.length
-          );
+          const cell = widget.model!.contentFactory.createCodeCell({});
+          widget.model!.cells.push(cell);
+          widget.model!.cells.clear();
           expect(widget.widgets.length).toBe(0);
         });
       });
@@ -382,7 +398,7 @@
 
       it('should be settable', () => {
         const widget = createWidget();
-        expect(widget.widgets[0].editor!.getOption('autoClosingBrackets')).toBe(
+        expect(widget.widgets[0].editor.getOption('autoClosingBrackets')).toBe(
           false
         );
         const newConfig = {
@@ -394,7 +410,7 @@
           }
         };
         widget.editorConfig = newConfig;
-        expect(widget.widgets[0].editor!.getOption('autoClosingBrackets')).toBe(
+        expect(widget.widgets[0].editor.getOption('autoClosingBrackets')).toBe(
           true
         );
       });
@@ -410,7 +426,7 @@
         const widget = new LogStaticNotebook(options);
         const model = new NotebookModel();
         const value = { name: 'python', codemirror_mode: 'python' };
-        model.setMetadata('language_info', value);
+        model.metadata.set('language_info', value);
         widget.model = model;
         expect(widget.codeMimetype).toBe('text/x-python');
       });
@@ -452,36 +468,6 @@
       });
     });
 
-    describe('#moveCell()', () => {
-      it('should preserve isDirty state after moving a code cell', () => {
-        const widget = createWidget();
-        widget.model!.sharedModel.insertCells(0, [
-          { cell_type: 'code' },
-          { cell_type: 'code' }
-        ]);
-        (widget.widgets[0].model as CodeCellModel).isDirty = true;
-        widget.moveCell(0, 1);
-        expect((widget.widgets[1].model as CodeCellModel).isDirty).toBe(true);
-      });
-
-      it('should preserve isDirty state after moving multiple code cells', () => {
-        const widget = createWidget();
-        widget.model!.sharedModel.insertCells(0, [
-          { cell_type: 'code' },
-          { cell_type: 'code' },
-          { cell_type: 'code' },
-          { cell_type: 'code' },
-          { cell_type: 'code' }
-        ]);
-        (widget.widgets[0].model as CodeCellModel).isDirty = true;
-        (widget.widgets[2].model as CodeCellModel).isDirty = true;
-        widget.moveCell(0, 4, 3);
-        expect((widget.widgets[2].model as CodeCellModel).isDirty).toBe(true);
-        expect((widget.widgets[3].model as CodeCellModel).isDirty).toBe(false);
-        expect((widget.widgets[4].model as CodeCellModel).isDirty).toBe(true);
-      });
-    });
-
     describe('#onModelChanged()', () => {
       it('should be called when the model changes', () => {
         const widget = new LogStaticNotebook(options);
@@ -504,7 +490,7 @@
     describe('#onMetadataChanged()', () => {
       it('should be called when the metadata on the notebook changes', () => {
         const widget = createWidget();
-        widget.model!.setMetadata('foo', 1);
+        widget.model!.metadata.set('foo', 1);
         expect(widget.methods).toEqual(
           expect.arrayContaining(['onMetadataChanged'])
         );
@@ -513,7 +499,7 @@
       it('should update the `codeMimetype`', () => {
         const widget = createWidget();
         const value = { name: 'python', codemirror_mode: 'python' };
-        widget.model!.setMetadata('language_info', value);
+        widget.model!.metadata.set('language_info', value);
         expect(widget.methods).toEqual(
           expect.arrayContaining(['onMetadataChanged'])
         );
@@ -523,7 +509,7 @@
       it('should update the cell widget mimetype', () => {
         const widget = createWidget();
         const value = { name: 'python', mimetype: 'text/x-python' };
-        widget.model!.setMetadata('language_info', value);
+        widget.model!.metadata.set('language_info', value);
         expect(widget.methods).toEqual(
           expect.arrayContaining(['onMetadataChanged'])
         );
@@ -542,10 +528,20 @@
       });
     });
 
+    describe('#onCellMoved()', () => {
+      it('should be called when a cell is moved', () => {
+        const widget = createWidget();
+        widget.model!.fromJSON(utils.DEFAULT_CONTENT);
+        widget.model!.cells.move(0, 1);
+        expect(widget.methods).toEqual(expect.arrayContaining(['onCellMoved']));
+      });
+    });
+
     describe('#onCellRemoved()', () => {
       it('should be called when a cell is removed', () => {
         const widget = createWidget();
-        widget.model!.sharedModel.deleteCell(0);
+        const cell = widget.model!.cells.get(0);
+        widget.model!.cells.removeValue(cell);
         expect(widget.methods).toEqual(
           expect.arrayContaining(['onCellRemoved'])
         );
@@ -563,36 +559,33 @@
 
       describe('#createCodeCell({})', () => {
         it('should create a `CodeCell`', () => {
-          const contentFactory = new StaticNotebook.ContentFactory({
-            editorFactory: utils.editorFactory
-          });
-          const model = new CodeCellModel();
+          const contentFactory = new StaticNotebook.ContentFactory();
+          const model = new CodeCellModel({});
           const codeOptions = { model, rendermime, contentFactory };
-          const widget = contentFactory.createCodeCell(codeOptions);
+          const parent = new StaticNotebook(options);
+          const widget = contentFactory.createCodeCell(codeOptions, parent);
           expect(widget).toBeInstanceOf(CodeCell);
         });
       });
 
       describe('#createMarkdownCell({})', () => {
         it('should create a `MarkdownCell`', () => {
-          const contentFactory = new StaticNotebook.ContentFactory({
-            editorFactory: utils.editorFactory
-          });
-          const model = new MarkdownCellModel();
+          const contentFactory = new StaticNotebook.ContentFactory();
+          const model = new MarkdownCellModel({});
           const mdOptions = { model, rendermime, contentFactory };
-          const widget = contentFactory.createMarkdownCell(mdOptions);
+          const parent = new StaticNotebook(options);
+          const widget = contentFactory.createMarkdownCell(mdOptions, parent);
           expect(widget).toBeInstanceOf(MarkdownCell);
         });
       });
 
       describe('#createRawCell()', () => {
         it('should create a `RawCell`', () => {
-          const contentFactory = new StaticNotebook.ContentFactory({
-            editorFactory: utils.editorFactory
-          });
-          const model = new RawCellModel();
+          const contentFactory = new StaticNotebook.ContentFactory();
+          const model = new RawCellModel({});
           const rawOptions = { model, contentFactory };
-          const widget = contentFactory.createRawCell(rawOptions);
+          const parent = new StaticNotebook(options);
+          const widget = contentFactory.createRawCell(rawOptions, parent);
           expect(widget).toBeInstanceOf(RawCell);
         });
       });
@@ -731,13 +724,12 @@
         const widget = createActiveWidget();
         Widget.attach(widget, document.body);
         MessageLoop.sendMessage(widget, Widget.Msg.ActivateRequest);
-        widget.model!.sharedModel.insertCell(0, {
-          cell_type: 'markdown',
-          source: '# Hello'
-        }); // Should be rendered with content.
-        const child = widget.widgets[0] as MarkdownCell;
+        const cell = widget.model!.contentFactory.createMarkdownCell({});
+        cell.value.text = '# Hello'; // Should be rendered with content.
+        widget.model!.cells.push(cell);
+        const child = widget.widgets[widget.widgets.length - 1] as MarkdownCell;
         expect(child.rendered).toBe(true);
-        widget.activeCellIndex = 0;
+        widget.activeCellIndex = widget.widgets.length - 1;
         widget.mode = 'edit';
         expect(child.rendered).toBe(false);
       });
@@ -998,86 +990,65 @@
         const widget = createActiveWidget();
         widget.model!.fromJSON(utils.DEFAULT_CONTENT);
 
-        expect(() => {
-          permutations.forEach(p => {
-            checkSelection(widget, p[0], p[1], p[2]);
-          });
-        }).not.toThrow();
+        permutations.forEach(p => {
+          checkSelection(widget, p[0], p[1], p[2]);
+        });
       });
 
       it('should work when we only have an active cell, with no existing selection', () => {
         const widget = createActiveWidget();
         widget.model!.fromJSON(utils.DEFAULT_CONTENT);
 
-        expect(() => {
-          permutations.forEach(p => {
-            if (p[0] === p[1]) {
-              checkSelection(widget, p[0], p[1], p[2], false);
-            }
-          });
-        }).not.toThrow();
+        permutations.forEach(p => {
+          if (p[0] === p[1]) {
+            checkSelection(widget, p[0], p[1], p[2], false);
+          }
+        });
       });
 
       it('should clip when the index is greater than the last index', () => {
         const widget = createActiveWidget();
         widget.model!.fromJSON(utils.DEFAULT_CONTENT);
 
-        expect(() => {
-          permutations.forEach(p => {
-            checkSelection(widget, p[0], p[1], Number.MAX_SAFE_INTEGER);
-          });
-        }).not.toThrow();
+        permutations.forEach(p => {
+          checkSelection(widget, p[0], p[1], Number.MAX_SAFE_INTEGER);
+        });
       });
 
       it('should clip when the index is greater than the last index with no existing selection', () => {
         const widget = createActiveWidget();
         widget.model!.fromJSON(utils.DEFAULT_CONTENT);
 
-        expect(() => {
-          permutations.forEach(p => {
-            if (p[0] === p[1]) {
-              checkSelection(
-                widget,
-                p[0],
-                p[1],
-                Number.MAX_SAFE_INTEGER,
-                false
-              );
-            }
-          });
-        }).not.toThrow();
+        permutations.forEach(p => {
+          if (p[0] === p[1]) {
+            checkSelection(widget, p[0], p[1], Number.MAX_SAFE_INTEGER, false);
+          }
+        });
       });
 
       it('should clip when the index is less than 0', () => {
         const widget = createActiveWidget();
         widget.model!.fromJSON(utils.DEFAULT_CONTENT);
 
-        expect(() => {
-          permutations.forEach(p => {
-            checkSelection(widget, p[0], p[1], -10);
-          });
-        }).not.toThrow();
+        permutations.forEach(p => {
+          checkSelection(widget, p[0], p[1], -10);
+        });
       });
 
       it('should clip when the index is less than 0 with no existing selection', () => {
         const widget = createActiveWidget();
         widget.model!.fromJSON(utils.DEFAULT_CONTENT);
 
-        expect(() => {
-          permutations.forEach(p => {
-            if (p[0] === p[1]) {
-              checkSelection(widget, p[0], p[1], -10, false);
-            }
-          });
-        }).not.toThrow();
+        permutations.forEach(p => {
+          if (p[0] === p[1]) {
+            checkSelection(widget, p[0], p[1], -10, false);
+          }
+        });
       });
 
       it('handles the case of no cells', () => {
         const widget = createActiveWidget();
-        widget.model!.sharedModel.deleteCellRange(
-          0,
-          widget.model!.sharedModel.cells.length
-        );
+        widget.model!.cells.clear();
         expect(widget.widgets.length).toBe(0);
 
         // Set up a selection event listener.
@@ -1102,7 +1073,7 @@
         widget.select(widget.widgets[3]);
         widget.activeCellIndex = 3;
 
-        expect(() => widget.getContiguousSelection()).toThrow(
+        expect(() => widget.getContiguousSelection()).toThrowError(
           /Selection not contiguous/
         );
       });
@@ -1117,13 +1088,13 @@
 
         // Check if active cell is outside selection.
         widget.activeCellIndex = 0;
-        expect(() => widget.getContiguousSelection()).toThrow(
+        expect(() => widget.getContiguousSelection()).toThrowError(
           /Active cell not at endpoint of selection/
         );
 
         // Check if active cell is inside selection.
         widget.activeCellIndex = 2;
-        expect(() => widget.getContiguousSelection()).toThrow(
+        expect(() => widget.getContiguousSelection()).toThrowError(
           /Active cell not at endpoint of selection/
         );
       });
@@ -1138,10 +1109,7 @@
 
       it('handles the case of no cells', () => {
         const widget = createActiveWidget();
-        widget.model!.sharedModel.deleteCellRange(
-          0,
-          widget.model!.sharedModel.cells.length
-        );
+        widget.model!.cells.clear();
         expect(widget.widgets.length).toBe(0);
 
         const selection = widget.getContiguousSelection();
@@ -1215,15 +1183,12 @@
           expect(widget.activeCellIndex).toBe(0);
         });
 
-        it('should preserve "command" mode if in a markdown cell', async () => {
-          widget.model!.sharedModel.insertCell(0, {
-            cell_type: 'markdown',
-            source: '# Hello'
-          });
-          const child = widget.widgets[0] as MarkdownCell;
-          if (!child.inViewport) {
-            await signalToPromise(child.inViewportChanged);
-          }
+        it('should preserve "command" mode if in a markdown cell', () => {
+          const cell = widget.model!.contentFactory.createMarkdownCell({});
+          cell.value.text = '# Hello'; // Should be rendered with content.
+          widget.model!.cells.push(cell);
+          const count = widget.widgets.length;
+          const child = widget.widgets[count - 1] as MarkdownCell;
           expect(child.rendered).toBe(true);
           simulate(child.node, 'mousedown');
           expect(child.rendered).toBe(true);
@@ -1233,21 +1198,6 @@
         it('should extend selection if invoked with shift', () => {
           widget.activeCellIndex = 3;
 
-          // shift click no-op
-          simulate(widget.widgets[3].node, 'mousedown', { shiftKey: true });
-          expect(widget.activeCellIndex).toBe(3);
-          expect(selected(widget)).toEqual([]);
-          // test that selecting mode handler does not prevent default
-          // if no cells were selected; in the selecting mode we listen
-          // to the `mouseup` event to stop selecting when the mouse button gets
-          // released; this event gets default prevented as handled by the notebook.
-          const mouseUpEvent = new MouseEvent('mouseup', {
-            bubbles: true,
-            cancelable: true
-          });
-          widget.widgets[3].node.dispatchEvent(mouseUpEvent);
-          expect(mouseUpEvent.defaultPrevented).toBe(false);
-
           // shift click below
           simulate(widget.widgets[4].node, 'mousedown', { shiftKey: true });
           expect(widget.activeCellIndex).toBe(4);
@@ -1267,27 +1217,6 @@
           simulate(widget.widgets[2].node, 'mousedown', { shiftKey: true });
           expect(widget.activeCellIndex).toBe(2);
           expect(selected(widget)).toEqual([2, 3]);
-
-          // shift click deselect
-          simulate(widget.widgets[3].node, 'mousedown', { shiftKey: true });
-          expect(widget.activeCellIndex).toBe(3);
-          expect(selected(widget)).toEqual([]);
-
-          // shift click select by dragging from active cell
-          expect(widget.activeCellIndex).toBe(3);
-          simulate(widget.widgets[3].node, 'mousedown', { shiftKey: true });
-          expect(widget.activeCellIndex).toBe(3);
-          simulate(widget.widgets[4].node, 'mousemove', { shiftKey: true });
-          expect(selected(widget)).toEqual([3, 4]);
-          // test that selecting mode mouse up handler prevents default;
-          // in selecting mode we listen to the `mouseup` event to stop
-          // selecting when the mouse button gets released
-          const blockedMouseUpEvent = new MouseEvent('mouseup', {
-            bubbles: true,
-            cancelable: true
-          });
-          widget.widgets[4].node.dispatchEvent(blockedMouseUpEvent);
-          expect(blockedMouseUpEvent.defaultPrevented).toBe(true);
         });
 
         it('should not extend a selection if there is text selected in the output', () => {
@@ -1308,65 +1237,57 @@
           expect(selected(widget)).toEqual([]);
         });
 
-        it('should leave a markdown cell rendered', async () => {
-          widget.model!.sharedModel.insertCells(0, [
-            { cell_type: 'code' },
-            { cell_type: 'markdown', source: '# Hello' }
-          ]);
-          const codeChild = widget.widgets[0];
-          const mdChild = widget.widgets[1] as MarkdownCell;
-          if (!codeChild.inViewport) {
-            await signalToPromise(codeChild.inViewportChanged);
-          }
-          if (!mdChild.inViewport) {
-            await signalToPromise(mdChild.inViewportChanged);
-          }
+        it('should leave a markdown cell rendered', () => {
+          const code = widget.model!.contentFactory.createCodeCell({});
+          const md = widget.model!.contentFactory.createMarkdownCell({});
+          md.value.text = '# Hello'; // Should be rendered with content.
+          widget.model!.cells.push(code);
+          widget.model!.cells.push(md);
+          const count = widget.widgets.length;
+          const codeChild = widget.widgets[count - 2];
+          const mdChild = widget.widgets[count - 1] as MarkdownCell;
           widget.select(codeChild);
           widget.select(mdChild);
-          widget.activeCellIndex = 0;
+          widget.activeCellIndex = count - 2;
           expect(mdChild.rendered).toBe(true);
-          simulate(codeChild.editorWidget!.node, 'mousedown');
-          simulate(codeChild.editorWidget!.node, 'focusin');
+          simulate(codeChild.editorWidget.node, 'mousedown');
+          simulate(codeChild.editorWidget.node, 'focusin');
           expect(mdChild.rendered).toBe(true);
           expect(widget.activeCell).toBe(codeChild);
           expect(widget.mode).toBe('edit');
         });
 
-        it('should remove selection and switch to command mode', async () => {
-          widget.model!.sharedModel.insertCells(0, [
-            { cell_type: 'code' },
-            { cell_type: 'markdown', source: '# Hello' }
-          ]);
-          const codeChild = widget.widgets[0];
-          const mdChild = widget.widgets[1] as MarkdownCell;
-          if (!codeChild.inViewport) {
-            await signalToPromise(codeChild.inViewportChanged);
-          }
-          if (!mdChild.inViewport) {
-            await signalToPromise(mdChild.inViewportChanged);
-          }
+        it('should remove selection and switch to command mode', () => {
+          const code = widget.model!.contentFactory.createCodeCell({});
+          const md = widget.model!.contentFactory.createMarkdownCell({});
+          widget.model!.cells.push(code);
+          widget.model!.cells.push(md);
+          const count = widget.widgets.length;
+          const codeChild = widget.widgets[count - 2];
+          const mdChild = widget.widgets[count - 1] as MarkdownCell;
           widget.select(codeChild);
           widget.select(mdChild);
-          widget.activeCellIndex = 0;
-          simulate(codeChild.editorWidget!.node, 'mousedown');
-          simulate(codeChild.editorWidget!.node, 'focusin');
+          widget.activeCellIndex = count - 2;
+          simulate(codeChild.editorWidget.node, 'mousedown');
+          simulate(codeChild.editorWidget.node, 'focusin');
           expect(widget.mode).toBe('edit');
-          simulate(codeChild.editorWidget!.node, 'mousedown', { button: 2 });
+          simulate(codeChild.editorWidget.node, 'mousedown', { button: 2 });
           expect(widget.isSelected(mdChild)).toBe(false);
           expect(widget.mode).toBe('command');
         });
 
         it('should have no effect on shift right click', () => {
-          widget.model!.sharedModel.insertCells(0, [
-            { cell_type: 'code' },
-            { cell_type: 'markdown', source: '# Hello' }
-          ]);
-          const codeChild = widget.widgets[0];
-          const mdChild = widget.widgets[1] as MarkdownCell;
+          const code = widget.model!.contentFactory.createCodeCell({});
+          const md = widget.model!.contentFactory.createMarkdownCell({});
+          widget.model!.cells.push(code);
+          widget.model!.cells.push(md);
+          const count = widget.widgets.length;
+          const codeChild = widget.widgets[count - 2];
+          const mdChild = widget.widgets[count - 1] as MarkdownCell;
           widget.select(codeChild);
           widget.select(mdChild);
-          widget.activeCellIndex = 0;
-          simulate(codeChild.editorWidget!.node, 'mousedown', {
+          widget.activeCellIndex = count - 2;
+          simulate(codeChild.editorWidget.node, 'mousedown', {
             shiftKey: true,
             button: 2
           });
@@ -1376,15 +1297,13 @@
       });
 
       describe('dblclick', () => {
-        it('should unrender a markdown cell', async () => {
-          widget.model!.sharedModel.insertCell(0, {
-            cell_type: 'markdown',
-            source: '# Hello'
-          });
-          const child = widget.widgets[0] as MarkdownCell;
-          if (!child.inViewport) {
-            await signalToPromise(child.inViewportChanged);
-          }
+        it('should unrender a markdown cell', () => {
+          const cell = widget.model!.contentFactory.createMarkdownCell({});
+          cell.value.text = '# Hello'; // Should be rendered with content.
+          widget.model!.cells.push(cell);
+          const child = widget.widgets[
+            widget.widgets.length - 1
+          ] as MarkdownCell;
           expect(child.rendered).toBe(true);
           expect(widget.mode).toBe('command');
           simulate(child.node, 'dblclick');
@@ -1396,14 +1315,14 @@
       describe('focusin', () => {
         it('should change to edit mode if a child cell takes focus', () => {
           const child = widget.widgets[0];
-          simulate(child.editorWidget!.node, 'focusin');
+          simulate(child.editorWidget.node, 'focusin');
           expect(widget.events).toEqual(expect.arrayContaining(['focusin']));
           expect(widget.mode).toBe('edit');
         });
 
         it('should change to command mode if the widget takes focus', () => {
           const child = widget.widgets[0];
-          simulate(child.editorWidget!.node, 'focusin');
+          simulate(child.editorWidget.node, 'focusin');
           expect(widget.events).toEqual(expect.arrayContaining(['focusin']));
           expect(widget.mode).toBe('edit');
           widget.events = [];
@@ -1411,28 +1330,10 @@
           expect(widget.events).toEqual(expect.arrayContaining(['focusin']));
           expect(widget.mode).toBe('command');
         });
-
-        it('should not unrender previously active markdown cell', async () => {
-          widget.model!.sharedModel.insertCell(0, {
-            cell_type: 'markdown',
-            source: '# Hello'
-          });
-          const mdCell = widget.widgets[0] as MarkdownCell;
-          if (!mdCell.inViewport) {
-            await signalToPromise(mdCell.inViewportChanged);
-          }
-          widget.activeCellIndex = 0;
-          expect(mdCell.rendered).toBe(true);
-          const cellToActivate = widget.widgets[1];
-          expect(widget.mode).toBe('command');
-          simulate(cellToActivate.editorWidget!.node, 'focusin');
-          expect(widget.mode).toBe('edit');
-          expect(mdCell.rendered).toBe(true);
-        });
       });
 
       describe('focusout', () => {
-        it('should switch to command mode', async () => {
+        it('should switch to command mode', () => {
           simulate(widget.node, 'focusin');
           widget.mode = 'edit';
           const event = generate('focusout');
@@ -1440,10 +1341,8 @@
           widget.node.dispatchEvent(event);
           expect(widget.mode).toBe('command');
           MessageLoop.sendMessage(widget, Widget.Msg.ActivateRequest);
-          // Wait for the activeCell to be focused
-          await framePromise();
           expect(widget.mode).toBe('command');
-          expect(widget.activeCell!.editor!.hasFocus()).toBe(false);
+          expect(widget.activeCell!.editor.hasFocus()).toBe(false);
         });
 
         it('should set command mode', () => {
@@ -1500,14 +1399,18 @@
         const child = widget.widgets[0];
         await framePromise();
         Widget.detach(widget);
-        expect(widget.methods).toContain('onBeforeDetach');
+        expect(widget.methods).toEqual(
+          expect.arrayContaining(['onBeforeDetach'])
+        );
         widget.events = [];
         simulate(widget.node, 'mousedown');
-        expect(widget.events).not.toContain('mousedown');
+        expect(widget.events).toEqual(
+          expect.not.arrayContaining(['mousedown'])
+        );
         simulate(widget.node, 'dblclick');
-        expect(widget.events).not.toContain('dblclick');
+        expect(widget.events).toEqual(expect.not.arrayContaining(['dblclick']));
         simulate(child.node, 'focusin');
-        expect(widget.events).not.toContain('focusin');
+        expect(widget.events).toEqual(expect.not.arrayContaining(['focusin']));
         widget.dispose();
       });
     });
@@ -1515,15 +1418,13 @@
     describe('#onActivateRequest()', () => {
       it('should focus the node after an update', async () => {
         const widget = createActiveWidget();
-        widget.model!.fromJSON(utils.DEFAULT_CONTENT);
         Widget.attach(widget, document.body);
+        MessageLoop.sendMessage(widget, Widget.Msg.ActivateRequest);
+        expect(widget.methods).toEqual(
+          expect.arrayContaining(['onActivateRequest'])
+        );
         await framePromise();
-        MessageLoop.sendMessage(widget, Widget.Msg.ActivateRequest);
-        expect(widget.methods).toEqual(
-          expect.arrayContaining(['onActivateRequest'])
-        );
-        await framePromise();
-        expect(document.activeElement).toBe(widget.activeCell!.node);
+        expect(document.activeElement).toBe(widget.node);
         widget.dispose();
       });
     });
@@ -1600,30 +1501,56 @@
         const widget = createActiveWidget();
         widget.model!.fromJSON(utils.DEFAULT_CONTENT);
         widget.activeCellIndex = 1;
-        widget.model!.sharedModel.insertCell(0, { cell_type: 'code' });
+        const cell = widget.model!.contentFactory.createCodeCell({});
+        widget.model!.cells.insert(1, cell);
         expect(widget.activeCell).toBe(widget.widgets[2]);
       });
 
       describe('`edgeRequested` signal', () => {
-        it('should activate the previous cell if top is requested', async () => {
+        it('should activate the previous cell if top is requested', () => {
           const widget = createActiveWidget();
           widget.model!.fromJSON(utils.DEFAULT_CONTENT);
           widget.activeCellIndex = 1;
-          // Wait for the cell to be ready and the signal listener to be set
-          await sleep();
           const child = widget.widgets[widget.activeCellIndex];
-          (child.editor!.edgeRequested as any).emit('top');
+          (child.editor.edgeRequested as any).emit('top');
           expect(widget.activeCellIndex).toBe(0);
         });
 
-        it('should activate the next cell if bottom is requested', async () => {
+        it('should activate the next cell if bottom is requested', () => {
           const widget = createActiveWidget();
           widget.model!.fromJSON(utils.DEFAULT_CONTENT);
-          // Wait for the cell to be ready and the signal listener to be set
-          await sleep();
           const child = widget.widgets[widget.activeCellIndex];
-          (child.editor!.edgeRequested as any).emit('bottom');
+          (child.editor.edgeRequested as any).emit('bottom');
           expect(widget.activeCellIndex).toBe(1);
+        });
+      });
+    });
+
+    describe('#onCellMoved()', () => {
+      it('should update the active cell index if necessary', () => {
+        const widget = createActiveWidget();
+
+        // [fromIndex, toIndex, activeIndex], starting with activeIndex=3.
+        const moves = [
+          [0, 2, 3],
+          [0, 3, 2],
+          [0, 4, 2],
+          [3, 2, 2],
+          [3, 3, 3],
+          [3, 4, 4],
+          [4, 2, 4],
+          [4, 3, 4],
+          [4, 5, 3]
+        ];
+
+        moves.forEach(m => {
+          const [fromIndex, toIndex, activeIndex] = m;
+          widget.model!.fromJSON(utils.DEFAULT_CONTENT);
+          const cell = widget.widgets[3];
+          widget.activeCellIndex = 3;
+          widget.model!.cells.move(fromIndex, toIndex);
+          expect(widget.activeCellIndex).toBe(activeIndex);
+          expect(widget.widgets[activeIndex]).toBe(cell);
         });
       });
     });
@@ -1631,7 +1558,8 @@
     describe('#onCellRemoved()', () => {
       it('should post an `update-request', async () => {
         const widget = createActiveWidget();
-        widget.model!.sharedModel.deleteCell(0);
+        const cell = widget.model!.cells.get(0);
+        widget.model!.cells.removeValue(cell);
         expect(widget.methods).toEqual(
           expect.arrayContaining(['onCellRemoved'])
         );
@@ -1644,7 +1572,7 @@
       it('should update the active cell if necessary', () => {
         const widget = createActiveWidget();
         widget.model!.fromJSON(utils.DEFAULT_CONTENT);
-        widget.model!.sharedModel.deleteCell(0);
+        widget.model!.cells.remove(0);
         expect(widget.activeCell).toBe(widget.widgets[0]);
       });
 
@@ -1652,8 +1580,25 @@
         const widget = createActiveWidget();
         widget.model!.fromJSON(utils.DEFAULT_CONTENT);
         widget.activeCellIndex = 2;
-        widget.model!.sharedModel.deleteCell(1);
+        widget.model!.cells.remove(1);
         expect(widget.activeCell).toBe(widget.widgets[1]);
+      });
+    });
+
+    // WIP See https://github.com/jupyterlab/jupyterlab/issues/10526
+    describe('#virtualNotebook()', () => {
+      it('should render the last cell widget', () => {
+        const model = new NotebookModel();
+        const widget = new StaticNotebook(options);
+        widget.model = model;
+        widget.model!.fromJSON(utils.DEFAULT_CONTENT);
+        const cell = widget.widgets[5];
+        expect(
+          cell.inputArea.editorWidget.model.value.text.startsWith(
+            'from IPython.display import Latex'
+          )
+        ).toBe(true);
+        console.log();
       });
     });
   });