--- packages\notebook\test\actions.spec.ts (old)
+++ packages\notebook\test\actions.spec.ts (new)
@@ -2,34 +2,19 @@
 // Distributed under the terms of the Modified BSD License.
 
 import { ISessionContext, SessionContext } from '@jupyterlab/apputils';
-import { createSessionContext } from '@jupyterlab/apputils/lib/testutils';
-import {
-  CodeCell,
-  ICodeCellModel,
-  MarkdownCell,
-  RawCell
-} from '@jupyterlab/cells';
-import { CodeEditor } from '@jupyterlab/codeeditor';
+import { CodeCell, MarkdownCell, RawCell } from '@jupyterlab/cells';
 import { CellType, IMimeBundle } from '@jupyterlab/nbformat';
-import {
-  KernelError,
-  Notebook,
-  NotebookActions,
-  NotebookModel,
-  StaticNotebook
-} from '@jupyterlab/notebook';
-import { Stdin } from '@jupyterlab/outputarea';
 import { IRenderMimeRegistry } from '@jupyterlab/rendermime';
-import { ISharedCodeCell } from '@jupyter/ydoc';
 import {
   acceptDialog,
+  createSessionContext,
   dismissDialog,
-  JupyterServer,
-  signalToPromise,
-  sleep,
-  waitForDialog
-} from '@jupyterlab/testing';
+  sleep
+} from '@jupyterlab/testutils';
+import { JupyterServer } from '@jupyterlab/testutils/lib/start_jupyter_server';
+import { each } from '@lumino/algorithm';
 import { JSONArray, JSONObject, UUID } from '@lumino/coreutils';
+import { KernelError, Notebook, NotebookActions, NotebookModel } from '..';
 import * as utils from './utils';
 
 const ERROR_INPUT = 'a = foo';
@@ -39,8 +24,9 @@
 const server = new JupyterServer();
 
 beforeAll(async () => {
+  jest.setTimeout(20000);
   await server.start();
-}, 30000);
+});
 
 afterAll(async () => {
   await server.shutdown();
@@ -55,6 +41,7 @@
     let ipySessionContext: ISessionContext;
 
     beforeAll(async function () {
+      jest.setTimeout(20000);
       rendermime = utils.defaultRenderMime();
 
       async function createContext(options?: Partial<SessionContext.IOptions>) {
@@ -67,17 +54,13 @@
         createContext(),
         createContext({ kernelPreference: { name: 'ipython' } })
       ]);
-    }, 30000);
+    });
 
     beforeEach(() => {
       widget = new Notebook({
         rendermime,
         contentFactory: utils.createNotebookFactory(),
-        mimeTypeService: utils.mimeTypeService,
-        notebookConfig: {
-          ...StaticNotebook.defaultNotebookConfig,
-          windowingMode: 'none'
-        }
+        mimeTypeService: utils.mimeTypeService
       });
       const model = new NotebookModel();
       model.fromJSON(utils.DEFAULT_CONTENT);
@@ -88,7 +71,6 @@
     });
 
     afterEach(() => {
-      widget.model?.dispose();
       widget.dispose();
       utils.clipboard.clear();
     });
@@ -135,10 +117,10 @@
             cellError = error;
           }
         });
-        widget.model!.sharedModel.insertCell(widget.widgets.length, {
-          cell_type: 'code',
-          source: ERROR_INPUT
-        });
+
+        const cell = widget.model!.contentFactory.createCodeCell({});
+        cell.value.text = ERROR_INPUT;
+        widget.model!.cells.push(cell);
         widget.select(widget.widgets[widget.widgets.length - 1]);
         const result = await NotebookActions.run(widget, ipySessionContext);
         expect(result).toBe(false);
@@ -148,6 +130,7 @@
         expect(cellError!.errorName).toBe('NameError');
         expect(cellError!.errorValue).toBe("name 'foo' is not defined");
         expect(cellError!.traceback).not.toBeNull();
+        await ipySessionContext.session!.kernel!.restart();
       });
     });
 
@@ -156,7 +139,7 @@
         const cell = widget.activeCell as CodeCell;
         const next = widget.widgets[1] as MarkdownCell;
         let emitted = 0;
-        widget.activeCell!.model.sharedModel.setSource("print('hello')");
+        widget.activeCell!.model.value.text = "print('hello')";
         widget.select(next);
         cell.model.outputs.clear();
         next.rendered = false;
@@ -170,64 +153,35 @@
       });
     });
 
-    describe('#splitCell()', () => {
+    describe('#splitCell({})', () => {
       it('should split the active cell into two cells', () => {
         const cell = widget.activeCell!;
         const source = 'thisisasamplestringwithnospaces';
-        cell.model.sharedModel.setSource(source);
+        cell.model.value.text = source;
         const index = widget.activeCellIndex;
-        const editor = cell.editor as CodeEditor.IEditor;
+        const editor = cell.editor;
         editor.setCursorPosition(editor.getPositionAt(10)!);
         NotebookActions.splitCell(widget);
         const cells = widget.model!.cells;
         const newSource =
-          cells.get(index).sharedModel.getSource() +
-          cells.get(index + 1).sharedModel.getSource();
+          cells.get(index).value.text + cells.get(index + 1).value.text;
         expect(newSource).toBe(source);
       });
 
       it('should preserve leading white space in the second cell', () => {
         const cell = widget.activeCell!;
         const source = 'this\n\n   is a test';
-        cell.model.sharedModel.setSource(source);
-        const editor = cell.editor as CodeEditor.IEditor;
+        cell.model.value.text = source;
+        const editor = cell.editor;
         editor.setCursorPosition(editor.getPositionAt(4)!);
         NotebookActions.splitCell(widget);
-        expect(widget.activeCell!.model.sharedModel.getSource()).toBe(
-          '   is a test'
-        );
-      });
-
-      it('should preserve all outputs in the second cell', async () => {
-        const cell = widget.activeCell as CodeCell;
-        // Produce two outputs (note, first will be `text/plain`,
-        // while second will be `application/vnd.jupyter.stdout`,
-        // which guarantees these will not be merged).
-        const index = widget.activeCellIndex;
-        const source = 'print(1)\ndisplay(2)';
-        cell.model.sharedModel.setSource(source);
-
-        // Should populate outputs
-        await NotebookActions.run(widget, ipySessionContext);
-        expect(cell.model.outputs).toHaveLength(2);
-
-        // Split cell
-        const editor = cell.editor as CodeEditor.IEditor;
-        editor.setCursorPosition(editor.getPositionAt(9)!);
-        NotebookActions.splitCell(widget);
-
-        // The output should now be only in the second cell
-        const cells = widget.model!.cells;
-        const first = cells.get(index) as ICodeCellModel;
-        const second = cells.get(index + 1) as ICodeCellModel;
-        expect(first.outputs).toHaveLength(0);
-        expect(second.outputs).toHaveLength(2);
+        expect(widget.activeCell!.model.value.text).toBe('   is a test');
       });
 
       it('should clear the existing selection', () => {
-        for (const child of widget.widgets) {
+        each(widget.widgets, child => {
           widget.select(child);
-        }
+        });
         NotebookActions.splitCell(widget);
         for (let i = 0; i < widget.widgets.length; i++) {
           if (i === widget.activeCellIndex) {
@@ -251,82 +205,82 @@
       });
 
       it('should create two empty cells if there is no content', () => {
-        widget.activeCell!.model.sharedModel.setSource('');
+        widget.activeCell!.model.value.text = '';
         NotebookActions.splitCell(widget);
-        expect(widget.activeCell!.model.sharedModel.getSource()).toBe('');
+        expect(widget.activeCell!.model.value.text).toBe('');
         const prev = widget.widgets[0];
-        expect(prev.model.sharedModel.getSource()).toBe('');
+        expect(prev.model.value.text).toBe('');
       });
 
       it('should be a no-op if there is no model', () => {
         widget.model = null;
         NotebookActions.splitCell(widget);
-        expect(widget.activeCell).toBeNull();
-      });
-
-      it('should switch the widget mode to edit', () => {
+        expect(widget.activeCell).toBeUndefined();
+      });
+
+      it('should preserve the widget mode', () => {
+        NotebookActions.splitCell(widget);
+        expect(widget.mode).toBe('command');
+        widget.mode = 'edit';
         NotebookActions.splitCell(widget);
         expect(widget.mode).toBe('edit');
-        widget.mode = 'edit';
-        NotebookActions.splitCell(widget);
-        expect(widget.mode).toBe('edit');
       });
 
       it('should be undo-able', () => {
-        const source = widget.activeCell!.model.sharedModel.getSource();
+        const source = widget.activeCell!.model.value.text;
         const count = widget.widgets.length;
         NotebookActions.splitCell(widget);
         NotebookActions.undo(widget);
         expect(widget.widgets.length).toBe(count);
         const cell = widget.widgets[0];
-        expect(cell.model.sharedModel.getSource()).toBe(source);
+        expect(cell.model.value.text).toBe(source);
       });
     });
 
     describe('#mergeCells', () => {
       it('should merge the selected cells', () => {
-        let source = widget.activeCell!.model.sharedModel.getSource() + '\n\n';
+        let source = widget.activeCell!.model.value.text + '\n\n';
         let next = widget.widgets[1];
         widget.select(next);
-        source += next.model.sharedModel.getSource() + '\n\n';
+        source += next.model.value.text + '\n\n';
         next = widget.widgets[2];
         widget.select(next);
-        source += next.model.sharedModel.getSource();
+        source += next.model.value.text;
         const count = widget.widgets.length;
         NotebookActions.mergeCells(widget);
         expect(widget.widgets.length).toBe(count - 2);
-        expect(widget.activeCell!.model.sharedModel.getSource()).toBe(source);
+        expect(widget.activeCell!.model.value.text).toBe(source);
       });
 
       it('should be a no-op if there is no model', () => {
         widget.model = null;
         NotebookActions.mergeCells(widget);
-        expect(widget.activeCell).toBeNull();
+        expect(widget.activeCell).toBeUndefined();
       });
 
       it('should select the next cell if there is only one cell selected', () => {
-        let source = widget.activeCell!.model.sharedModel.getSource() + '\n\n';
+        let source = widget.activeCell!.model.value.text + '\n\n';
         const next = widget.widgets[1];
-        source += next.model.sharedModel.getSource();
+        source += next.model.value.text;
         NotebookActions.mergeCells(widget);
-        expect(widget.activeCell!.model.sharedModel.getSource()).toBe(source);
+        expect(widget.activeCell!.model.value.text).toBe(source);
       });
 
       it('should select the previous cell if there is only one cell selected and mergeAbove is true', () => {
         widget.activeCellIndex = 1;
-        let source = widget.activeCell!.model.sharedModel.getSource();
+        let source = widget.activeCell!.model.value.text;
         const previous = widget.widgets[0];
-        source = previous.model.sharedModel.getSource() + '\n\n' + source;
+        source = previous.model.value.text + '\n\n' + source;
         NotebookActions.mergeCells(widget, true);
-        expect(widget.activeCell!.model.sharedModel.getSource()).toBe(source);
+        expect(widget.activeCell!.model.value.text).toBe(source);
       });
 
       it('should do nothing if first cell selected and mergeAbove is true', () => {
-        let source = widget.activeCell!.model.sharedModel.getSource();
+        let source = widget.activeCell!.model.value.text;
         const cellNumber = widget.widgets.length;
         NotebookActions.mergeCells(widget, true);
         expect(widget.widgets.length).toBe(cellNumber);
-        expect(widget.activeCell!.model.sharedModel.getSource()).toBe(source);
+        expect(widget.activeCell!.model.value.text).toBe(source);
       });
 
       it('should clear the outputs of a code cell', () => {
@@ -335,12 +289,6 @@
         expect(cell.model.outputs.length).toBe(0);
       });
 
-      it('should mark cell as trusted as cells without output are trusted', () => {
-        NotebookActions.mergeCells(widget);
-        const cell = widget.activeCell as CodeCell;
-        expect(cell.model.trusted).toBe(true);
-      });
-
       it('should preserve the widget mode', () => {
         widget.mode = 'edit';
         NotebookActions.mergeCells(widget);
@@ -351,13 +299,13 @@
       });
 
       it('should be undo-able', () => {
-        const source = widget.activeCell!.model.sharedModel.getSource();
+        const source = widget.activeCell!.model.value.text;
         const count = widget.widgets.length;
         NotebookActions.mergeCells(widget);
         NotebookActions.undo(widget);
         expect(widget.widgets.length).toBe(count);
         const cell = widget.widgets[0];
-        expect(cell.model.sharedModel.getSource()).toBe(source);
+        expect(cell.model.value.text).toBe(source);
       });
 
       it('should unrender a markdown cell', () => {
@@ -435,7 +383,7 @@
       it('should be a no-op if there is no model', () => {
         widget.model = null;
         NotebookActions.deleteCells(widget);
-        expect(widget.activeCell).toBeNull();
+        expect(widget.activeCell).toBeUndefined();
       });
 
       it('should switch to command mode', () => {
@@ -471,13 +419,13 @@
       it('should be undo-able', () => {
         const next = widget.widgets[1];
         widget.select(next);
-        const source = widget.activeCell!.model.sharedModel.getSource();
+        const source = widget.activeCell!.model.value.text;
         const count = widget.widgets.length;
         NotebookActions.deleteCells(widget);
         NotebookActions.undo(widget);
         expect(widget.widgets.length).toBe(count);
         const cell = widget.widgets[0];
-        expect(cell.model.sharedModel.getSource()).toBe(source);
+        expect(cell.model.value.text).toBe(source);
       });
 
       it('should be undo-able if all the cells are deleted', () => {
@@ -485,11 +433,11 @@
           widget.select(widget.widgets[i]);
         }
         const count = widget.widgets.length;
-        const source = widget.widgets[1].model.sharedModel.getSource();
+        const source = widget.widgets[1].model.value.text;
         NotebookActions.deleteCells(widget);
         NotebookActions.undo(widget);
         expect(widget.widgets.length).toBe(count);
-        expect(widget.widgets[1].model.sharedModel.getSource()).toBe(source);
+        expect(widget.widgets[1].model.value.text).toBe(source);
       });
     });
 
@@ -505,10 +453,10 @@
       it('should be a no-op if there is no model', () => {
         widget.model = null;
         NotebookActions.insertAbove(widget);
-        expect(widget.activeCell).toBeNull();
-      });
-
-      it('widget mode should be preserved', () => {
+        expect(widget.activeCell).toBeUndefined();
+      });
+
+      it('should widget mode should be preserved', () => {
         NotebookActions.insertAbove(widget);
         expect(widget.mode).toBe('command');
         widget.mode = 'edit';
@@ -538,12 +486,7 @@
 
       it('should be the new active cell', () => {
         NotebookActions.insertAbove(widget);
-        expect(widget.activeCell!.model.sharedModel.getSource()).toBe('');
-      });
-
-      it('should mark inserted code cell as trusted', () => {
-        NotebookActions.insertAbove(widget);
-        expect(widget.activeCell!.model.trusted).toBe(true);
+        expect(widget.activeCell!.model.value.text).toBe('');
       });
     });
 
@@ -559,7 +502,7 @@
       it('should be a no-op if there is no model', () => {
         widget.model = null;
         NotebookActions.insertBelow(widget);
-        expect(widget.activeCell).toBeNull();
+        expect(widget.activeCell).toBeUndefined();
       });
 
       it('should widget mode should be preserved', () => {
@@ -592,12 +535,7 @@
 
       it('should be the new active cell', () => {
         NotebookActions.insertBelow(widget);
-        expect(widget.activeCell!.model.sharedModel.getSource()).toBe('');
-      });
-
-      it('should mark inserted code cell as trusted', () => {
-        NotebookActions.insertBelow(widget);
-        expect(widget.activeCell!.model.trusted).toBe(true);
+        expect(widget.activeCell!.model.value.text).toBe('');
       });
     });
 
@@ -614,7 +552,7 @@
       it('should be a no-op if there is no model', () => {
         widget.model = null;
         NotebookActions.changeCellType(widget, 'code');
-        expect(widget.activeCell).toBeNull();
+        expect(widget.activeCell).toBeUndefined();
       });
 
       it('should preserve the widget mode', () => {
@@ -649,54 +587,6 @@
         NotebookActions.changeCellType(widget, 'markdown');
         const cell = widget.activeCell as MarkdownCell;
         expect(cell.rendered).toBe(false);
-      });
-
-      it('should mark code cell as trusted', () => {
-        // Switch to markdown and then to code as otherwise this is no-op.
-        NotebookActions.changeCellType(widget, 'markdown');
-        NotebookActions.changeCellType(widget, 'code');
-        const cell = widget.activeCell as CodeCell;
-        expect(cell.model.trusted).toBe(true);
-      });
-
-      it('should clear trust metadata if switching away from code cell', () => {
-        widget.activeCell!.model.trusted = true;
-        NotebookActions.changeCellType(widget, 'markdown');
-        const cell = widget.activeCell as MarkdownCell;
-        expect(cell.model.metadata.trusted).toBe(undefined);
-      });
-
-      it('should not change cell type away from code cell when input is pending', async () => {
-        let cell = widget.activeCell as CodeCell;
-        expect(widget.activeCell).toBeInstanceOf(CodeCell);
-
-        const inputRequested = signalToPromise(cell.outputArea.inputRequested);
-
-        // Execute input request
-        cell.model.sharedModel.setSource('input()');
-        // Do not wait for completion yet: it will not complete until input is submitted
-        const donePromise = NotebookActions.run(widget, sessionContext);
-        // Wait for the input being requested from kernel
-        const stdin = (await inputRequested)[1];
-
-        // Try to change cell type
-        NotebookActions.changeCellType(widget, 'raw');
-        // Cell type should stay unchanged.
-        expect(widget.activeCell).toBeInstanceOf(CodeCell);
-
-        // Should show a dialog informing user why cell type could not be changed
-        await waitForDialog();
-        await acceptDialog();
-
-        // Submit the input
-        (stdin as Stdin).handleEvent(
-          new KeyboardEvent('keydown', { key: 'Enter' })
-        );
-        await donePromise;
-
-        // Try to change cell type again, it should work now
-        NotebookActions.changeCellType(widget, 'raw');
-        expect(widget.activeCell).toBeInstanceOf(RawCell);
       });
     });
 
@@ -750,7 +640,7 @@
           emitted += 1;
         });
         widget.select(other);
-        other.model.sharedModel.setSource('a = 1');
+        other.model.value.text = 'a = 1';
         const result = await NotebookActions.run(widget, sessionContext);
         expect(result).toBe(true);
         expect(widget.activeCell).toBe(other);
@@ -787,20 +677,10 @@
         NotebookActions.selectionExecuted.connect(() => {
           emitted += 1;
         });
-        const result = await NotebookActions.run(
-          widget,
-          {
-            isTerminating: false,
-            pendingInput: false,
-            hasNoKernel: true,
-            kernelPreference: { autoStartDefault: false },
-            startKernel: () => Promise.resolve(true)
-          } as ISessionContext,
-          { selectKernel: () => Promise.resolve() } as any
-        );
+        const result = await NotebookActions.run(widget, undefined);
         expect(result).toBe(true);
         const cell = widget.activeCell as CodeCell;
-        expect(cell.model.executionCount).toBe(null);
+        expect(cell.model.executionCount).toBeNull();
         expect(emitted).toBe(1);
       });
 
@@ -809,20 +689,17 @@
         NotebookActions.selectionExecuted.connect(() => {
           emitted += 1;
         });
-        widget.model!.sharedModel.insertCell(2, {
-          cell_type: 'code',
-          source: ERROR_INPUT
-        });
+        let cell = widget.model!.contentFactory.createCodeCell({});
+        cell.value.text = ERROR_INPUT;
+        widget.model!.cells.insert(2, cell);
         widget.select(widget.widgets[2]);
-        const cell = widget.model!.sharedModel.insertCell(
-          widget.widgets.length,
-          { cell_type: 'code' }
-        ) as ISharedCodeCell;
+        cell = widget.model!.contentFactory.createCodeCell({});
+        widget.model!.cells.push(cell);
         widget.select(widget.widgets[widget.widgets.length - 1]);
         const result = await NotebookActions.run(widget, ipySessionContext);
-        await sleep(400);
         expect(result).toBe(false);
-        expect(cell.execution_count).toBeNull();
+        expect(cell.executionCount).toBeNull();
+        await ipySessionContext.session!.kernel!.restart();
         expect(emitted).toBe(1);
       });
 
@@ -831,20 +708,20 @@
         NotebookActions.selectionExecuted.connect(() => {
           emitted += 1;
         });
-        widget.model!.sharedModel.insertCell(widget.widgets.length, {
-          cell_type: 'markdown'
-        });
+        const cell = widget.model!.contentFactory.createMarkdownCell({});
+        widget.model!.cells.push(cell);
         const child = widget.widgets[widget.widgets.length - 1] as MarkdownCell;
         child.rendered = false;
         widget.select(child);
-        widget.activeCell!.model.sharedModel.setSource(ERROR_INPUT);
+        widget.activeCell!.model.value.text = ERROR_INPUT;
         const result = await NotebookActions.run(widget, ipySessionContext);
         // Markdown rendering is asynchronous, but the cell
         // provides no way to hook into that. Sleep here
         // to make sure it finishes.
-        await sleep(400);
+        await sleep(100);
         expect(result).toBe(false);
         expect(child.rendered).toBe(true);
+        await ipySessionContext.session!.kernel!.restart();
         expect(emitted).toBe(1);
       });
     });
@@ -883,6 +760,7 @@
         );
         expect(result).toBe(false);
         expect(widget.isSelected(widget.widgets[0])).toBe(false);
+        await ipySessionContext.session!.kernel!.restart();
       });
 
       it('should change to command mode', async () => {
@@ -916,7 +794,6 @@
         expect(result).toBe(true);
         expect(widget.widgets.length).toBe(count + 1);
         expect(widget.activeCell).toBeInstanceOf(CodeCell);
-        expect(widget.activeCell!.model.trusted).toBe(true);
         expect(widget.mode).toBe('edit');
       });
 
@@ -933,22 +810,21 @@
       });
 
       it('should stop executing code cells on an error', async () => {
-        widget.activeCell!.model.sharedModel.setSource(ERROR_INPUT);
-        const cell = widget.model!.sharedModel.insertCell(
-          widget.widgets.length,
-          { cell_type: 'code' }
-        ) as ISharedCodeCell;
+        widget.activeCell!.model.value.text = ERROR_INPUT;
+        const cell = widget.model!.contentFactory.createCodeCell({});
+        widget.model!.cells.push(cell);
         widget.select(widget.widgets[widget.widgets.length - 1]);
         const result = await NotebookActions.runAndAdvance(
           widget,
           ipySessionContext
         );
         expect(result).toBe(false);
-        expect(cell.execution_count).toBeNull();
+        expect(cell.executionCount).toBeNull();
+        await ipySessionContext.session!.kernel!.restart();
       });
 
       it('should render all markdown cells on an error', async () => {
-        widget.activeCell!.model.sharedModel.setSource(ERROR_INPUT);
+        widget.activeCell!.model.value.text = ERROR_INPUT;
         const cell = widget.widgets[1] as MarkdownCell;
         cell.rendered = false;
         widget.select(cell);
@@ -959,10 +835,11 @@
         // Markdown rendering is asynchronous, but the cell
         // provides no way to hook into that. Sleep here
         // to make sure it finishes.
-        await sleep(400);
+        await sleep(100);
         expect(result).toBe(false);
         expect(cell.rendered).toBe(true);
         expect(widget.activeCellIndex).toBe(2);
+        await ipySessionContext.session!.kernel!.restart();
       });
     });
 
@@ -1005,7 +882,7 @@
       it('should insert a new code cell in edit mode after the last selected cell', async () => {
         const next = widget.widgets[2];
         widget.select(next);
-        next.model.sharedModel.setSource('a = 1');
+        next.model.value.text = 'a = 1';
         const count = widget.widgets.length;
         const result = await NotebookActions.runAndInsert(
           widget,
@@ -1013,7 +890,6 @@
         );
         expect(result).toBe(true);
         expect(widget.activeCell).toBeInstanceOf(CodeCell);
-        expect(widget.activeCell!.model.trusted).toBe(true);
         expect(widget.mode).toBe('edit');
         expect(widget.widgets.length).toBe(count + 1);
       });
@@ -1021,7 +897,7 @@
       it('should allow an undo of the cell insert', async () => {
         const next = widget.widgets[2];
         widget.select(next);
-        next.model.sharedModel.setSource('a = 1');
+        next.model.value.text = 'a = 1';
         const count = widget.widgets.length;
         const result = await NotebookActions.runAndInsert(
           widget,
@@ -1033,23 +909,21 @@
       });
 
       it('should stop executing code cells on an error', async () => {
-        widget.activeCell!.model.sharedModel.setSource(ERROR_INPUT);
-        const cell = widget.model!.sharedModel.insertCell(
-          widget.widgets.length,
-          { cell_type: 'code' }
-        ) as ISharedCodeCell;
+        widget.activeCell!.model.value.text = ERROR_INPUT;
+        const cell = widget.model!.contentFactory.createCodeCell({});
+        widget.model!.cells.push(cell);
         widget.select(widget.widgets[widget.widgets.length - 1]);
         const result = await NotebookActions.runAndInsert(
           widget,
           ipySessionContext
         );
-        await sleep(400);
         expect(result).toBe(false);
-        expect(cell.execution_count).toBeNull();
+        expect(cell.executionCount).toBeNull();
+        await ipySessionContext.session!.kernel!.restart();
       });
 
       it('should render all markdown cells on an error', async () => {
-        widget.activeCell!.model.sharedModel.setSource(ERROR_INPUT);
+        widget.activeCell!.model.value.text = ERROR_INPUT;
         const cell = widget.widgets[1] as MarkdownCell;
         cell.rendered = false;
         widget.select(cell);
@@ -1060,47 +934,18 @@
         // Markdown rendering is asynchronous, but the cell
         // provides no way to hook into that. Sleep here
         // to make sure it finishes.
-        await sleep(500);
+        await sleep(100);
         expect(result).toBe(false);
         expect(cell.rendered).toBe(true);
         expect(widget.activeCellIndex).toBe(2);
-      });
-    });
-
-    describe('#runCells()', () => {
-      beforeEach(() => {
-        // Make sure all cells have valid code.
-        widget.widgets[2].model.sharedModel.setSource('a = 1');
-      });
-
-      it('should change to command mode', async () => {
-        widget.mode = 'edit';
-        const result = await NotebookActions.runCells(
-          widget,
-          [widget.widgets[2]],
-          sessionContext
-        );
-        expect(result).toBe(true);
-        expect(widget.mode).toBe('command');
-      });
-
-      it('should preserve the existing selection', async () => {
-        const next = widget.widgets[2];
-        widget.select(next);
-        const result = await NotebookActions.runCells(
-          widget,
-          [widget.widgets[1]],
-          sessionContext
-        );
-        expect(result).toBe(true);
-        expect(widget.isSelected(widget.widgets[2])).toBe(true);
+        await ipySessionContext.session!.kernel!.restart();
       });
     });
 
     describe('#runAll()', () => {
       beforeEach(() => {
         // Make sure all cells have valid code.
-        widget.widgets[2].model.sharedModel.setSource('a = 1');
+        widget.widgets[2].model.value.text = 'a = 1';
       });
 
       it('should run all of the cells in the notebook', async () => {
@@ -1141,50 +986,28 @@
       });
 
       it('should stop executing code cells on an error', async () => {
-        widget.activeCell!.model.sharedModel.setSource(ERROR_INPUT);
-        const cell = widget.model!.sharedModel.insertCell(
-          widget.widgets.length,
-          { cell_type: 'code' }
-        ) as ISharedCodeCell;
-        widget.select(widget.widgets[widget.widgets.length - 1]);
+        widget.activeCell!.model.value.text = ERROR_INPUT;
+        const cell = widget.model!.contentFactory.createCodeCell({});
+        widget.model!.cells.push(cell);
         const result = await NotebookActions.runAll(widget, ipySessionContext);
         expect(result).toBe(false);
-        expect(cell.execution_count).toBeNull();
+        expect(cell.executionCount).toBeNull();
         expect(widget.activeCellIndex).toBe(widget.widgets.length - 1);
+        await ipySessionContext.session!.kernel!.restart();
       });
 
       it('should render all markdown cells on an error', async () => {
-        widget.activeCell!.model.sharedModel.setSource(ERROR_INPUT);
+        widget.activeCell!.model.value.text = ERROR_INPUT;
         const cell = widget.widgets[1] as MarkdownCell;
         cell.rendered = false;
         const result = await NotebookActions.runAll(widget, ipySessionContext);
         // Markdown rendering is asynchronous, but the cell
         // provides no way to hook into that. Sleep here
         // to make sure it finishes.
-        await sleep(400);
+        await sleep(100);
         expect(result).toBe(false);
         expect(cell.rendered).toBe(true);
-      });
-    });
-
-    describe('#runAllBelow()', () => {
-      it('should run all selected cell and all below', async () => {
-        const next = widget.widgets[1] as MarkdownCell;
-        const cell = widget.activeCell as CodeCell;
-        cell.model.outputs.clear();
-        next.rendered = false;
-        const result = await NotebookActions.runAllBelow(
-          widget,
-          sessionContext
-        );
-        expect(result).toBe(true);
-        expect(cell.model.outputs.length).toBeGreaterThan(0);
-        expect(next.rendered).toBe(true);
-      });
-
-      it('should activate the last cell', async () => {
-        await NotebookActions.runAllBelow(widget, sessionContext);
-        expect(widget.activeCellIndex).toBe(widget.widgets.length - 1);
+        await ipySessionContext.session!.kernel!.restart();
       });
     });
 
@@ -1394,13 +1217,6 @@
         expect(widget.activeCellIndex).toBe(0);
       });
 
-      it('should move the last cell up', () => {
-        const lastIndex = widget.model!.cells.length - 1;
-        widget.activeCellIndex = lastIndex;
-        NotebookActions.moveUp(widget);
-        expect(widget.activeCellIndex).toBe(lastIndex - 1);
-      });
-
       it('should be a no-op if there is no model', () => {
         widget.model = null;
         NotebookActions.moveUp(widget);
@@ -1415,11 +1231,11 @@
 
       it('should be undo-able', () => {
         widget.activeCellIndex++;
-        const source = widget.activeCell!.model.sharedModel.getSource();
+        const source = widget.activeCell!.model.value.text;
         NotebookActions.moveUp(widget);
-        expect(widget.model!.cells.get(0).sharedModel.getSource()).toBe(source);
-        NotebookActions.undo(widget);
-        expect(widget.model!.cells.get(1).sharedModel.getSource()).toBe(source);
+        expect(widget.model!.cells.get(0).value.text).toBe(source);
+        NotebookActions.undo(widget);
+        expect(widget.model!.cells.get(1).value.text).toBe(source);
       });
     });
 
@@ -1446,11 +1262,11 @@
       });
 
       it('should be undo-able', () => {
-        const source = widget.activeCell!.model.sharedModel.getSource();
+        const source = widget.activeCell!.model.value.text;
         NotebookActions.moveDown(widget);
-        expect(widget.model!.cells.get(1).sharedModel.getSource()).toBe(source);
-        NotebookActions.undo(widget);
-        expect(widget.model!.cells.get(0).sharedModel.getSource()).toBe(source);
+        expect(widget.model!.cells.get(1).value.text).toBe(source);
+        NotebookActions.undo(widget);
+        expect(widget.model!.cells.get(0).value.text).toBe(source);
       });
     });
 
@@ -1479,7 +1295,7 @@
       it('should delete metadata.deletable', () => {
         const next = widget.widgets[1];
         widget.select(next);
-        next.model.setMetadata('deletable', false);
+        next.model.metadata.set('deletable', false);
         NotebookActions.copy(widget);
         const data = utils.clipboard.getData(JUPYTER_CELL_MIME) as JSONArray;
         data.map(cell => {
@@ -1512,10 +1328,10 @@
       });
 
       it('should be undo-able', () => {
-        const source = widget.activeCell!.model.sharedModel.getSource();
+        const source = widget.activeCell!.model.value.text;
         NotebookActions.cut(widget);
         NotebookActions.undo(widget);
-        expect(widget.widgets[0].model.sharedModel.getSource()).toBe(source);
+        expect(widget.widgets[0].model.value.text).toBe(source);
       });
 
       it('should add a new code cell if all cells were cut', async () => {
@@ -1531,7 +1347,7 @@
 
     describe('#paste()', () => {
       it('should paste cells from a utils.clipboard', () => {
-        const source = widget.activeCell!.model.sharedModel.getSource();
+        const source = widget.activeCell!.model.value.text;
         const next = widget.widgets[1];
         widget.select(next);
         const count = widget.widgets.length;
@@ -1539,7 +1355,7 @@
         widget.activeCellIndex = 1;
         NotebookActions.paste(widget);
         expect(widget.widgets.length).toBe(count);
-        expect(widget.widgets[2].model.sharedModel.getSource()).toBe(source);
+        expect(widget.widgets[2].model.value.text).toBe(source);
         expect(widget.activeCellIndex).toBe(3);
       });
 
@@ -1601,7 +1417,7 @@
       it('should be a no-op if there are no cell actions to undo', () => {
         const count = widget.widgets.length;
         NotebookActions.deleteCells(widget);
-        widget.model!.sharedModel.clearUndoHistory();
+        widget.model!.cells.clearUndo();
         NotebookActions.undo(widget);
         expect(widget.widgets.length).toBe(count - 1);
       });
@@ -1641,24 +1457,22 @@
 
     describe('#toggleAllLineNumbers()', () => {
       it('should toggle line numbers on all cells', () => {
-        const state = widget.activeCell!.editor!.getOption('lineNumbers');
+        const state = widget.activeCell!.editor.getOption('lineNumbers');
         NotebookActions.toggleAllLineNumbers(widget);
         for (let i = 0; i < widget.widgets.length; i++) {
-          const lineNumbers =
-            widget.widgets[i].editor!.getOption('lineNumbers');
+          const lineNumbers = widget.widgets[i].editor.getOption('lineNumbers');
           expect(lineNumbers).toBe(!state);
         }
       });
 
       it('should be based on the state of the active cell', () => {
-        const state = widget.activeCell!.editor!.getOption('lineNumbers');
+        const state = widget.activeCell!.editor.getOption('lineNumbers');
         for (let i = 1; i < widget.widgets.length; i++) {
-          widget.widgets[i].editor!.setOption('lineNumbers', !state);
+          widget.widgets[i].editor.setOption('lineNumbers', !state);
         }
         NotebookActions.toggleAllLineNumbers(widget);
         for (let i = 0; i < widget.widgets.length; i++) {
-          const lineNumbers =
-            widget.widgets[i].editor!.getOption('lineNumbers');
+          const lineNumbers = widget.widgets[i].editor.getOption('lineNumbers');
           expect(lineNumbers).toBe(!state);
         }
       });
@@ -1693,10 +1507,8 @@
         NotebookActions.clearOutputs(widget);
         let cell = widget.widgets[0] as CodeCell;
         expect(cell.model.outputs.length).toBe(0);
-        expect(cell.model.trusted).toBe(true);
         cell = widget.widgets[index] as CodeCell;
         expect(cell.model.outputs.length).toBe(0);
-        expect(cell.model.trusted).toBe(true);
       });
 
       it('should preserve the widget mode', () => {
@@ -1722,9 +1534,7 @@
         for (let i = 0; i < widget.widgets.length; i++) {
           const cell = widget.widgets[i];
           if (cell instanceof CodeCell) {
-            // eslint-disable-next-line jest/no-conditional-expect
             expect(cell.model.outputs.length).toBe(0);
-            expect(cell.model.trusted).toBe(true);
           }
         }
       });
@@ -1749,10 +1559,8 @@
         const next = widget.widgets[1];
         widget.select(next);
         NotebookActions.setMarkdownHeader(widget, 2);
-        expect(
-          widget.activeCell!.model.sharedModel.getSource().slice(0, 3)
-        ).toBe('## ');
-        expect(next.model.sharedModel.getSource().slice(0, 3)).toBe('## ');
+        expect(widget.activeCell!.model.value.text.slice(0, 3)).toBe('## ');
+        expect(next.model.value.text.slice(0, 3)).toBe('## ');
       });
 
       it('should convert the cells to markdown type', () => {
@@ -1762,13 +1570,9 @@
 
       it('should be clamped between 1 and 6', () => {
         NotebookActions.setMarkdownHeader(widget, -1);
-        expect(
-          widget.activeCell!.model.sharedModel.getSource().slice(0, 2)
-        ).toBe('# ');
+        expect(widget.activeCell!.model.value.text.slice(0, 2)).toBe('# ');
         NotebookActions.setMarkdownHeader(widget, 10);
-        expect(
-          widget.activeCell!.model.sharedModel.getSource().slice(0, 7)
-        ).toBe('###### ');
+        expect(widget.activeCell!.model.value.text.slice(0, 7)).toBe('###### ');
       });
 
       it('should be a no-op if there is no model', () => {
@@ -1778,15 +1582,15 @@
       });
 
       it('should replace an existing header', () => {
-        widget.activeCell!.model.sharedModel.setSource('# foo');
+        widget.activeCell!.model.value.text = '# foo';
         NotebookActions.setMarkdownHeader(widget, 2);
-        expect(widget.activeCell!.model.sharedModel.getSource()).toBe('## foo');
+        expect(widget.activeCell!.model.value.text).toBe('## foo');
       });
 
       it('should replace leading white space', () => {
-        widget.activeCell!.model.sharedModel.setSource('      foo');
+        widget.activeCell!.model.value.text = '      foo';
         NotebookActions.setMarkdownHeader(widget, 2);
-        expect(widget.activeCell!.model.sharedModel.getSource()).toBe('## foo');
+        expect(widget.activeCell!.model.value.text).toBe('## foo');
       });
 
       it('should unrender the cells', () => {
@@ -1820,7 +1624,7 @@
 
       it('should be a no-op if the model is `null`', async () => {
         widget.model = null;
-        await expect(NotebookActions.trust(widget)).resolves.not.toThrow();
+        await NotebookActions.trust(widget);
       });
 
       it('should show a dialog if all cells are trusted', async () => {
@@ -1833,7 +1637,7 @@
         }
         const promise = NotebookActions.trust(widget);
         await acceptDialog();
-        await expect(promise).resolves.not.toThrow();
+        await promise;
       });
     });
   });