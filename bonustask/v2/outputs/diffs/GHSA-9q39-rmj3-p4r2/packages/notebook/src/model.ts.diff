--- packages\notebook\src\model.ts (old)
+++ packages\notebook\src\model.ts (new)
@@ -2,23 +2,34 @@
 // Distributed under the terms of the Modified BSD License.
 
 import { Dialog, showDialog } from '@jupyterlab/apputils';
-import { ICellModel } from '@jupyterlab/cells';
+import {
+  CellModel,
+  CodeCellModel,
+  ICellModel,
+  ICodeCellModel,
+  IMarkdownCellModel,
+  IRawCellModel,
+  MarkdownCellModel,
+  RawCellModel
+} from '@jupyterlab/cells';
 import { IChangedArgs } from '@jupyterlab/coreutils';
 import { DocumentRegistry } from '@jupyterlab/docregistry';
 import * as nbformat from '@jupyterlab/nbformat';
-import { IObservableList } from '@jupyterlab/observables';
 import {
-  IMapChange,
-  ISharedNotebook,
-  NotebookChange,
-  YNotebook
-} from '@jupyter/ydoc';
+  IModelDB,
+  IObservableJSON,
+  IObservableList,
+  IObservableMap,
+  IObservableUndoableList,
+  ModelDB
+} from '@jupyterlab/observables';
+import * as models from '@jupyterlab/shared-models';
 import {
   ITranslator,
   nullTranslator,
   TranslationBundle
 } from '@jupyterlab/translation';
-import { JSONExt } from '@lumino/coreutils';
+import { ReadonlyPartialJSONValue, UUID } from '@lumino/coreutils';
 import { ISignal, Signal } from '@lumino/signaling';
 import { CellList } from './celllist';
 
@@ -29,7 +40,12 @@
   /**
    * The list of cells in the notebook.
    */
-  readonly cells: CellList;
+  readonly cells: IObservableUndoableList<ICellModel>;
+
+  /**
+   * The cell model factory for the notebook.
+   */
+  readonly contentFactory: NotebookModel.IContentFactory;
 
   /**
    * The major version number of the nbformat.
@@ -43,19 +59,8 @@
 
   /**
    * The metadata associated with the notebook.
-   *
-   * ### Notes
-   * This is a copy of the metadata. Changing a part of it
-   * won't affect the model.
-   * As this returns a copy of all metadata, it is advised to
-   * use `getMetadata` to speed up the process of getting a single key.
-   */
-  readonly metadata: nbformat.INotebookMetadata;
-
-  /**
-   * Signal emitted when notebook metadata changes.
-   */
-  readonly metadataChanged: ISignal<INotebookModel, IMapChange>;
+   */
+  readonly metadata: IObservableJSON;
 
   /**
    * The array of deleted cells since the notebook was last run.
@@ -63,34 +68,10 @@
   readonly deletedCells: string[];
 
   /**
-   * Shared model
-   */
-  readonly sharedModel: ISharedNotebook;
-
-  /**
-   * Delete a metadata
-   *
-   * @param key Metadata key
-   */
-  deleteMetadata(key: string): void;
-
-  /**
-   * Get a metadata
-   *
-   * ### Notes
-   * This returns a copy of the key value.
-   *
-   * @param key Metadata key
-   */
-  getMetadata(key: string): any;
-
-  /**
-   * Set a metadata
-   *
-   * @param key Metadata key
-   * @param value Metadata value
-   */
-  setMetadata(key: string, value: any): void;
+   * If the model is initialized or not.
+   */
+  isInitialized: boolean;
+  readonly sharedModel: models.ISharedNotebook;
 }
 
 /**
@@ -101,35 +82,39 @@
    * Construct a new notebook model.
    */
   constructor(options: NotebookModel.IOptions = {}) {
-    this.standaloneModel = typeof options.sharedModel === 'undefined';
-
-    if (options.sharedModel) {
-      this.sharedModel = options.sharedModel;
+    if (options.modelDB) {
+      this.modelDB = options.modelDB;
     } else {
-      this.sharedModel = YNotebook.create({
-        disableDocumentWideUndoRedo:
-          options.disableDocumentWideUndoRedo ?? true,
-        data: {
-          nbformat: nbformat.MAJOR_VERSION,
-          nbformat_minor: nbformat.MINOR_VERSION,
-          metadata: {
-            kernelspec: { name: '', display_name: '' },
-            language_info: { name: options.languagePreference ?? '' }
-          }
-        }
-      });
-    }
-
-    this._cells = new CellList(this.sharedModel);
+      this.modelDB = new ModelDB();
+    }
+    this.sharedModel = new models.YNotebook({
+      disableDocumentWideUndoRedo: options.disableDocumentWideUndoRedo ?? true
+    }) as models.ISharedNotebook;
+    this._isInitialized = options.isInitialized === false ? false : true;
+    const factory =
+      options.contentFactory || NotebookModel.defaultContentFactory;
+    this.contentFactory = factory.clone(this.modelDB.view('cells'));
+    this._cells = new CellList(
+      this.modelDB,
+      this.contentFactory,
+      this.sharedModel
+    );
     this._trans = (options.translator || nullTranslator).load('jupyterlab');
+    this._cells.changed.connect(this._onCellsChanged, this);
+
+    // Handle initial metadata.
+    const metadata = this.modelDB.createMap('metadata');
+    if (!metadata.has('language_info')) {
+      const name = options.languagePreference || '';
+      metadata.set('language_info', { name });
+    }
+    this._ensureMetadata();
+    metadata.changed.connect(this._onMetadataChanged, this);
     this._deletedCells = [];
     this._collaborationEnabled = !!options?.collaborationEnabled;
 
-    this._cells.changed.connect(this._onCellsChanged, this);
     this.sharedModel.changed.connect(this._onStateChanged, this);
-    this.sharedModel.metadataChanged.connect(this._onMetadataChanged, this);
-  }
-
+  }
   /**
    * A signal emitted when the document content changes.
    */
@@ -138,24 +123,10 @@
   }
 
   /**
-   * Signal emitted when notebook metadata changes.
-   */
-  get metadataChanged(): ISignal<INotebookModel, IMapChange<any>> {
-    return this._metadataChanged;
-  }
-
-  /**
    * A signal emitted when the document state changes.
    */
   get stateChanged(): ISignal<this, IChangedArgs<any>> {
     return this._stateChanged;
-  }
-
-  /**
-   * Get the observable list of notebook cells.
-   */
-  get cells(): CellList {
-    return this._cells;
   }
 
   /**
@@ -194,37 +165,40 @@
 
   /**
    * The metadata associated with the notebook.
-   *
-   * ### Notes
-   * This is a copy of the metadata. Changing a part of it
-   * won't affect the model.
-   * As this returns a copy of all metadata, it is advised to
-   * use `getMetadata` to speed up the process of getting a single key.
-   */
-  get metadata(): nbformat.INotebookMetadata {
-    return this.sharedModel.metadata;
+   */
+  get metadata(): IObservableJSON {
+    return this.modelDB.get('metadata') as IObservableJSON;
+  }
+
+  /**
+   * Get the observable list of notebook cells.
+   */
+  get cells(): IObservableUndoableList<ICellModel> {
+    return this._cells;
   }
 
   /**
    * The major version number of the nbformat.
    */
   get nbformat(): number {
-    return this.sharedModel.nbformat;
+    return this._nbformat;
   }
 
   /**
    * The minor version number of the nbformat.
    */
   get nbformatMinor(): number {
-    return this.sharedModel.nbformat_minor;
+    return this._nbformatMinor;
   }
 
   /**
    * The default kernel name of the document.
    */
   get defaultKernelName(): string {
-    const spec = this.getMetadata('kernelspec');
-    return spec?.name ?? '';
+    const spec = this.metadata.get(
+      'kernelspec'
+    ) as nbformat.IKernelspecMetadata;
+    return spec ? spec.name : '';
   }
 
   /**
@@ -235,11 +209,20 @@
   }
 
   /**
+   * If the model is initialized or not.
+   */
+  get isInitialized(): boolean {
+    return this._isInitialized;
+  }
+
+  /**
    * The default kernel language of the document.
    */
   get defaultKernelLanguage(): string {
-    const info = this.getMetadata('language_info');
-    return info?.name ?? '';
+    const info = this.metadata.get(
+      'language_info'
+    ) as nbformat.ILanguageInfoMetadata;
+    return info ? info.name : '';
   }
 
   /**
@@ -257,50 +240,12 @@
     if (this.isDisposed) {
       return;
     }
-    this._isDisposed = true;
-
     const cells = this.cells;
     this._cells = null!;
     cells.dispose();
-    if (this.standaloneModel) {
-      this.sharedModel.dispose();
-    }
+    this._isDisposed = true;
+    this.modelDB.dispose();
     Signal.clearData(this);
-  }
-
-  /**
-   * Delete a metadata
-   *
-   * @param key Metadata key
-   */
-  deleteMetadata(key: string): void {
-    return this.sharedModel.deleteMetadata(key);
-  }
-
-  /**
-   * Get a metadata
-   *
-   * ### Notes
-   * This returns a copy of the key value.
-   *
-   * @param key Metadata key
-   */
-  getMetadata(key: string): any {
-    return this.sharedModel.getMetadata(key);
-  }
-
-  /**
-   * Set a metadata
-   *
-   * @param key Metadata key
-   * @param value Metadata value
-   */
-  setMetadata(key: string, value: any): void {
-    if (typeof value === 'undefined') {
-      this.sharedModel.deleteMetadata(key);
-    } else {
-      this.sharedModel.setMetadata(key, value);
-    }
   }
 
   /**
@@ -324,8 +269,26 @@
    * Serialize the model to JSON.
    */
   toJSON(): nbformat.INotebookContent {
+    const cells: nbformat.ICell[] = [];
+    for (let i = 0; i < (this.cells?.length ?? 0); i++) {
+      const cell = this.cells.get(i).toJSON();
+      if (this._nbformat === 4 && this._nbformatMinor <= 4) {
+        // strip cell ids if we have notebook format 4.0-4.4
+        delete cell.id;
+      }
+      cells.push(cell);
+    }
     this._ensureMetadata();
-    return this.sharedModel.toJSON();
+    const metadata = this.sharedModel.getMetadata();
+    for (const key of this.metadata.keys()) {
+      metadata[key] = JSON.parse(JSON.stringify(this.metadata.get(key)));
+    }
+    return {
+      metadata,
+      nbformat_minor: this._nbformatMinor,
+      nbformat: this._nbformat,
+      cells
+    };
   }
 
   /**
@@ -335,19 +298,52 @@
    * Should emit a [contentChanged] signal.
    */
   fromJSON(value: nbformat.INotebookContent): void {
-    const copy = JSONExt.deepCopy(value);
+    const cells: ICellModel[] = [];
+    const factory = this.contentFactory;
+    const useId = value.nbformat === 4 && value.nbformat_minor >= 5;
+    for (const cell of value.cells) {
+      const options: CellModel.IOptions = { cell };
+      if (useId) {
+        options.id = (cell as any).id;
+      }
+      switch (cell.cell_type) {
+        case 'code':
+          cells.push(factory.createCodeCell(options));
+          break;
+        case 'markdown':
+          cells.push(factory.createMarkdownCell(options));
+          break;
+        case 'raw':
+          cells.push(factory.createRawCell(options));
+          break;
+        default:
+          continue;
+      }
+    }
+    if (!cells.length) {
+      cells.push(factory.createCodeCell({}));
+    }
+    this.cells.beginCompoundOperation();
+    this.cells.clear();
+    this.cells.pushAll(cells);
+    this.cells.endCompoundOperation();
+
+    (this.sharedModel as models.YNotebook).nbformat_minor =
+      nbformat.MINOR_VERSION;
+    (this.sharedModel as models.YNotebook).nbformat = nbformat.MAJOR_VERSION;
     const origNbformat = value.metadata.orig_nbformat;
 
+    if (value.nbformat !== this._nbformat) {
+      (this.sharedModel as models.YNotebook).nbformat = value.nbformat;
+    }
+    if (value.nbformat_minor > this._nbformatMinor) {
+      (this.sharedModel as models.YNotebook).nbformat_minor =
+        value.nbformat_minor;
+    }
+
     // Alert the user if the format changes.
-    copy.nbformat = Math.max(value.nbformat, nbformat.MAJOR_VERSION);
-    if (
-      copy.nbformat !== value.nbformat ||
-      copy.nbformat_minor < nbformat.MINOR_VERSION
-    ) {
-      copy.nbformat_minor = nbformat.MINOR_VERSION;
-    }
-    if (origNbformat !== undefined && copy.nbformat !== origNbformat) {
-      const newer = copy.nbformat > origNbformat;
+    if (origNbformat !== undefined && this._nbformat !== origNbformat) {
+      const newer = this._nbformat > origNbformat;
       let msg: string;
 
       if (newer) {
@@ -358,7 +354,7 @@
 'Older versions of Jupyter may not be able to read the new format.' To preserve the original format version,
 close the notebook without saving it.`,
           origNbformat,
-          copy.nbformat
+          this._nbformat
         );
       } else {
         msg = this._trans.__(
@@ -368,7 +364,7 @@
 Some features of the original notebook may not be available.' To preserve the original format version,
 close the notebook without saving it.`,
           origNbformat,
-          copy.nbformat
+          this._nbformat
         );
       }
       void showDialog({
@@ -378,23 +374,41 @@
       });
     }
 
-    // Ensure there is at least one cell
-    if ((copy.cells?.length ?? 0) === 0) {
-      copy['cells'] = [
-        { cell_type: 'code', source: '', metadata: { trusted: true } }
-      ];
-    }
-    this.sharedModel.fromJSON(copy);
-
+    // Update the metadata.
+    this.metadata.clear();
+    const metadata = value.metadata;
+    for (const key in metadata) {
+      // orig_nbformat is not intended to be stored per spec.
+      if (key === 'orig_nbformat') {
+        continue;
+      }
+      this.metadata.set(key, metadata[key]);
+    }
     this._ensureMetadata();
     this.dirty = true;
   }
 
   /**
+   * Initialize the model with its current state.
+   *
+   * # Notes
+   * Adds an empty code cell if the model is empty
+   * and clears undo state.
+   */
+  initialize(): void {
+    if (!this.cells.length) {
+      const factory = this.contentFactory;
+      this.cells.push(factory.createCodeCell({}));
+    }
+    this._isInitialized = true;
+    this.cells.clearUndo();
+  }
+
+  /**
    * Handle a change in the cells list.
    */
   private _onCellsChanged(
-    list: CellList,
+    list: IObservableList<ICellModel>,
     change: IObservableList.IChangedArgs<ICellModel>
   ): void {
     switch (change.type) {
@@ -416,17 +430,9 @@
     this.triggerContentChange();
   }
 
-  private _onMetadataChanged(
-    sender: ISharedNotebook,
-    changes: IMapChange
-  ): void {
-    this._metadataChanged.emit(changes);
-    this.triggerContentChange();
-  }
-
   private _onStateChanged(
-    sender: ISharedNotebook,
-    changes: NotebookChange
+    sender: models.ISharedNotebook,
+    changes: models.NotebookChange
   ): void {
     if (changes.stateChange) {
       changes.stateChange.forEach(value => {
@@ -444,20 +450,50 @@
         }
       });
     }
+
+    if (changes.nbformatChanged) {
+      const change = changes.nbformatChanged;
+      if (change.key === 'nbformat' && change.newValue !== undefined) {
+        this._nbformat = change.newValue;
+      }
+      if (change.key === 'nbformat_minor' && change.newValue !== undefined) {
+        this._nbformatMinor = change.newValue;
+      }
+    }
+
+    if (changes.metadataChange) {
+      const metadata = this.sharedModel.getMetadata();
+      if (metadata) {
+        this._modelDBMutex(() => {
+          this.metadata.clear();
+          Object.entries(metadata).forEach(([key, value]) => {
+            this.metadata.set(key, value);
+          });
+        });
+      }
+    }
+  }
+
+  private _onMetadataChanged(
+    metadata: IObservableJSON,
+    change: IObservableMap.IChangedArgs<ReadonlyPartialJSONValue | undefined>
+  ): void {
+    this._modelDBMutex(() => {
+      this.sharedModel.setMetadata(metadata.toJSON());
+    });
+    this.triggerContentChange();
   }
 
   /**
    * Make sure we have the required metadata fields.
    */
-  private _ensureMetadata(languageName: string = ''): void {
-    if (!this.getMetadata('language_info')) {
-      this.sharedModel.setMetadata('language_info', { name: languageName });
-    }
-    if (!this.getMetadata('kernelspec')) {
-      this.sharedModel.setMetadata('kernelspec', {
-        name: '',
-        display_name: ''
-      });
+  private _ensureMetadata(): void {
+    const metadata = this.metadata;
+    if (!metadata.has('language_info')) {
+      metadata.set('language_info', { name: '' });
+    }
+    if (!metadata.has('kernelspec')) {
+      metadata.set('kernelspec', { name: '', display_name: '' });
     }
   }
 
@@ -484,14 +520,25 @@
   }
 
   /**
+   * The cell model factory for the notebook.
+   */
+  readonly contentFactory: NotebookModel.IContentFactory;
+
+  /**
    * The shared notebook model.
    */
-  readonly sharedModel: ISharedNotebook;
-
-  /**
-   * Whether the model should disposed the shared model on disposal or not.
-   */
-  protected standaloneModel = false;
+  readonly sharedModel: models.ISharedNotebook;
+
+  /**
+   * A mutex to update the shared model.
+   */
+  protected readonly _modelDBMutex = models.createMutex();
+
+  /**
+   * The underlying `IModelDB` instance in which model
+   * data is stored.
+   */
+  readonly modelDB: IModelDB;
 
   private _dirty = false;
   private _readOnly = false;
@@ -500,9 +547,11 @@
 
   private _trans: TranslationBundle;
   private _cells: CellList;
+  private _nbformat = nbformat.MAJOR_VERSION;
+  private _nbformatMinor = nbformat.MINOR_VERSION;
   private _deletedCells: string[];
+  private _isInitialized: boolean;
   private _isDisposed = false;
-  private _metadataChanged = new Signal<NotebookModel, IMapChange>(this);
   private _collaborationEnabled: boolean;
 }
 
@@ -513,17 +562,33 @@
   /**
    * An options object for initializing a notebook model.
    */
-  export interface IOptions
-    extends DocumentRegistry.IModelOptions<ISharedNotebook> {
-    /**
-     * Default cell type.
-     */
-    defaultCell?: 'code' | 'markdown' | 'raw';
+  export interface IOptions {
+    /**
+     * The language preference for the model.
+     */
+    languagePreference?: string;
+
+    /**
+     * A factory for creating cell models.
+     *
+     * The default is a shared factory instance.
+     */
+    contentFactory?: IContentFactory;
+
+    /**
+     * A modelDB for storing notebook data.
+     */
+    modelDB?: IModelDB;
 
     /**
      * Language translator.
      */
     translator?: ITranslator;
+
+    /**
+     * If the model is initialized or not.
+     */
+    isInitialized?: boolean;
 
     /**
      * Defines if the document can be undo/redo.
@@ -534,5 +599,220 @@
      * @alpha
      */
     disableDocumentWideUndoRedo?: boolean;
-  }
+
+    /**
+     * Whether collaboration should be enabled for this document model.
+     */
+    collaborationEnabled?: boolean;
+  }
+
+  /**
+   * A factory for creating notebook model content.
+   */
+  export interface IContentFactory {
+    /**
+     * The factory for output area models.
+     */
+    readonly codeCellContentFactory: CodeCellModel.IContentFactory;
+
+    /**
+     * The IModelDB in which to put data for the notebook model.
+     */
+    modelDB: IModelDB | undefined;
+
+    /**
+     * Create a new cell by cell type.
+     *
+     * @param type:  the type of the cell to create.
+     *
+     * @param options: the cell creation options.
+     *
+     * #### Notes
+     * This method is intended to be a convenience method to programmatically
+     * call the other cell creation methods in the factory.
+     */
+    createCell(
+      type: nbformat.CellType,
+      options: CellModel.IOptions
+    ): ICellModel;
+
+    /**
+     * Create a new code cell.
+     *
+     * @param options - The options used to create the cell.
+     *
+     * @returns A new code cell. If a source cell is provided, the
+     *   new cell will be initialized with the data from the source.
+     */
+    createCodeCell(options: CodeCellModel.IOptions): ICodeCellModel;
+
+    /**
+     * Create a new markdown cell.
+     *
+     * @param options - The options used to create the cell.
+     *
+     * @returns A new markdown cell. If a source cell is provided, the
+     *   new cell will be initialized with the data from the source.
+     */
+    createMarkdownCell(options: CellModel.IOptions): IMarkdownCellModel;
+
+    /**
+     * Create a new raw cell.
+     *
+     * @param options - The options used to create the cell.
+     *
+     * @returns A new raw cell. If a source cell is provided, the
+     *   new cell will be initialized with the data from the source.
+     */
+    createRawCell(options: CellModel.IOptions): IRawCellModel;
+
+    /**
+     * Clone the content factory with a new IModelDB.
+     */
+    clone(modelDB: IModelDB): IContentFactory;
+  }
+
+  /**
+   * The default implementation of an `IContentFactory`.
+   */
+  export class ContentFactory {
+    /**
+     * Create a new cell model factory.
+     */
+    constructor(options: ContentFactory.IOptions) {
+      this.codeCellContentFactory =
+        options.codeCellContentFactory || CodeCellModel.defaultContentFactory;
+      this.modelDB = options.modelDB;
+    }
+
+    /**
+     * The factory for code cell content.
+     */
+    readonly codeCellContentFactory: CodeCellModel.IContentFactory;
+
+    /**
+     * The IModelDB in which to put the notebook data.
+     */
+    readonly modelDB: IModelDB | undefined;
+
+    /**
+     * Create a new cell by cell type.
+     *
+     * @param type:  the type of the cell to create.
+     *
+     * @param options: the cell creation options.
+     *
+     * #### Notes
+     * This method is intended to be a convenience method to programmatically
+     * call the other cell creation methods in the factory.
+     */
+    createCell(
+      type: nbformat.CellType,
+      options: CellModel.IOptions
+    ): ICellModel {
+      switch (type) {
+        case 'code':
+          return this.createCodeCell(options);
+        case 'markdown':
+          return this.createMarkdownCell(options);
+        case 'raw':
+        default:
+          return this.createRawCell(options);
+      }
+    }
+
+    /**
+     * Create a new code cell.
+     *
+     * @param source - The data to use for the original source data.
+     *
+     * @returns A new code cell. If a source cell is provided, the
+     *   new cell will be initialized with the data from the source.
+     *   If the contentFactory is not provided, the instance
+     *   `codeCellContentFactory` will be used.
+     */
+    createCodeCell(options: CodeCellModel.IOptions): ICodeCellModel {
+      if (options.contentFactory) {
+        options.contentFactory = this.codeCellContentFactory;
+      }
+      if (this.modelDB) {
+        if (!options.id) {
+          options.id = UUID.uuid4();
+        }
+        options.modelDB = this.modelDB.view(options.id);
+      }
+      return new CodeCellModel(options);
+    }
+
+    /**
+     * Create a new markdown cell.
+     *
+     * @param source - The data to use for the original source data.
+     *
+     * @returns A new markdown cell. If a source cell is provided, the
+     *   new cell will be initialized with the data from the source.
+     */
+    createMarkdownCell(options: CellModel.IOptions): IMarkdownCellModel {
+      if (this.modelDB) {
+        if (!options.id) {
+          options.id = UUID.uuid4();
+        }
+        options.modelDB = this.modelDB.view(options.id);
+      }
+      return new MarkdownCellModel(options);
+    }
+
+    /**
+     * Create a new raw cell.
+     *
+     * @param source - The data to use for the original source data.
+     *
+     * @returns A new raw cell. If a source cell is provided, the
+     *   new cell will be initialized with the data from the source.
+     */
+    createRawCell(options: CellModel.IOptions): IRawCellModel {
+      if (this.modelDB) {
+        if (!options.id) {
+          options.id = UUID.uuid4();
+        }
+        options.modelDB = this.modelDB.view(options.id);
+      }
+      return new RawCellModel(options);
+    }
+
+    /**
+     * Clone the content factory with a new IModelDB.
+     */
+    clone(modelDB: IModelDB): ContentFactory {
+      return new ContentFactory({
+        modelDB: modelDB,
+        codeCellContentFactory: this.codeCellContentFactory
+      });
+    }
+  }
+
+  /**
+   * A namespace for the notebook model content factory.
+   */
+  export namespace ContentFactory {
+    /**
+     * The options used to initialize a `ContentFactory`.
+     */
+    export interface IOptions {
+      /**
+       * The factory for code cell model content.
+       */
+      codeCellContentFactory?: CodeCellModel.IContentFactory;
+
+      /**
+       * The modelDB in which to place new content.
+       */
+      modelDB?: IModelDB;
+    }
+  }
+
+  /**
+   * The default `ContentFactory` instance.
+   */
+  export const defaultContentFactory = new ContentFactory({});
 }