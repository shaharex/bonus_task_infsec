--- packages\notebook\src\notebooktools.ts (old)
+++ packages\notebook\src\notebooktools.ts (new)
@@ -1,15 +1,27 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
+import { Collapse, Styling } from '@jupyterlab/apputils';
 import { Cell, ICellModel } from '@jupyterlab/cells';
-import { CodeEditor, JSONEditor } from '@jupyterlab/codeeditor';
-import { ObservableJSON } from '@jupyterlab/observables';
-import { IMapChange } from '@jupyter/ydoc';
-import { ITranslator, nullTranslator } from '@jupyterlab/translation';
-import { Collapser } from '@jupyterlab/ui-components';
-import { ArrayExt } from '@lumino/algorithm';
-import { ReadonlyPartialJSONValue } from '@lumino/coreutils';
+import {
+  CodeEditor,
+  CodeEditorWrapper,
+  JSONEditor
+} from '@jupyterlab/codeeditor';
+import * as nbformat from '@jupyterlab/nbformat';
+import { IObservableMap, ObservableJSON } from '@jupyterlab/observables';
+import {
+  ITranslator,
+  nullTranslator,
+  TranslationBundle
+} from '@jupyterlab/translation';
+import { ArrayExt, chain, each } from '@lumino/algorithm';
+import {
+  ReadonlyPartialJSONObject,
+  ReadonlyPartialJSONValue
+} from '@lumino/coreutils';
 import { ConflatableMessage, Message, MessageLoop } from '@lumino/messaging';
+import { h, VirtualDOM, VirtualNode } from '@lumino/virtualdom';
 import { PanelLayout, Widget } from '@lumino/widgets';
 import { INotebookModel } from './model';
 import { NotebookPanel } from './panel';
@@ -60,10 +72,14 @@
     this.addClass('jp-NotebookTools');
 
     this.translator = options.translator || nullTranslator;
-
-    this._tools = [];
-
-    this.layout = new PanelLayout();
+    this._trans = this.translator.load('jupyterlab');
+    this._commonTools = new RankedPanel<NotebookTools.Tool>();
+    this._advancedTools = new RankedPanel<NotebookTools.Tool>();
+    this._advancedTools.title.label = this._trans.__('Advanced Tools');
+
+    const layout = (this.layout = new PanelLayout());
+    layout.addWidget(this._commonTools);
+    layout.addWidget(new Collapse({ widget: this._advancedTools }));
 
     this._tracker = options.tracker;
     this._tracker.currentChanged.connect(
@@ -111,12 +127,10 @@
     const rank = options.rank ?? 100;
 
     let section: RankedPanel<NotebookTools.Tool>;
-    const extendedTool = this._tools.find(
-      extendedTool => extendedTool.section === options.section
-    );
-    if (extendedTool) section = extendedTool.panel;
-    else {
-      throw new Error(`The section ${options.section} does not exist`);
+    if (options.section === 'advanced') {
+      section = this._advancedTools;
+    } else {
+      section = this._commonTools;
     }
 
     tool.addClass('jp-NotebookTools-tool');
@@ -130,57 +144,6 @@
     MessageLoop.sendMessage(tool, NotebookTools.ActiveCellMessage);
   }
 
-  /*
-   * Add a section to the notebook tool with its widget
-   */
-  addSection(options: NotebookTools.IAddSectionOptions): void {
-    const sectionName = options.sectionName;
-    const label = options.label || options.sectionName;
-    const widget = options.tool;
-    let rank = options.rank ?? null;
-
-    const newSection = new RankedPanel<NotebookTools.Tool>();
-    newSection.title.label = label;
-
-    if (widget) newSection.addWidget(widget, 0);
-
-    this._tools.push({
-      section: sectionName,
-      panel: newSection,
-      rank: rank
-    });
-
-    if (rank != null)
-      (this.layout as PanelLayout).insertWidget(
-        rank,
-        new Collapser({ widget: newSection })
-      );
-    else {
-      // If no rank is provided, try to add the new section before the AdvancedTools.
-      let advancedToolsRank = null;
-      const layout = this.layout as PanelLayout;
-      for (let i = 0; i < layout.widgets.length; i++) {
-        let w = layout.widgets[i];
-        if (w instanceof Collapser) {
-          if (w.widget.id === 'advancedToolsSection') {
-            advancedToolsRank = i;
-            break;
-          }
-        }
-      }
-
-      if (advancedToolsRank !== null)
-        (this.layout as PanelLayout).insertWidget(
-          advancedToolsRank,
-          new Collapser({ widget: newSection })
-        );
-      else
-        (this.layout as PanelLayout).addWidget(
-          new Collapser({ widget: newSection })
-        );
-    }
-  }
-
   /**
    * Handle a change to the notebook panel.
    */
@@ -189,7 +152,7 @@
       this._prevActiveNotebookModel &&
       !this._prevActiveNotebookModel.isDisposed
     ) {
-      this._prevActiveNotebookModel.metadataChanged.disconnect(
+      this._prevActiveNotebookModel.metadata.changed.disconnect(
         this._onActiveNotebookPanelMetadataChanged,
         this
       );
@@ -200,14 +163,14 @@
         : null;
     this._prevActiveNotebookModel = activeNBModel;
     if (activeNBModel) {
-      activeNBModel.metadataChanged.connect(
+      activeNBModel.metadata.changed.connect(
         this._onActiveNotebookPanelMetadataChanged,
         this
       );
     }
-    for (const widget of this._toolChildren()) {
+    each(this._toolChildren(), widget => {
       MessageLoop.sendMessage(widget, NotebookTools.ActiveNotebookPanelMessage);
-    }
+    });
   }
 
   /**
@@ -215,7 +178,7 @@
    */
   private _onActiveCellChanged(): void {
     if (this._prevActiveCell && !this._prevActiveCell.isDisposed) {
-      this._prevActiveCell.metadataChanged.disconnect(
+      this._prevActiveCell.metadata.changed.disconnect(
         this._onActiveCellMetadataChanged,
         this
       );
@@ -223,65 +186,65 @@
     const activeCell = this.activeCell ? this.activeCell.model : null;
     this._prevActiveCell = activeCell;
     if (activeCell) {
-      activeCell.metadataChanged.connect(
+      activeCell.metadata.changed.connect(
         this._onActiveCellMetadataChanged,
         this
       );
     }
-    for (const widget of this._toolChildren()) {
+    each(this._toolChildren(), widget => {
       MessageLoop.sendMessage(widget, NotebookTools.ActiveCellMessage);
-    }
+    });
   }
 
   /**
    * Handle a change in the selection.
    */
   private _onSelectionChanged(): void {
-    for (const widget of this._toolChildren()) {
+    each(this._toolChildren(), widget => {
       MessageLoop.sendMessage(widget, NotebookTools.SelectionMessage);
-    }
+    });
   }
 
   /**
    * Handle a change in the active cell metadata.
    */
   private _onActiveNotebookPanelMetadataChanged(
-    sender: INotebookModel,
-    args: IMapChange
+    sender: IObservableMap<ReadonlyPartialJSONValue | undefined>,
+    args: IObservableMap.IChangedArgs<ReadonlyPartialJSONValue>
   ): void {
     const message = new ObservableJSON.ChangeMessage(
       'activenotebookpanel-metadata-changed',
-      { oldValue: undefined, newValue: undefined, ...args }
+      args
     );
-    for (const widget of this._toolChildren()) {
+    each(this._toolChildren(), widget => {
       MessageLoop.sendMessage(widget, message);
-    }
+    });
   }
 
   /**
    * Handle a change in the notebook model metadata.
    */
   private _onActiveCellMetadataChanged(
-    sender: ICellModel,
-    args: IMapChange
+    sender: IObservableMap<ReadonlyPartialJSONValue | undefined>,
+    args: IObservableMap.IChangedArgs<ReadonlyPartialJSONValue>
   ): void {
     const message = new ObservableJSON.ChangeMessage(
       'activecell-metadata-changed',
-      { newValue: undefined, oldValue: undefined, ...args }
+      args
     );
-    for (const widget of this._toolChildren()) {
+    each(this._toolChildren(), widget => {
       MessageLoop.sendMessage(widget, message);
-    }
-  }
-
-  private *_toolChildren() {
-    for (let tool of this._tools) {
-      yield* tool.panel.children();
-    }
+    });
+  }
+
+  private _toolChildren() {
+    return chain(this._commonTools.children(), this._advancedTools.children());
   }
 
   translator: ITranslator;
-  private _tools: Array<NotebookTools.IToolPanel>;
+  private _trans: TranslationBundle;
+  private _commonTools: RankedPanel<NotebookTools.Tool>;
+  private _advancedTools: RankedPanel<NotebookTools.Tool>;
   private _tracker: INotebookTracker;
   private _prevActiveCell: ICellModel | null;
   private _prevActiveNotebookModel: INotebookModel | null;
@@ -303,26 +266,6 @@
   ][];
 
   /**
-   * Interface for an extended panel section.
-   */
-  export interface IToolPanel {
-    /**
-     * The name of the section.
-     */
-    section: string;
-
-    /**
-     * The associated panel, only one for a section.
-     */
-    panel: RankedPanel<NotebookTools.Tool>;
-
-    /**
-     * The rank of the section on the notebooktools panel.
-     */
-    rank?: number | null;
-  }
-
-  /**
    * The options used to create a NotebookTools object.
    */
   export interface IOptions {
@@ -344,40 +287,15 @@
     /**
      * The tool to add to the notebook tools area.
      */
-    tool: INotebookTools.ITool;
+    tool: Tool;
 
     /**
      * The section to which the tool should be added.
      */
-    section: string;
+    section?: 'common' | 'advanced';
 
     /**
      * The rank order of the widget among its siblings.
-     */
-    rank?: number;
-  }
-
-  /**
-   * The options used to add a section to the notebook tools.
-   */
-  export interface IAddSectionOptions {
-    /**
-     * The name of the new section.
-     */
-    sectionName: string;
-
-    /**
-     * The tool to add to the notebook tools area.
-     */
-    tool?: INotebookTools.ITool;
-
-    /**
-     * The label of the new section.
-     */
-    label?: string;
-
-    /**
-     * The rank order of the section among its siblings.
      */
     rank?: number;
   }
@@ -408,7 +326,7 @@
      */
     notebookTools: INotebookTools;
 
-    dispose(): void {
+    dispose() {
       super.dispose();
       if (this.notebookTools) {
         this.notebookTools = null!;
@@ -501,6 +419,109 @@
   }
 
   /**
+   * A cell tool displaying the active cell contents.
+   */
+  export class ActiveCellTool extends Tool {
+    /**
+     * Construct a new active cell tool.
+     */
+    constructor() {
+      super();
+      this.addClass('jp-ActiveCellTool');
+      this.addClass('jp-InputArea');
+      this.layout = new PanelLayout();
+    }
+
+    /**
+     * Dispose of the resources used by the tool.
+     */
+    dispose() {
+      if (this._model === null) {
+        return;
+      }
+      this._model.dispose();
+      this._model = null!;
+      super.dispose();
+    }
+
+    /**
+     * Handle a change to the active cell.
+     */
+    protected onActiveCellChanged(): void {
+      const activeCell = this.notebookTools.activeCell;
+      const layout = this.layout as PanelLayout;
+      const count = layout.widgets.length;
+      for (let i = 0; i < count; i++) {
+        layout.widgets[0].dispose();
+      }
+      if (this._cellModel && !this._cellModel.isDisposed) {
+        this._cellModel.value.changed.disconnect(this._onValueChanged, this);
+        this._cellModel.mimeTypeChanged.disconnect(
+          this._onMimeTypeChanged,
+          this
+        );
+      }
+      if (!activeCell) {
+        const cell = new Widget();
+        cell.addClass('jp-InputArea-editor');
+        cell.addClass('jp-InputArea-editor');
+        layout.addWidget(cell);
+        this._cellModel = null;
+        return;
+      }
+      const promptNode = activeCell.promptNode
+        ? (activeCell.promptNode.cloneNode(true) as HTMLElement)
+        : undefined;
+      const prompt = new Widget({ node: promptNode });
+      const factory = activeCell.contentFactory.editorFactory;
+
+      const cellModel = (this._cellModel = activeCell.model);
+      cellModel.value.changed.connect(this._onValueChanged, this);
+      cellModel.mimeTypeChanged.connect(this._onMimeTypeChanged, this);
+      this._model.value.text = cellModel.value.text.split('\n')[0];
+      this._model.mimeType = cellModel.mimeType;
+
+      const model = this._model;
+      const editorWidget = new CodeEditorWrapper({ model, factory });
+      editorWidget.addClass('jp-InputArea-editor');
+      editorWidget.addClass('jp-InputArea-editor');
+      editorWidget.editor.setOption('readOnly', true);
+      layout.addWidget(prompt);
+      layout.addWidget(editorWidget);
+    }
+
+    /**
+     * Handle a change to the notebook panel.
+     *
+     * #### Notes
+     * The default implementation is a no-op.
+     */
+    protected onActiveNotebookPanelChanged(msg: Message): void {
+      if (!this.notebookTools.activeNotebookPanel) {
+        // Force cleaning up the signal
+        void this.onActiveCellChanged();
+      }
+    }
+
+    /**
+     * Handle a change to the current editor value.
+     */
+    private _onValueChanged(): void {
+      this._model.value.text = this._cellModel!.value.text.split('\n')[0];
+    }
+
+    /**
+     * Handle a change to the current editor mimetype.
+     */
+    private _onMimeTypeChanged(): void {
+      this._model.mimeType = this._cellModel!.mimeType;
+    }
+
+    private _model = new CodeEditor.Model();
+    private _cellModel: CodeEditor.IModel | null;
+  }
+
+  /**
    * A raw metadata editor.
    */
   export class MetadataEditorTool extends Tool {
@@ -582,6 +603,368 @@
       translator?: ITranslator;
     }
   }
+
+  /**
+   * A notebook metadata editor
+   */
+  export class NotebookMetadataEditorTool extends MetadataEditorTool {
+    constructor(options: MetadataEditorTool.IOptions) {
+      const translator = options.translator || nullTranslator;
+      const trans = translator.load('jupyterlab');
+      options.label = options.label || trans.__('Notebook Metadata');
+      super(options);
+    }
+
+    /**
+     * Handle a change to the notebook.
+     */
+    protected onActiveNotebookPanelChanged(msg: Message): void {
+      super.onActiveNotebookPanelChanged(msg);
+      if (this.notebookTools.activeNotebookPanel) {
+        this._update();
+      }
+    }
+
+    /**
+     * Handle a change to the notebook metadata.
+     */
+    protected onActiveNotebookPanelMetadataChanged(msg: Message): void {
+      this._update();
+    }
+
+    private _update() {
+      const nb =
+        this.notebookTools.activeNotebookPanel &&
+        this.notebookTools.activeNotebookPanel.content;
+      this.editor.source = nb?.model?.metadata ?? null;
+    }
+  }
+
+  /**
+   * A cell metadata editor
+   */
+  export class CellMetadataEditorTool extends MetadataEditorTool {
+    constructor(options: MetadataEditorTool.IOptions) {
+      const translator = options.translator || nullTranslator;
+      const trans = translator.load('jupyterlab');
+      options.label = options.label || trans.__('Cell Metadata');
+      super(options);
+    }
+
+    /**
+     * Handle a change to the active cell.
+     */
+    protected onActiveCellChanged(msg: Message): void {
+      this.editor.dispose();
+      if (this.notebookTools.activeCell) {
+        this.createEditor();
+        this._update();
+      }
+    }
+
+    /**
+     * Handle a change to the active cell metadata.
+     */
+    protected onActiveCellMetadataChanged(msg: Message): void {
+      this._update();
+    }
+
+    private _update() {
+      const cell = this.notebookTools.activeCell;
+      this.editor.source = cell ? cell.model.metadata : null;
+    }
+  }
+
+  /**
+   * A cell tool that provides a selection for a given metadata key.
+   */
+  export class KeySelector extends Tool {
+    /**
+     * Construct a new KeySelector.
+     */
+    constructor(options: KeySelector.IOptions) {
+      // TODO: use react
+      super({ node: Private.createSelectorNode(options) });
+      this.addClass('jp-KeySelector');
+      this.key = options.key;
+      this._default = options.default;
+      this._validCellTypes = options.validCellTypes || [];
+      this._getter = options.getter || this._getValue;
+      this._setter = options.setter || this._setValue;
+    }
+
+    /**
+     * The metadata key used by the selector.
+     */
+    readonly key: string;
+
+    /**
+     * The select node for the widget.
+     */
+    get selectNode(): HTMLSelectElement {
+      return this.node.getElementsByTagName('select')[0] as HTMLSelectElement;
+    }
+
+    /**
+     * Handle the DOM events for the widget.
+     *
+     * @param event - The DOM event sent to the widget.
+     *
+     * #### Notes
+     * This method implements the DOM `EventListener` interface and is
+     * called in response to events on the notebook panel's node. It should
+     * not be called directly by user code.
+     */
+    handleEvent(event: Event): void {
+      switch (event.type) {
+        case 'change':
+          this.onValueChanged();
+          break;
+        default:
+          break;
+      }
+    }
+
+    /**
+     * Handle `after-attach` messages for the widget.
+     */
+    protected onAfterAttach(msg: Message): void {
+      const node = this.selectNode;
+      node.addEventListener('change', this);
+    }
+
+    /**
+     * Handle `before-detach` messages for the widget.
+     */
+    protected onBeforeDetach(msg: Message): void {
+      const node = this.selectNode;
+      node.removeEventListener('change', this);
+    }
+
+    /**
+     * Handle a change to the active cell.
+     */
+    protected onActiveCellChanged(msg: Message): void {
+      const select = this.selectNode;
+      const activeCell = this.notebookTools.activeCell;
+      if (!activeCell) {
+        select.disabled = true;
+        select.value = '';
+        return;
+      }
+      const cellType = activeCell.model.type;
+      if (
+        this._validCellTypes.length &&
+        this._validCellTypes.indexOf(cellType) === -1
+      ) {
+        select.value = '';
+        select.disabled = true;
+        return;
+      }
+      select.disabled = false;
+      this._changeGuard = true;
+      const getter = this._getter;
+      select.value = JSON.stringify(getter(activeCell));
+      this._changeGuard = false;
+    }
+
+    /**
+     * Handle a change to the metadata of the active cell.
+     */
+    protected onActiveCellMetadataChanged(msg: ObservableJSON.ChangeMessage) {
+      if (this._changeGuard) {
+        return;
+      }
+      const select = this.selectNode;
+      const cell = this.notebookTools.activeCell;
+      if (msg.args.key === this.key && cell) {
+        this._changeGuard = true;
+        const getter = this._getter;
+        select.value = JSON.stringify(getter(cell));
+        this._changeGuard = false;
+      }
+    }
+
+    /**
+     * Handle a change to the value.
+     */
+    protected onValueChanged(): void {
+      const activeCell = this.notebookTools.activeCell;
+      if (!activeCell || this._changeGuard) {
+        return;
+      }
+      this._changeGuard = true;
+      const select = this.selectNode;
+      const setter = this._setter;
+      setter(activeCell, JSON.parse(select.value));
+      this._changeGuard = false;
+    }
+
+    /**
+     * Get the value for the data.
+     */
+    private _getValue = (cell: Cell) => {
+      let value = cell.model.metadata.get(this.key);
+      if (value === undefined) {
+        value = this._default;
+      }
+      return value;
+    };
+
+    /**
+     * Set the value for the data.
+     */
+    private _setValue = (
+      cell: Cell,
+      value: ReadonlyPartialJSONValue | undefined
+    ) => {
+      if (value === this._default) {
+        cell.model.metadata.delete(this.key);
+      } else {
+        cell.model.metadata.set(this.key, value);
+      }
+    };
+
+    private _changeGuard = false;
+    private _validCellTypes: string[];
+    private _getter: (cell: Cell) => ReadonlyPartialJSONValue | undefined;
+    private _setter: (
+      cell: Cell,
+      value: ReadonlyPartialJSONValue | undefined
+    ) => void;
+    private _default: ReadonlyPartialJSONValue | undefined;
+  }
+
+  /**
+   * The namespace for `KeySelector` static data.
+   */
+  export namespace KeySelector {
+    /**
+     * The options used to initialize a keyselector.
+     */
+    export interface IOptions {
+      /**
+       * The metadata key of interest.
+       */
+      key: string;
+
+      /**
+       * The map of values to options.
+       *
+       * Value corresponds to the unique identifier.
+       * Option corresponds to the localizable value to display.
+       *
+       * See: `<option value="volvo">Volvo</option>`
+       *
+       * #### Notes
+       * If a value equals the default, choosing it may erase the key from the
+       * metadata.
+       */
+      optionValueArray: ReadonlyPartialJSONOptionValueArray;
+
+      /**
+       * The optional title of the selector - defaults to capitalized `key`.
+       */
+      title: string;
+
+      /**
+       * The optional valid cell types - defaults to all valid types.
+       */
+      validCellTypes?: nbformat.CellType[];
+
+      /**
+       * An optional value getter for the selector.
+       *
+       * @param cell - The currently active cell.
+       *
+       * @returns The appropriate value for the selector.
+       */
+      getter?: (cell: Cell) => ReadonlyPartialJSONValue | undefined;
+
+      /**
+       * An optional value setter for the selector.
+       *
+       * @param cell - The currently active cell.
+       *
+       * @param value - The value of the selector.
+       *
+       * #### Notes
+       * The setter should set the appropriate metadata value given the value of
+       * the selector.
+       */
+      setter?: (
+        cell: Cell,
+        value: ReadonlyPartialJSONValue | undefined
+      ) => void;
+
+      /**
+       * Default value for default setters and getters if value is not found.
+       */
+      default?: ReadonlyPartialJSONValue;
+    }
+  }
+
+  /**
+   * Create a slideshow selector.
+   */
+  export function createSlideShowSelector(
+    translator?: ITranslator
+  ): KeySelector {
+    translator = translator || nullTranslator;
+    const trans = translator.load('jupyterlab');
+    trans.__('');
+    const options: KeySelector.IOptions = {
+      key: 'slideshow',
+      title: trans.__('Slide Type'),
+      optionValueArray: [
+        ['-', null],
+        [trans.__('Slide'), 'slide'],
+        [trans.__('Sub-Slide'), 'subslide'],
+        [trans.__('Fragment'), 'fragment'],
+        [trans.__('Skip'), 'skip'],
+        [trans.__('Notes'), 'notes']
+      ],
+      getter: cell => {
+        const value = cell.model.metadata.get('slideshow') as
+          | ReadonlyPartialJSONObject
+          | undefined;
+        return value && value['slide_type'];
+      },
+      setter: (cell, value) => {
+        let data = cell.model.metadata.get('slideshow') || Object.create(null);
+        if (value === null) {
+          // Make a shallow copy so we aren't modifying the original metadata.
+          data = { ...data };
+          delete data.slide_type;
+        } else {
+          data = { ...data, slide_type: value };
+        }
+        if (Object.keys(data).length > 0) {
+          cell.model.metadata.set('slideshow', data);
+        } else {
+          cell.model.metadata.delete('slideshow');
+        }
+      }
+    };
+    return new KeySelector(options);
+  }
+
+  /**
+   * Create an nbconvert selector.
+   */
+  export function createNBConvertSelector(
+    optionValueArray: ReadonlyPartialJSONOptionValueArray,
+    translator?: ITranslator
+  ): KeySelector {
+    translator = translator || nullTranslator;
+    const trans = translator.load('jupyterlab');
+    return new KeySelector({
+      key: 'raw_mimetype',
+      title: trans.__('Raw NBConvert Format'),
+      optionValueArray: optionValueArray,
+      validCellTypes: ['raw']
+    });
+  }
 }
 
 /**
@@ -609,4 +992,27 @@
   export function itemCmp(first: IRankItem, second: IRankItem): number {
     return first.rank - second.rank;
   }
+
+  /**
+   * Create the node for a KeySelector.
+   */
+  export function createSelectorNode(
+    options: NotebookTools.KeySelector.IOptions
+  ): HTMLElement {
+    const name = options.key;
+    const title = options.title || name[0].toLocaleUpperCase() + name.slice(1);
+    const optionNodes: VirtualNode[] = [];
+    let value: any;
+    let option: any;
+    each(options.optionValueArray, item => {
+      option = item[0];
+      value = JSON.stringify(item[1]);
+      optionNodes.push(h.option({ value }, option));
+    });
+    const node = VirtualDOM.realize(
+      h.div({}, h.label(title, h.select({}, optionNodes)))
+    );
+    Styling.styleNode(node);
+    return node;
+  }
 }