--- packages\notebook\src\widget.ts (old)
+++ packages\notebook\src\widget.ts (new)
@@ -1,7 +1,6 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
-import { DOMUtils } from '@jupyterlab/apputils';
 import {
   Cell,
   CodeCell,
@@ -15,29 +14,20 @@
 import { CodeEditor, IEditorMimeTypeService } from '@jupyterlab/codeeditor';
 import { IChangedArgs } from '@jupyterlab/coreutils';
 import * as nbformat from '@jupyterlab/nbformat';
-import { IObservableList } from '@jupyterlab/observables';
+import { IObservableList, IObservableMap } from '@jupyterlab/observables';
 import { IRenderMimeRegistry } from '@jupyterlab/rendermime';
-import type { IMapChange } from '@jupyter/ydoc';
-import { TableOfContentsUtils } from '@jupyterlab/toc';
 import { ITranslator, nullTranslator } from '@jupyterlab/translation';
-import { WindowedList } from '@jupyterlab/ui-components';
-import { ArrayExt, findIndex } from '@lumino/algorithm';
-import { MimeData } from '@lumino/coreutils';
+import { ArrayExt, each, findIndex } from '@lumino/algorithm';
+import { MimeData, ReadonlyPartialJSONValue } from '@lumino/coreutils';
 import { ElementExt } from '@lumino/domutils';
-import { Drag } from '@lumino/dragdrop';
+import { Drag, IDragEvent } from '@lumino/dragdrop';
 import { Message } from '@lumino/messaging';
 import { AttachedProperty } from '@lumino/properties';
 import { ISignal, Signal } from '@lumino/signaling';
 import { h, VirtualDOM } from '@lumino/virtualdom';
 import { PanelLayout, Widget } from '@lumino/widgets';
 import { NotebookActions } from './actions';
-import { CellList } from './celllist';
-import { DROP_SOURCE_CLASS, DROP_TARGET_CLASS } from './constants';
-import { INotebookHistory } from './history';
 import { INotebookModel } from './model';
-import { NotebookViewModel, NotebookWindowedLayout } from './windowing';
-import { NotebookFooter } from './notebookfooter';
-import { CodeCellModel } from '../../cells/src/model';
 
 /**
  * The data attribute added to a widget that has an active kernel.
@@ -95,12 +85,14 @@
 const UNCONFINED_CLASS = 'jp-mod-unconfined';
 
 /**
- * The class name added to the notebook when an element within it is focused
- * and takes keyboard input, such as focused <input> or <div contenteditable>.
- *
- * This class is also effective when the focused element is in shadow DOM.
- */
-const READ_WRITE_CLASS = 'jp-mod-readWrite';
+ * The class name added to a drop target.
+ */
+const DROP_TARGET_CLASS = 'jp-mod-dropTarget';
+
+/**
+ * The class name added to a drop source.
+ */
+const DROP_SOURCE_CLASS = 'jp-mod-dropSource';
 
 /**
  * The class name added to drag images.
@@ -137,12 +129,10 @@
  */
 const DRAG_THRESHOLD = 5;
 
-/**
- * Maximal remaining time for idle callback
- *
- * Ref: https://developer.mozilla.org/en-US/docs/Web/API/Background_Tasks_API#getting_the_most_out_of_idle_callbacks
- */
-const MAXIMUM_TIME_REMAINING = 50;
+/*
+ * The type of cell insert provided via signal.
+ */
+type InsertType = 'push' | 'insert' | 'set';
 
 /*
  * The rendering mode for the notebook.
@@ -153,12 +143,6 @@
  * The class attached to the heading collapser button
  */
 const HEADING_COLLAPSER_CLASS = 'jp-collapseHeadingButton';
-
-/**
- * The class that controls the visibility of "heading collapser" and "show hidden cells" buttons.
- */
-const HEADING_COLLAPSER_VISBILITY_CONTROL_CLASS =
-  'jp-mod-showHiddenCellsButton';
 
 const SIDE_BY_SIDE_CLASS = 'jp-mod-sideBySide';
 
@@ -170,7 +154,6 @@
 if ((window as any).requestIdleCallback === undefined) {
   // On Safari, requestIdleCallback is not available, so we use replacement functions for `idleCallbacks`
   // See: https://developer.mozilla.org/en-US/docs/Web/API/Background_Tasks_API#falling_back_to_settimeout
-  // eslint-disable-next-line @typescript-eslint/ban-types
   (window as any).requestIdleCallback = function (handler: Function) {
     let startTime = Date.now();
     return setTimeout(function () {
@@ -197,60 +180,66 @@
  * `null` model, and may want to listen to the `modelChanged`
  * signal.
  */
-export class StaticNotebook extends WindowedList<NotebookViewModel> {
+export class StaticNotebook extends Widget {
   /**
    * Construct a notebook widget.
    */
   constructor(options: StaticNotebook.IOptions) {
-    const cells = new Array<Cell>();
-    const windowingActive =
-      (options.notebookConfig?.windowingMode ??
-        StaticNotebook.defaultNotebookConfig.windowingMode) === 'full';
-    super({
-      model: new NotebookViewModel(cells, {
-        overscanCount:
-          options.notebookConfig?.overscanCount ??
-          StaticNotebook.defaultNotebookConfig.overscanCount,
-        windowingActive
-      }),
-      layout: new NotebookWindowedLayout(),
-      renderer: options.renderer ?? WindowedList.defaultRenderer,
-      scrollbar: false
-    });
+    super();
     this.addClass(NB_CLASS);
-    this.cellsArray = cells;
-
-    this._idleCallBack = null;
-
-    this._editorConfig = StaticNotebook.defaultEditorConfig;
-    this._notebookConfig = StaticNotebook.defaultNotebookConfig;
-    this._mimetype = IEditorMimeTypeService.defaultMimeType;
-    this._notebookModel = null;
-    this._modelChanged = new Signal<this, void>(this);
-    this._modelContentChanged = new Signal<this, void>(this);
-
     this.node.dataset[KERNEL_USER] = 'true';
     this.node.dataset[UNDOER] = 'true';
     this.node.dataset[CODE_RUNNER] = 'true';
     this.rendermime = options.rendermime;
-    this.translator = options.translator || nullTranslator;
-    this.contentFactory = options.contentFactory;
+    this.translator = options.translator ?? nullTranslator;
+    this.layout = new Private.NotebookPanelLayout();
+    this.contentFactory =
+      options.contentFactory || StaticNotebook.defaultContentFactory;
     this.editorConfig =
       options.editorConfig || StaticNotebook.defaultEditorConfig;
     this.notebookConfig =
       options.notebookConfig || StaticNotebook.defaultNotebookConfig;
-    this._updateNotebookConfig();
     this._mimetypeService = options.mimeTypeService;
     this.renderingLayout = options.notebookConfig?.renderingLayout;
-    this.kernelHistory = options.kernelHistory;
-  }
-
-  get cellCollapsed(): ISignal<this, Cell> {
-    return this._cellCollapsed;
-  }
-
-  get cellInViewportChanged(): ISignal<this, Cell> {
-    return this._cellInViewportChanged;
+
+    // Section for the virtual-notebook behavior.
+    this._idleCallBack = null;
+    this._toRenderMap = new Map<string, { index: number; cell: Cell }>();
+    if ('IntersectionObserver' in window) {
+      this._observer = new IntersectionObserver(
+        (entries, observer) => {
+          entries.forEach(o => {
+            if (o.isIntersecting) {
+              observer.unobserve(o.target);
+              const ci = this._toRenderMap.get(o.target.id);
+              if (ci) {
+                const { cell, index } = ci;
+                this._renderPlaceholderCell(cell, index);
+              }
+            }
+          });
+        },
+        {
+          root: this.node,
+          threshold: 1,
+          rootMargin: `${this.notebookConfig.observedTopMargin} 0px ${this.notebookConfig.observedBottomMargin} 0px`
+        }
+      );
+    }
+  }
+
+  /**
+   * A signal emitted when the notebook is fully rendered.
+   */
+  get fullyRendered(): ISignal<this, boolean> {
+    return this._fullyRendered;
+  }
+
+  /**
+   * A signal emitted when the a placeholder cell is rendered.
+   */
+  get placeholderCellRendered(): ISignal<this, Cell> {
+    return this._placeholderCellRendered;
   }
 
   /**
@@ -296,22 +285,37 @@
    * The model for the widget.
    */
   get model(): INotebookModel | null {
-    return this._notebookModel;
+    return this._model;
   }
   set model(newValue: INotebookModel | null) {
     newValue = newValue || null;
-    if (this._notebookModel === newValue) {
+    if (this._model === newValue) {
       return;
     }
-    const oldValue = this._notebookModel;
-    this._notebookModel = newValue;
+    const oldValue = this._model;
+    this._model = newValue;
+
+    if (oldValue && oldValue.modelDB.isCollaborative) {
+      void oldValue.modelDB.connected.then(() => {
+        oldValue!.modelDB.collaborators!.changed.disconnect(
+          this._onCollaboratorsChanged,
+          this
+        );
+      });
+    }
+    if (newValue && newValue.modelDB.isCollaborative) {
+      void newValue.modelDB.connected.then(() => {
+        newValue!.modelDB.collaborators!.changed.connect(
+          this._onCollaboratorsChanged,
+          this
+        );
+      });
+    }
+
     // Trigger private, protected, and public changes.
     this._onModelChanged(oldValue, newValue);
     this.onModelChanged(oldValue, newValue);
     this._modelChanged.emit(void 0);
-
-    // Trigger state change
-    this.viewModel.itemsList = newValue?.cells ?? null;
   }
 
   /**
@@ -325,7 +329,7 @@
    * A read-only sequence of the widgets in the notebook.
    */
   get widgets(): ReadonlyArray<Cell> {
-    return this.cellsArray as ReadonlyArray<Cell>;
+    return (this.layout as PanelLayout).widgets as ReadonlyArray<Cell>;
   }
 
   /**
@@ -371,114 +375,8 @@
     if (this.isDisposed) {
       return;
     }
-    this._notebookModel = null;
-    (this.layout as NotebookWindowedLayout).header?.dispose();
+    this._model = null;
     super.dispose();
-  }
-
-  /**
-   * Move cells preserving widget view state.
-   *
-   * #### Notes
-   * This is required because at the model level a move is a deletion
-   * followed by an insertion. Hence the view state is not preserved.
-   *
-   * @param from The index of the cell to move
-   * @param to The new index of the cell
-   * @param n Number of cells to move
-   */
-  moveCell(from: number, to: number, n = 1): void {
-    if (!this.model) {
-      return;
-    }
-
-    const boundedTo = Math.min(this.model.cells.length - 1, Math.max(0, to));
-
-    if (boundedTo === from) {
-      return;
-    }
-
-    const viewModel: { [k: string]: any }[] = new Array(n);
-    let dirtyState: boolean[] = new Array(n);
-
-    for (let i = 0; i < n; i++) {
-      viewModel[i] = {};
-      const oldCell = this.widgets[from + i];
-      if (oldCell.model.type === 'markdown') {
-        for (const k of ['rendered', 'headingCollapsed']) {
-          // @ts-expect-error Cell has no index signature
-          viewModel[i][k] = oldCell[k];
-        }
-      } else if (oldCell.model.type === 'code') {
-        const oldCodeCell = oldCell.model as ICodeCellModel;
-        dirtyState[i] = oldCodeCell.isDirty;
-      }
-    }
-
-    this.model!.sharedModel.moveCells(from, boundedTo, n);
-
-    for (let i = 0; i < n; i++) {
-      const newCell = this.widgets[to + i];
-      const view = viewModel[i];
-      for (const state in view) {
-        // @ts-expect-error Cell has no index signature
-        newCell[state] = view[state];
-      }
-
-      if (from > to) {
-        if (this.widgets[to + i].model.type === 'code') {
-          (this.widgets[to + i].model as CodeCellModel).isDirty = dirtyState[i];
-        }
-      } else {
-        if (this.widgets[to + i - n + 1].model.type === 'code') {
-          (this.widgets[to + i - n + 1].model as CodeCellModel).isDirty =
-            dirtyState[i];
-        }
-      }
-    }
-  }
-
-  /**
-   * Force rendering the cell outputs of a given cell if it is still a placeholder.
-   *
-   * #### Notes
-   * The goal of this method is to allow search on cell outputs (that is based
-   * on DOM tree introspection).
-   *
-   * @param index The cell index
-   */
-  renderCellOutputs(index: number): void {
-    const cell = this.viewModel.widgetRenderer(index) as Cell;
-    if (cell instanceof CodeCell && cell.isPlaceholder()) {
-      cell.dataset.windowedListIndex = `${index}`;
-      this.layout.insertWidget(index, cell);
-      if (this.notebookConfig.windowingMode === 'full') {
-        // We need to delay slightly the removal to let codemirror properly initialize
-        requestAnimationFrame(() => {
-          this.layout.removeWidget(cell);
-        });
-      }
-    }
-  }
-
-  /**
-   * Adds a message to the notebook as a header.
-   */
-  protected addHeader(): void {
-    const trans = this.translator.load('jupyterlab');
-    const info = new Widget();
-    info.node.textContent = trans.__(
-      'The notebook is empty. Click the + button on the toolbar to add a new cell.'
-    );
-    (this.layout as NotebookWindowedLayout).header = info;
-  }
-
-  /**
-   * Removes the header.
-   */
-  protected removeHeader(): void {
-    (this.layout as NotebookWindowedLayout).header?.dispose();
-    (this.layout as NotebookWindowedLayout).header = null;
   }
 
   /**
@@ -513,7 +411,10 @@
    * The default implementation updates the mimetypes of the code cells
    * when the `language_info` metadata changes.
    */
-  protected onMetadataChanged(sender: INotebookModel, args: IMapChange): void {
+  protected onMetadataChanged(
+    sender: IObservableMap<ReadonlyPartialJSONValue | undefined>,
+    args: IObservableMap.IChangedArgs<ReadonlyPartialJSONValue>
+  ): void {
     switch (args.key) {
       case 'language_info':
         this._updateMimetype();
@@ -533,26 +434,21 @@
   }
 
   /**
+   * Handle a cell being moved.
+   *
+   * The default implementation is a no-op
+   */
+  protected onCellMoved(fromIndex: number, toIndex: number): void {
+    // This is a no-op.
+  }
+
+  /**
    * Handle a cell being removed.
    *
    * The default implementation is a no-op
    */
   protected onCellRemoved(index: number, cell: Cell): void {
     // This is a no-op.
-  }
-
-  /**
-   * A message handler invoked on an `'update-request'` message.
-   *
-   * #### Notes
-   * The default implementation of this handler is a no-op.
-   */
-  protected onUpdateRequest(msg: Message): void {
-    if (this.notebookConfig.windowingMode === 'defer') {
-      void this._runOnIdleTime();
-    } else {
-      super.onUpdateRequest(msg);
-    }
   }
 
   /**
@@ -562,109 +458,88 @@
     oldValue: INotebookModel | null,
     newValue: INotebookModel | null
   ): void {
+    const layout = this.layout as PanelLayout;
     if (oldValue) {
+      oldValue.cells.changed.disconnect(this._onCellsChanged, this);
+      oldValue.metadata.changed.disconnect(this.onMetadataChanged, this);
       oldValue.contentChanged.disconnect(this.onModelContentChanged, this);
-      oldValue.metadataChanged.disconnect(this.onMetadataChanged, this);
-      oldValue.cells.changed.disconnect(this._onCellsChanged, this);
-      while (this.cellsArray.length) {
+      // TODO: reuse existing cell widgets if possible. Remember to initially
+      // clear the history of each cell if we do this.
+      while (layout.widgets.length) {
         this._removeCell(0);
       }
     }
     if (!newValue) {
-      this._mimetype = IEditorMimeTypeService.defaultMimeType;
+      this._mimetype = 'text/plain';
       return;
     }
     this._updateMimetype();
     const cells = newValue.cells;
     const collab = newValue.collaborative ?? false;
-    if (!collab && !cells.length) {
-      newValue.sharedModel.insertCell(0, {
-        cell_type: this.notebookConfig.defaultCell,
-        metadata:
-          this.notebookConfig.defaultCell === 'code'
-            ? {
-                // This is an empty cell created in empty notebook, thus is trusted
-                trusted: true
-              }
-            : {}
-      });
-    }
-    let index = -1;
-    for (const cell of cells) {
-      this._insertCell(++index, cell);
-    }
-    newValue.cells.changed.connect(this._onCellsChanged, this);
-    newValue.metadataChanged.connect(this.onMetadataChanged, this);
+    if (!collab && !cells.length && newValue.isInitialized) {
+      cells.push(
+        newValue.contentFactory.createCell(this.notebookConfig.defaultCell, {})
+      );
+    }
+
+    each(cells, (cell: ICellModel, i: number) => {
+      this._insertCell(i, cell, 'set');
+    });
+    cells.changed.connect(this._onCellsChanged, this);
     newValue.contentChanged.connect(this.onModelContentChanged, this);
+    newValue.metadata.changed.connect(this.onMetadataChanged, this);
   }
 
   /**
    * Handle a change cells event.
    */
-  protected _onCellsChanged(
-    sender: CellList,
+  private _onCellsChanged(
+    sender: IObservableList<ICellModel>,
     args: IObservableList.IChangedArgs<ICellModel>
-  ): void {
-    this.removeHeader();
+  ) {
+    let index = 0;
     switch (args.type) {
-      case 'add': {
-        let index = 0;
+      case 'add':
         index = args.newIndex;
-        for (const value of args.newValues) {
-          this._insertCell(index++, value);
-        }
-        this._updateDataWindowedListIndex(
-          args.newIndex,
-          this.model!.cells.length,
-          args.newValues.length
-        );
+        // eslint-disable-next-line no-case-declarations
+        const insertType: InsertType = args.oldIndex == -1 ? 'push' : 'insert';
+        each(args.newValues, value => {
+          this._insertCell(index++, value, insertType);
+        });
         break;
-      }
+      case 'move':
+        this._moveCell(args.oldIndex, args.newIndex);
+        break;
       case 'remove':
-        for (let length = args.oldValues.length; length > 0; length--) {
+        each(args.oldValues, value => {
           this._removeCell(args.oldIndex);
-        }
-        this._updateDataWindowedListIndex(
-          args.oldIndex,
-          this.model!.cells.length + args.oldValues.length,
-          -1 * args.oldValues.length
-        );
-        // Add default cell if there are no cells remaining.
-        if (!sender.length) {
-          const model = this.model;
-          // Add the cell in a new context to avoid triggering another
-          // cell changed event during the handling of this signal.
-          requestAnimationFrame(() => {
-            if (model && !model.isDisposed && !model.sharedModel.cells.length) {
-              model.sharedModel.insertCell(0, {
-                cell_type: this.notebookConfig.defaultCell,
-                metadata:
-                  this.notebookConfig.defaultCell === 'code'
-                    ? {
-                        // This is an empty cell created in empty notebook, thus is trusted
-                        trusted: true
-                      }
-                    : {}
-              });
-            }
-          });
-        }
+        });
+        break;
+      case 'set':
+        // TODO: reuse existing widgets if possible.
+        index = args.newIndex;
+        each(args.newValues, value => {
+          // Note: this ordering (insert then remove)
+          // is important for getting the active cell
+          // index for the editable notebook correct.
+          this._insertCell(index, value, 'set');
+          this._removeCell(index + 1);
+          index++;
+        });
         break;
       default:
         return;
     }
-
-    if (!this.model!.sharedModel.cells.length) {
-      this.addHeader();
-    }
-
-    this.update();
   }
 
   /**
    * Create a cell widget and insert into the notebook.
    */
-  private _insertCell(index: number, cell: ICellModel): void {
+  private _insertCell(
+    index: number,
+    cell: ICellModel,
+    insertType: InsertType
+  ): void {
     let widget: Cell;
     switch (cell.type) {
       case 'code':
@@ -673,20 +548,105 @@
         break;
       case 'markdown':
         widget = this._createMarkdownCell(cell as IMarkdownCellModel);
-        if (cell.sharedModel.getSource() === '') {
+        if (cell.value.text === '') {
           (widget as MarkdownCell).rendered = false;
         }
         break;
       default:
         widget = this._createRawCell(cell as IRawCellModel);
     }
-    widget.inViewportChanged.connect(this._onCellInViewportChanged, this);
     widget.addClass(NB_CELL_CLASS);
 
-    ArrayExt.insert(this.cellsArray, index, widget);
-    this.onCellInserted(index, widget);
-
+    const layout = this.layout as PanelLayout;
+    if (
+      this._observer &&
+      insertType === 'push' &&
+      this._renderedCellsCount >=
+        this.notebookConfig.numberCellsToRenderDirectly &&
+      cell.type !== 'markdown'
+    ) {
+      // We have an observer and we are have been asked to push (not to insert).
+      // and we are above the number of cells to render directly, then
+      // we will add a placeholder and let the intersection observer or the
+      // idle browser render those placeholder cells.
+      this._toRenderMap.set(widget.model.id, { index: index, cell: widget });
+      const placeholder = this._createPlaceholderCell(
+        cell as IRawCellModel,
+        index
+      );
+      placeholder.node.id = widget.model.id;
+      layout.insertWidget(index, placeholder);
+      this.onCellInserted(index, placeholder);
+      this._fullyRendered.emit(false);
+      this._observer.observe(placeholder.node);
+    } else {
+      // We have no intersection observer, or we insert, or we are below
+      // the number of cells to render directly, so we render directly.
+      layout.insertWidget(index, widget);
+      this.onCellInserted(index, widget);
+      this._incrementRenderedCount();
+    }
     this._scheduleCellRenderOnIdle();
+  }
+
+  private _scheduleCellRenderOnIdle() {
+    if (
+      this._observer &&
+      this.notebookConfig.renderCellOnIdle &&
+      !this.isDisposed
+    ) {
+      if (!this._idleCallBack) {
+        const renderPlaceholderCells = this._renderPlaceholderCells.bind(this);
+        this._idleCallBack = (window as any).requestIdleCallback(
+          renderPlaceholderCells,
+          {
+            timeout: 3000
+          }
+        );
+      }
+    }
+  }
+
+  private _renderPlaceholderCells(deadline: any) {
+    if (this.notebookConfig.remainingTimeBeforeRescheduling > 0) {
+      const timeRemaining = deadline.timeRemaining();
+      // In case this got triggered because of timeout or when there are screen updates (https://w3c.github.io/requestidlecallback/#idle-periods),
+      // avoiding the render and rescheduling the place holder cell rendering.
+      if (
+        deadline.didTimeout ||
+        timeRemaining < this.notebookConfig.remainingTimeBeforeRescheduling
+      ) {
+        if (this._idleCallBack) {
+          (window as any).cancelIdleCallback(this._idleCallBack);
+          this._idleCallBack = null;
+        }
+        this._scheduleCellRenderOnIdle();
+      }
+    }
+
+    if (
+      this._renderedCellsCount < (this.model?.cells.length ?? 0) &&
+      this._renderedCellsCount >=
+        this.notebookConfig.numberCellsToRenderDirectly
+    ) {
+      const ci = this._toRenderMap.entries().next();
+      this._renderPlaceholderCell(ci.value[1].cell, ci.value[1].index);
+    }
+  }
+
+  private _renderPlaceholderCell(cell: Cell, index: number) {
+    // We don't have cancel mechanism for scheduled requestIdleCallback(renderPlaceholderCells),
+    // adding defensive check for layout in case tab is closed.
+    if (!this.layout) {
+      return;
+    }
+    const pl = this.layout as PanelLayout;
+    pl.removeWidgetAt(index);
+    pl.insertWidget(index, cell);
+    this._toRenderMap.delete(cell.model.id);
+    this._incrementRenderedCount();
+    this.onCellInserted(index, cell);
+    this._placeholderCellRendered.emit(cell);
   }
 
   /**
@@ -696,31 +656,19 @@
     const rendermime = this.rendermime;
     const contentFactory = this.contentFactory;
     const editorConfig = this.editorConfig.code;
-    const options: CodeCell.IOptions = {
+    const options = {
+      editorConfig,
+      model,
+      rendermime,
       contentFactory,
-      editorConfig,
-      inputHistoryScope: this.notebookConfig.inputHistoryScope,
-      maxNumberOutputs: this.notebookConfig.maxNumberOutputs,
-      model,
-      placeholder: this._notebookConfig.windowingMode !== 'none',
-      rendermime,
-      translator: this.translator
+      updateEditorOnShow: false,
+      placeholder: false,
+      maxNumberOutputs: this.notebookConfig.maxNumberOutputs
     };
-    const cell = this.contentFactory.createCodeCell(options);
+    const cell = this.contentFactory.createCodeCell(options, this);
     cell.syncCollapse = true;
     cell.syncEditable = true;
     cell.syncScrolled = true;
-    cell.outputArea.inputRequested.connect((_, stdin) => {
-      this._onInputRequested(cell).catch(reason => {
-        console.error('Failed to scroll to cell requesting input.', reason);
-      });
-      stdin.disposed.connect(() => {
-        // The input field is removed from the DOM after the user presses Enter.
-        // This causes focus to be lost if we don't explicitly re-focus
-        // somewhere else.
-        cell.node.focus();
-      });
-    });
     return cell;
   }
 
@@ -731,20 +679,50 @@
     const rendermime = this.rendermime;
     const contentFactory = this.contentFactory;
     const editorConfig = this.editorConfig.markdown;
-    const options: MarkdownCell.IOptions = {
-      contentFactory,
+    const options = {
       editorConfig,
       model,
-      placeholder: this._notebookConfig.windowingMode !== 'none',
       rendermime,
-      showEditorForReadOnlyMarkdown:
-        this._notebookConfig.showEditorForReadOnlyMarkdown
+      contentFactory,
+      updateEditorOnShow: false,
+      placeholder: false,
+      showEditorForReadOnlyMarkdown: this._notebookConfig
+        .showEditorForReadOnlyMarkdown
     };
-    const cell = this.contentFactory.createMarkdownCell(options);
+    const cell = this.contentFactory.createMarkdownCell(options, this);
     cell.syncCollapse = true;
     cell.syncEditable = true;
     // Connect collapsed signal for each markdown cell widget
-    cell.headingCollapsedChanged.connect(this._onCellCollapsed, this);
+    cell.toggleCollapsedSignal.connect(
+      (newCell: MarkdownCell, collapsed: boolean) => {
+        NotebookActions.setHeadingCollapse(newCell, collapsed, this);
+      }
+    );
+    return cell;
+  }
+
+  /**
+   * Create a placeholder cell widget from a raw cell model.
+   */
+  private _createPlaceholderCell(model: IRawCellModel, index: number): RawCell {
+    const contentFactory = this.contentFactory;
+    const editorConfig = this.editorConfig.raw;
+    const options = {
+      editorConfig,
+      model,
+      contentFactory,
+      updateEditorOnShow: false,
+      placeholder: true
+    };
+    const cell = this.contentFactory.createRawCell(options, this);
+    cell.node.innerHTML = `
+      <div class="jp-Cell-Placeholder">
+        <div class="jp-Cell-Placeholder-wrapper">
+        </div>
+      </div>`;
+    cell.inputHidden = true;
+    cell.syncCollapse = true;
+    cell.syncEditable = true;
     return cell;
   }
 
@@ -754,25 +732,35 @@
   private _createRawCell(model: IRawCellModel): RawCell {
     const contentFactory = this.contentFactory;
     const editorConfig = this.editorConfig.raw;
-    const options: RawCell.IOptions = {
+    const options = {
       editorConfig,
       model,
       contentFactory,
-      placeholder: this._notebookConfig.windowingMode !== 'none'
+      updateEditorOnShow: false,
+      placeholder: false
     };
-    const cell = this.contentFactory.createRawCell(options);
+    const cell = this.contentFactory.createRawCell(options, this);
     cell.syncCollapse = true;
     cell.syncEditable = true;
     return cell;
   }
 
   /**
+   * Move a cell widget.
+   */
+  private _moveCell(fromIndex: number, toIndex: number): void {
+    const layout = this.layout as PanelLayout;
+    layout.insertWidget(toIndex, layout.widgets[fromIndex]);
+    this.onCellMoved(fromIndex, toIndex);
+  }
+
+  /**
    * Remove a cell widget.
    */
   private _removeCell(index: number): void {
-    const widget = this.cellsArray[index];
+    const layout = this.layout as PanelLayout;
+    const widget = layout.widgets[index] as Cell;
     widget.parent = null;
-    ArrayExt.removeAt(this.cellsArray, index);
     this.onCellRemoved(index, widget);
     widget.dispose();
   }
@@ -781,100 +769,32 @@
    * Update the mimetype of the notebook.
    */
   private _updateMimetype(): void {
-    const info = this._notebookModel?.getMetadata('language_info');
+    const info = this._model?.metadata.get(
+      'language_info'
+    ) as nbformat.ILanguageInfoMetadata;
     if (!info) {
       return;
     }
     this._mimetype = this._mimetypeService.getMimeTypeByLanguage(info);
-    for (const widget of this.widgets) {
+    each(this.widgets, widget => {
       if (widget.model.type === 'code') {
         widget.model.mimeType = this._mimetype;
       }
-    }
-  }
-
-  /**
-   * Callback when a cell collapsed status changes.
-   *
-   * @param cell Cell changed
-   * @param collapsed New collapsed status
-   */
-  private _onCellCollapsed(cell: Cell, collapsed: boolean): void {
-    NotebookActions.setHeadingCollapse(cell, collapsed, this);
-    this._cellCollapsed.emit(cell);
-  }
-
-  /**
-   * Callback when a cell viewport status changes.
-   *
-   * @param cell Cell changed
-   */
-  private _onCellInViewportChanged(cell: Cell): void {
-    this._cellInViewportChanged.emit(cell);
-  }
-
-  /**
-   * Ensure to load in the DOM a cell requesting an user input
-   *
-   * @param cell Cell requesting an input
-   */
-  private async _onInputRequested(cell: Cell): Promise<void> {
-    if (!cell.inViewport) {
-      const cellIndex = this.widgets.findIndex(c => c === cell);
-      if (cellIndex >= 0) {
-        await this.scrollToItem(cellIndex);
-
-        const inputEl = cell.node.querySelector('.jp-Stdin');
-        if (inputEl) {
-          ElementExt.scrollIntoViewIfNeeded(this.node, inputEl);
-          (inputEl as HTMLElement).focus();
+    });
+  }
+
+  /**
+   * Handle an update to the collaborators.
+   */
+  private _onCollaboratorsChanged(): void {
+    // If there are selections corresponding to non-collaborators,
+    // they are stale and should be removed.
+    for (let i = 0; i < this.widgets.length; i++) {
+      const cell = this.widgets[i];
+      for (const key of cell.model.selections.keys()) {
+        if (false === this._model?.modelDB?.collaborators?.has(key)) {
+          cell.model.selections.delete(key);
         }
-      }
-    }
-  }
-
-  private _scheduleCellRenderOnIdle() {
-    if (this.notebookConfig.windowingMode !== 'none' && !this.isDisposed) {
-      if (!this._idleCallBack) {
-        this._idleCallBack = requestIdleCallback(
-          (deadline: IdleDeadline) => {
-            this._idleCallBack = null;
-
-            // In case of timeout, render for some time even if it means freezing the UI
-            // This avoids the cells to never be loaded.
-            void this._runOnIdleTime(
-              deadline.didTimeout
-                ? MAXIMUM_TIME_REMAINING
-                : deadline.timeRemaining()
-            );
-          },
-          {
-            timeout: 3000
-          }
-        );
-      }
-    }
-  }
-
-  private _updateDataWindowedListIndex(
-    start: number,
-    end: number,
-    delta: number
-  ): void {
-    for (
-      let cellIdx = 0;
-      cellIdx < this.viewportNode.childElementCount;
-      cellIdx++
-    ) {
-      const cell = this.viewportNode.children[cellIdx];
-      const globalIndex = parseInt(
-        (cell as HTMLElement).dataset.windowedListIndex!,
-        10
-      );
-      if (globalIndex >= start && globalIndex < end) {
-        (cell as HTMLElement).dataset.windowedListIndex = `${
-          globalIndex + delta
-        }`;
       }
     }
   }
@@ -885,7 +805,7 @@
   private _updateEditorConfig() {
     for (let i = 0; i < this.widgets.length; i++) {
       const cell = this.widgets[i];
-      let config: Record<string, any> = {};
+      let config: Partial<CodeEditor.IConfig> = {};
       switch (cell.model.type) {
         case 'code':
           config = this._editorConfig.code;
@@ -897,66 +817,9 @@
           config = this._editorConfig.raw;
           break;
       }
-      cell.updateEditorConfig({ ...config });
-    }
-  }
-
-  private async _runOnIdleTime(
-    remainingTime: number = MAXIMUM_TIME_REMAINING
-  ): Promise<void> {
-    const startTime = Date.now();
-    let cellIdx = 0;
-    while (
-      Date.now() - startTime < remainingTime &&
-      cellIdx < this.cellsArray.length
-    ) {
-      const cell = this.cellsArray[cellIdx];
-      if (cell.isPlaceholder()) {
-        if (['defer', 'full'].includes(this.notebookConfig.windowingMode)) {
-          await this._updateForDeferMode(cell, cellIdx);
-          if (this.notebookConfig.windowingMode === 'full') {
-            // We need to delay slightly the removal to let codemirror properly initialize
-            requestAnimationFrame(() => {
-              this.viewModel.setEstimatedWidgetSize(
-                cell.model.id,
-                cell.node.getBoundingClientRect().height
-              );
-              this.layout.removeWidget(cell);
-            });
-          }
-        }
-      }
-      cellIdx++;
-    }
-
-    // If the notebook is not fully rendered
-    if (cellIdx < this.cellsArray.length) {
-      // If we are defering the cell rendering and the rendered cells do
-      // not fill the viewport yet
-      if (
-        this.notebookConfig.windowingMode === 'defer' &&
-        this.viewportNode.clientHeight < this.node.clientHeight
-      ) {
-        // Spend more time rendering cells to fill the viewport
-        await this._runOnIdleTime();
-      } else {
-        this._scheduleCellRenderOnIdle();
-      }
-    } else {
-      if (this._idleCallBack) {
-        window.cancelIdleCallback(this._idleCallBack);
-        this._idleCallBack = null;
-      }
-    }
-  }
-
-  private async _updateForDeferMode(
-    cell: Cell<ICellModel>,
-    cellIdx: number
-  ): Promise<void> {
-    cell.dataset.windowedListIndex = `${cellIdx}`;
-    this.layout.insertWidget(cellIdx, cell);
-    await cell.ready;
+      cell.editor.setOptions({ ...config });
+      cell.editor.refresh();
+    }
   }
 
   /**
@@ -968,40 +831,43 @@
       'jp-mod-scrollPastEnd',
       this._notebookConfig.scrollPastEnd
     );
-    // Control visibility of heading collapser UI
-    this.toggleClass(
-      HEADING_COLLAPSER_VISBILITY_CONTROL_CLASS,
-      this._notebookConfig.showHiddenCellsButton
-    );
+
     // Control editor visibility for read-only Markdown cells
-    const showEditorForReadOnlyMarkdown =
-      this._notebookConfig.showEditorForReadOnlyMarkdown;
+    const showEditorForReadOnlyMarkdown = this._notebookConfig
+      .showEditorForReadOnlyMarkdown;
     if (showEditorForReadOnlyMarkdown !== undefined) {
-      for (const cell of this.cellsArray) {
+      for (const cell of this.widgets) {
         if (cell.model.type === 'markdown') {
-          (cell as MarkdownCell).showEditorForReadOnly =
-            showEditorForReadOnlyMarkdown;
+          (cell as MarkdownCell).showEditorForReadOnly = showEditorForReadOnlyMarkdown;
         }
       }
     }
-
-    this.viewModel.windowingActive =
-      this._notebookConfig.windowingMode === 'full';
-  }
-
-  protected cellsArray: Array<Cell>;
-
-  private _cellCollapsed = new Signal<this, Cell>(this);
-  private _cellInViewportChanged = new Signal<this, Cell>(this);
-  private _editorConfig: StaticNotebook.IEditorConfig;
-  private _idleCallBack: number | null;
-  private _mimetype: string;
+  }
+
+  private _incrementRenderedCount() {
+    if (this._toRenderMap.size === 0) {
+      this._fullyRendered.emit(true);
+    }
+    this._renderedCellsCount++;
+  }
+
+  public get remainingCellToRenderCount(): number {
+    return this._toRenderMap.size;
+  }
+
+  private _editorConfig = StaticNotebook.defaultEditorConfig;
+  private _notebookConfig = StaticNotebook.defaultNotebookConfig;
+  private _mimetype = 'text/plain';
+  private _model: INotebookModel | null = null;
   private _mimetypeService: IEditorMimeTypeService;
-  readonly kernelHistory: INotebookHistory | undefined;
-  private _modelChanged: Signal<this, void>;
-  private _modelContentChanged: Signal<this, void>;
-  private _notebookConfig: StaticNotebook.INotebookConfig;
-  private _notebookModel: INotebookModel | null;
+  private _modelChanged = new Signal<this, void>(this);
+  private _modelContentChanged = new Signal<this, void>(this);
+  private _fullyRendered = new Signal<this, boolean>(this);
+  private _placeholderCellRendered = new Signal<this, Cell>(this);
+  private _observer: IntersectionObserver;
+  private _renderedCellsCount = 0;
+  private _toRenderMap: Map<string, { index: number; cell: Cell }>;
+  private _idleCallBack: any;
   private _renderingLayout: RenderingLayout | undefined;
   private _renderingLayoutChanged = new Signal<this, RenderingLayout>(this);
 }
@@ -1027,7 +893,7 @@
     /**
      * A factory for creating content.
      */
-    contentFactory: IContentFactory;
+    contentFactory?: IContentFactory;
 
     /**
      * A configuration object for the cell editor settings.
@@ -1048,16 +914,6 @@
      * The application language translator.
      */
     translator?: ITranslator;
-
-    /**
-     * The kernel history retrieval object
-     */
-    kernelHistory?: INotebookHistory;
-
-    /**
-     * The renderer used by the underlying windowed list.
-     */
-    renderer?: WindowedList.IRenderer;
   }
 
   /**
@@ -1072,17 +928,23 @@
     /**
      * Create a new code cell widget.
      */
-    createCodeCell(options: CodeCell.IOptions): CodeCell;
+    createCodeCell(
+      options: CodeCell.IOptions,
+      parent: StaticNotebook
+    ): CodeCell;
 
     /**
      * Create a new markdown cell widget.
      */
-    createMarkdownCell(options: MarkdownCell.IOptions): MarkdownCell;
+    createMarkdownCell(
+      options: MarkdownCell.IOptions,
+      parent: StaticNotebook
+    ): MarkdownCell;
 
     /**
      * Create a new raw cell widget.
      */
-    createRawCell(options: RawCell.IOptions): RawCell;
+    createRawCell(options: RawCell.IOptions, parent: StaticNotebook): RawCell;
   }
 
   /**
@@ -1092,15 +954,15 @@
     /**
      * Config options for code cells.
      */
-    readonly code: Record<string, any>;
+    readonly code: Partial<CodeEditor.IConfig>;
     /**
      * Config options for markdown cells.
      */
-    readonly markdown: Record<string, any>;
+    readonly markdown: Partial<CodeEditor.IConfig>;
     /**
      * Config options for raw cells.
      */
-    readonly raw: Record<string, any>;
+    readonly raw: Partial<CodeEditor.IConfig>;
   }
 
   /**
@@ -1108,22 +970,22 @@
    */
   export const defaultEditorConfig: IEditorConfig = {
     code: {
-      lineNumbers: false,
-      lineWrap: false,
+      ...CodeEditor.defaultConfig,
+      lineWrap: 'off',
       matchBrackets: true,
-      tabFocusable: false
+      autoClosingBrackets: false
     },
     markdown: {
-      lineNumbers: false,
-      lineWrap: true,
+      ...CodeEditor.defaultConfig,
+      lineWrap: 'on',
       matchBrackets: false,
-      tabFocusable: false
+      autoClosingBrackets: false
     },
     raw: {
-      lineNumbers: false,
-      lineWrap: true,
+      ...CodeEditor.defaultConfig,
+      lineWrap: 'on',
       matchBrackets: false,
-      tabFocusable: false
+      autoClosingBrackets: false
     }
   };
 
@@ -1132,68 +994,73 @@
    */
   export interface INotebookConfig {
     /**
+     * Enable scrolling past the last cell
+     */
+    scrollPastEnd: boolean;
+
+    /**
      * The default type for new notebook cells.
      */
     defaultCell: nbformat.CellType;
 
     /**
+     * Should timing be recorded in metadata
+     */
+    recordTiming: boolean;
+
+    /*
+     * Remaining time in milliseconds before
+     * virtual notebook rendering is rescheduled.
+     */
+    numberCellsToRenderDirectly: number;
+
+    /*
+     * Number of cells to render directly when virtual
+     * notebook intersection observer is available.
+     */
+    remainingTimeBeforeRescheduling: number;
+
+    /**
+     * Defines if the placeholder cells should be rendered
+     * when the browser is idle.
+     */
+    renderCellOnIdle: boolean;
+
+    /**
+     * Defines the observed top margin for the
+     * virtual notebook, set a positive number of pixels
+     * to render cells below the visible view.
+     */
+    observedTopMargin: string;
+
+    /**
+     * Defines the observed bottom margin for the
+     * virtual notebook, set a positive number of pixels
+     * to render cells below the visible view.
+     */
+    observedBottomMargin: string;
+
+    /**
+     * Defines the maximum number of outputs per cell.
+     */
+    maxNumberOutputs: number;
+
+    /**
+     * Should an editor be shown for read-only markdown
+     */
+    showEditorForReadOnlyMarkdown?: boolean;
+
+    /**
      * Defines if the document can be undo/redo.
      */
     disableDocumentWideUndoRedo: boolean;
 
     /**
-     * Whether to display notification if code cell is run while kernel is still initializing.
-     */
-    enableKernelInitNotification: boolean;
-
-    /**
-     * Defines the maximum number of outputs per cell.
-     */
-    maxNumberOutputs: number;
-
-    /**
-     * Whether to split stdin line history by kernel session or keep globally accessible.
-     */
-    inputHistoryScope: 'global' | 'session';
-
-    /**
-     * Number of cells to render in addition to those
-     * visible in the viewport.
-     *
-     * ### Notes
-     * In 'full' windowing mode, this is the number of cells above and below the
-     * viewport.
-     * In 'defer' windowing mode, this is the number of cells to render initially
-     * in addition to the one of the viewport.
-     */
-    overscanCount: number;
-
-    /**
-     * Should timing be recorded in metadata
-     */
-    recordTiming: boolean;
-
-    /**
      * Defines the rendering layout to use.
      */
     renderingLayout: RenderingLayout;
 
     /**
-     * Enable scrolling past the last cell
-     */
-    scrollPastEnd: boolean;
-
-    /**
-     * Show hidden cells button if collapsed
-     */
-    showHiddenCellsButton: boolean;
-
-    /**
-     * Should an editor be shown for read-only markdown
-     */
-    showEditorForReadOnlyMarkdown?: boolean;
-
-    /**
      * Override the side-by-side left margin.
      */
     sideBySideLeftMarginOverride: string;
@@ -1207,38 +1074,27 @@
      * Side-by-side output ratio.
      */
     sideBySideOutputRatio: number;
-
-    /**
-     * Windowing mode
-     *
-     * - 'defer': Wait for idle CPU cycles to attach out of viewport cells
-     * - 'full': Attach to the DOM only cells in viewport
-     * - 'none': Attach all cells to the viewport
-     */
-    windowingMode: 'defer' | 'full' | 'none';
-    accessKernelHistory?: boolean;
   }
 
   /**
    * Default configuration options for notebooks.
    */
   export const defaultNotebookConfig: INotebookConfig = {
-    enableKernelInitNotification: false,
-    showHiddenCellsButton: true,
     scrollPastEnd: true,
     defaultCell: 'code',
     recordTiming: false,
-    inputHistoryScope: 'global',
+    numberCellsToRenderDirectly: 99999,
+    remainingTimeBeforeRescheduling: 50,
+    renderCellOnIdle: true,
+    observedTopMargin: '1000px',
+    observedBottomMargin: '1000px',
     maxNumberOutputs: 50,
     showEditorForReadOnlyMarkdown: true,
     disableDocumentWideUndoRedo: true,
     renderingLayout: 'default',
     sideBySideLeftMarginOverride: '10px',
     sideBySideRightMarginOverride: '10px',
-    sideBySideOutputRatio: 1,
-    overscanCount: 1,
-    windowingMode: 'full',
-    accessKernelHistory: false
+    sideBySideOutputRatio: 1
   };
 
   /**
@@ -1246,8 +1102,7 @@
    */
   export class ContentFactory
     extends Cell.ContentFactory
-    implements IContentFactory
-  {
+    implements IContentFactory {
     /**
      * Create a new code cell widget.
      *
@@ -1255,7 +1110,13 @@
      * If no cell content factory is passed in with the options, the one on the
      * notebook content factory is used.
      */
-    createCodeCell(options: CodeCell.IOptions): CodeCell {
+    createCodeCell(
+      options: CodeCell.IOptions,
+      parent: StaticNotebook
+    ): CodeCell {
+      if (!options.contentFactory) {
+        options.contentFactory = this;
+      }
       return new CodeCell(options).initializeState();
     }
 
@@ -1266,7 +1127,13 @@
      * If no cell content factory is passed in with the options, the one on the
      * notebook content factory is used.
      */
-    createMarkdownCell(options: MarkdownCell.IOptions): MarkdownCell {
+    createMarkdownCell(
+      options: MarkdownCell.IOptions,
+      parent: StaticNotebook
+    ): MarkdownCell {
+      if (!options.contentFactory) {
+        options.contentFactory = this;
+      }
       return new MarkdownCell(options).initializeState();
     }
 
@@ -1277,7 +1144,10 @@
      * If no cell content factory is passed in with the options, the one on the
      * notebook content factory is used.
      */
-    createRawCell(options: RawCell.IOptions): RawCell {
+    createRawCell(options: RawCell.IOptions, parent: StaticNotebook): RawCell {
+      if (!options.contentFactory) {
+        options.contentFactory = this;
+      }
       return new RawCell(options).initializeState();
     }
   }
@@ -1291,6 +1161,11 @@
      */
     export interface IOptions extends Cell.ContentFactory.IOptions {}
   }
+
+  /**
+   * Default content factory for the static notebook widget.
+   */
+  export const defaultContentFactory: IContentFactory = new ContentFactory();
 }
 
 /**
@@ -1301,82 +1176,10 @@
    * Construct a notebook widget.
    */
   constructor(options: Notebook.IOptions) {
-    super({
-      renderer: {
-        createOuter(): HTMLElement {
-          return document.createElement('div');
-        },
-
-        createViewport(): HTMLElement {
-          const el = document.createElement('div');
-          el.setAttribute('role', 'feed');
-          el.setAttribute('aria-label', 'Cells');
-          return el;
-        },
-
-        createScrollbar(): HTMLOListElement {
-          return document.createElement('ol');
-        },
-
-        createScrollbarItem(
-          notebook: Notebook,
-          index: number,
-          model: ICellModel
-        ): HTMLLIElement {
-          const li = document.createElement('li');
-          li.appendChild(document.createTextNode(`${index + 1}`));
-          if (notebook.activeCellIndex === index) {
-            li.classList.add('jp-mod-active');
-          }
-          if (notebook.selectedCells.some(cell => model === cell.model)) {
-            li.classList.add('jp-mod-selected');
-          }
-          return li;
-        }
-      },
-      ...options
-    });
+    super(Private.processNotebookOptions(options));
+    this.node.tabIndex = 0; // Allow the widget to take focus.
     // Allow the node to scroll while dragging items.
-    this.outerNode.setAttribute('data-lm-dragscroll', 'true');
-    this.activeCellChanged.connect(this._updateSelectedCells, this);
-    this.jumped.connect((_, index: number) => (this.activeCellIndex = index));
-    this.selectionChanged.connect(this._updateSelectedCells, this);
-
-    this.addFooter();
-  }
-
-  /**
-   * List of selected and active cells
-   */
-  get selectedCells(): Cell[] {
-    return this._selectedCells;
-  }
-
-  /**
-   * Adds a footer to the notebook.
-   */
-  protected addFooter(): void {
-    const info = new NotebookFooter(this);
-    (this.layout as NotebookWindowedLayout).footer = info;
-  }
-
-  /**
-   * Handle a change cells event.
-   */
-  protected _onCellsChanged(
-    sender: CellList,
-    args: IObservableList.IChangedArgs<ICellModel>
-  ): void {
-    const activeCellId = this.activeCell?.model.id;
-    super._onCellsChanged(sender, args);
-    if (activeCellId) {
-      const newActiveCellIndex = this.model?.sharedModel.cells.findIndex(
-        cell => cell.getId() === activeCellId
-      );
-      if (newActiveCellIndex != null) {
-        this.activeCellIndex = newActiveCellIndex;
-      }
-    }
+    this.node.setAttribute('data-lm-dragscroll', 'true');
   }
 
   /**
@@ -1386,7 +1189,7 @@
    * This can be due to the active index changing or the
    * cell at the active index changing.
    */
-  get activeCellChanged(): ISignal<this, Cell | null> {
+  get activeCellChanged(): ISignal<this, Cell> {
     return this._activeCellChanged;
   }
 
@@ -1411,29 +1214,12 @@
     return this._mode;
   }
   set mode(newValue: NotebookMode) {
-    this.setMode(newValue);
-  }
-
-  /**
-   * Set the notebook mode.
-   *
-   * @param newValue Notebook mode
-   * @param options Control mode side-effect
-   * @param options.focus Whether to ensure focus (default) or not when setting the mode.
-   */
-  protected setMode(
-    newValue: NotebookMode,
-    options: { focus?: boolean } = {}
-  ): void {
-    const setFocus = options.focus ?? true;
     const activeCell = this.activeCell;
     if (!activeCell) {
       newValue = 'command';
     }
     if (newValue === this._mode) {
-      if (setFocus) {
-        this._ensureFocus();
-      }
+      this._ensureFocus();
       return;
     }
     // Post an update request.
@@ -1443,32 +1229,20 @@
 
     if (newValue === 'edit') {
       // Edit mode deselects all cells.
-      for (const widget of this.widgets) {
+      each(this.widgets, widget => {
         this.deselect(widget);
-      }
-      // Edit mode unrenders an active markdown widget.
+      });
+      //  Edit mode unrenders an active markdown widget.
       if (activeCell instanceof MarkdownCell) {
         activeCell.rendered = false;
       }
       activeCell!.inputHidden = false;
     } else {
-      if (setFocus) {
-        void NotebookActions.focusActiveCell(this, {
-          // Do not await the active cell because that creates a bug. If the user
-          // is editing a code cell and presses Accel Shift C to open the command
-          // palette, then the command palette opens before
-          // activeCell.node.focus() is called, which closes the command palette.
-          // To the end user, it looks as if all the keyboard shortcut did was
-          // move focus from the cell editor to the cell as a whole.
-          waitUntilReady: false,
-          preventScroll: true
-        });
-      }
+      // Focus on the notebook document, which blurs the active cell.
+      this.node.focus();
     }
     this._stateChanged.emit({ name: 'mode', oldValue, newValue });
-    if (setFocus) {
-      this._ensureFocus();
-    }
+    this._ensureFocus();
   }
 
   /**
@@ -1481,31 +1255,25 @@
     if (!this.model) {
       return -1;
     }
-    return this.widgets.length ? this._activeCellIndex : -1;
+    return this.model.cells.length ? this._activeCellIndex : -1;
   }
   set activeCellIndex(newValue: number) {
     const oldValue = this._activeCellIndex;
-    if (!this.model || !this.widgets.length) {
+    if (!this.model || !this.model.cells.length) {
       newValue = -1;
     } else {
       newValue = Math.max(newValue, 0);
-      newValue = Math.min(newValue, this.widgets.length - 1);
+      newValue = Math.min(newValue, this.model.cells.length - 1);
     }
 
     this._activeCellIndex = newValue;
-    const cell = this.widgets[newValue] ?? null;
-    (this.layout as NotebookWindowedLayout).activeCell = cell;
-    const cellChanged = cell !== this._activeCell;
-    if (cellChanged) {
+    const cell = this.widgets[newValue];
+    if (cell !== this._activeCell) {
       // Post an update request.
       this.update();
       this._activeCell = cell;
-    }
-
-    if (cellChanged || newValue != oldValue) {
       this._activeCellChanged.emit(cell);
     }
-
     if (this.mode === 'edit' && cell instanceof MarkdownCell) {
       cell.rendered = false;
     }
@@ -1546,47 +1314,6 @@
   }
 
   /**
-   * Move cells preserving widget view state.
-   *
-   * #### Notes
-   * This is required because at the model level a move is a deletion
-   * followed by an insertion. Hence the view state is not preserved.
-   *
-   * @param from The index of the cell to move
-   * @param to The new index of the cell
-   * @param n Number of cells to move
-   */
-  moveCell(from: number, to: number, n = 1): void {
-    // Save active cell id to be restored
-    const newActiveCellIndex =
-      from <= this.activeCellIndex && this.activeCellIndex < from + n
-        ? this.activeCellIndex + to - from - (from > to ? 0 : n - 1)
-        : -1;
-    const isSelected = this.widgets
-      .slice(from, from + n)
-      .map(w => this.isSelected(w));
-
-    super.moveCell(from, to, n);
-
-    if (newActiveCellIndex >= 0) {
-      this.activeCellIndex = newActiveCellIndex;
-    }
-    if (from > to) {
-      isSelected.forEach((selected, idx) => {
-        if (selected) {
-          this.select(this.widgets[to + idx]);
-        }
-      });
-    } else {
-      isSelected.forEach((selected, idx) => {
-        if (selected) {
-          this.select(this.widgets[to - n + 1 + idx]);
-        }
-      });
-    }
-  }
-
-  /**
    * Select a cell widget.
    *
    * #### Notes
@@ -1640,12 +1367,12 @@
    */
   deselectAll(): void {
     let changed = false;
-    for (const widget of this.widgets) {
+    each(this.widgets, widget => {
       if (Private.selectedProperty.get(widget)) {
         changed = true;
       }
       Private.selectedProperty.set(widget, false);
-    }
+    });
     if (changed) {
       this._selectionChanged.emit(void 0);
     }
@@ -1799,103 +1526,53 @@
   }
 
   /**
+   * Scroll so that the given position is centered.
+   *
+   * @param position - The vertical position in the notebook widget.
+   *
+   * @param threshold - An optional threshold for the scroll (0-50, defaults to
+   * 25).
+   *
+   * #### Notes
+   * If the position is within the threshold percentage of the widget height,
+   * measured from the center of the widget, the scroll position will not be
+   * changed. A threshold of 0 means we will always scroll so the position is
+   * centered, and a threshold of 50 means scrolling only happens if position is
+   * outside the current window.
+   */
+  scrollToPosition(position: number, threshold = 25): void {
+    const node = this.node;
+    const ar = node.getBoundingClientRect();
+    const delta = position - ar.top - ar.height / 2;
+    if (Math.abs(delta) > (ar.height * threshold) / 100) {
+      node.scrollTop += delta;
+    }
+  }
+
+  /**
    * Scroll so that the given cell is in view. Selects and activates cell.
    *
    * @param cell - A cell in the notebook widget.
-   * @param align - Type of alignment.
-   *
-   */
-  async scrollToCell(
-    cell: Cell,
-    align: WindowedList.ScrollToAlign = 'auto'
-  ): Promise<void> {
-    try {
-      await this.scrollToItem(
-        this.widgets.findIndex(c => c === cell),
-        align
-      );
-    } catch (r) {
-      //no-op
-    }
+   *
+   */
+  scrollToCell(cell: Cell): void {
+    // use Phosphor to scroll
+    ElementExt.scrollIntoViewIfNeeded(this.node, cell.node);
     // change selection and active cell:
     this.deselectAll();
     this.select(cell);
     cell.activate();
   }
 
-  private _parseFragment(fragment: string): Private.IFragmentData | undefined {
-    const cleanedFragment = fragment.slice(1);
-
-    if (!cleanedFragment) {
-      // Bail early
-      return;
-    }
-
-    const parts = cleanedFragment.split('=');
-    if (parts.length === 1) {
-      // Default to heading if no prefix is given.
-      return {
-        kind: 'heading',
-        value: cleanedFragment
-      };
-    }
-    return {
-      kind: parts[0] as any,
-      value: parts.slice(1).join('=')
-    };
-  }
-
   /**
    * Set URI fragment identifier.
    */
-  async setFragment(fragment: string): Promise<void> {
-    const parsedFragment = this._parseFragment(fragment);
-
-    if (!parsedFragment) {
-      // Bail early
-      return;
-    }
-
-    let result;
-
-    switch (parsedFragment.kind) {
-      case 'heading':
-        result = await this._findHeading(parsedFragment.value);
-        break;
-      case 'cell-id':
-        result = this._findCellById(parsedFragment.value);
-        break;
-      default:
-        console.warn(
-          `Unknown target type for URI fragment ${fragment}, interpreting as a heading`
-        );
-        result = await this._findHeading(
-          parsedFragment.kind + '=' + parsedFragment.value
-        );
-        break;
-    }
-
-    if (result == null) {
-      return;
-    }
-    let { cell, element } = result;
-
-    if (!cell.inViewport) {
-      await this.scrollToCell(cell, 'center');
-    }
-
-    if (element == null) {
-      element = cell.node;
-    }
-    const widgetBox = this.node.getBoundingClientRect();
-    const elementBox = element.getBoundingClientRect();
-
-    if (
-      elementBox.top > widgetBox.bottom ||
-      elementBox.bottom < widgetBox.top
-    ) {
-      element.scrollIntoView({ block: 'center' });
-    }
+  setFragment(fragment: string): void {
+    // Wait all cells are rendered then set fragment and update.
+    void Promise.all(this.widgets.map(widget => widget.ready)).then(() => {
+      this._fragment = fragment;
+      this.update();
+    });
   }
 
   /**
@@ -1923,10 +1600,7 @@
         if (event.eventPhase === Event.CAPTURING_PHASE) {
           this._evtMouseDownCapture(event as MouseEvent);
         } else {
-          // Skip processing the event when it resulted from a toolbar button click
-          if (!event.defaultPrevented) {
-            this._evtMouseDown(event as MouseEvent);
-          }
+          this._evtMouseDown(event as MouseEvent);
         }
         break;
       case 'mouseup':
@@ -1940,7 +1614,6 @@
         }
         break;
       case 'keydown':
-        // This works because CodeMirror does not stop the event propagation
         this._ensureFocus(true);
         break;
       case 'dblclick':
@@ -1953,19 +1626,18 @@
         this._evtFocusOut(event as MouseEvent);
         break;
       case 'lm-dragenter':
-        this._evtDragEnter(event as Drag.Event);
+        this._evtDragEnter(event as IDragEvent);
         break;
       case 'lm-dragleave':
-        this._evtDragLeave(event as Drag.Event);
+        this._evtDragLeave(event as IDragEvent);
         break;
       case 'lm-dragover':
-        this._evtDragOver(event as Drag.Event);
+        this._evtDragOver(event as IDragEvent);
         break;
       case 'lm-drop':
-        this._evtDrop(event as Drag.Event);
+        this._evtDrop(event as IDragEvent);
         break;
       default:
-        super.handleEvent(event);
         break;
     }
   }
@@ -2011,14 +1683,12 @@
     node.removeEventListener('lm-drop', this, true);
     document.removeEventListener('mousemove', this, true);
     document.removeEventListener('mouseup', this, true);
-    super.onBeforeAttach(msg);
   }
 
   /**
    * A message handler invoked on an `'after-show'` message.
    */
   protected onAfterShow(msg: Message): void {
-    super.onAfterShow(msg);
     this._checkCacheOnNextResize = true;
   }
 
@@ -2026,11 +1696,9 @@
    * A message handler invoked on a `'resize'` message.
    */
   protected onResize(msg: Widget.ResizeMessage): void {
-    // TODO
     if (!this._checkCacheOnNextResize) {
       return super.onResize(msg);
     }
-    super.onResize(msg);
     this._checkCacheOnNextResize = false;
     const cache = this._cellLayoutStateCache;
     const width = parseInt(this.node.style.width, 10);
@@ -2045,8 +1713,8 @@
 
     // Fallback:
     for (const w of this.widgets) {
-      if (w instanceof Cell && w.inViewport) {
-        w.editorWidget?.update();
+      if (w instanceof Cell) {
+        w.editorWidget.update();
       }
     }
   }
@@ -2055,7 +1723,6 @@
    * A message handler invoked on an `'before-hide'` message.
    */
   protected onBeforeHide(msg: Message): void {
-    super.onBeforeHide(msg);
     // Update cache
     const width = parseInt(this.node.style.width, 10);
     this._cellLayoutStateCache = { width };
@@ -2065,7 +1732,6 @@
    * Handle `'activate-request'` messages.
    */
   protected onActivateRequest(msg: Message): void {
-    super.onActivateRequest(msg);
     this._ensureFocus(true);
   }
 
@@ -2073,7 +1739,6 @@
    * Handle `update-request` messages sent to the widget.
    */
   protected onUpdateRequest(msg: Message): void {
-    super.onUpdateRequest(msg);
     const activeCell = this.activeCell;
 
     // Set the appropriate classes on the cells.
@@ -2084,17 +1749,15 @@
       this.addClass(COMMAND_CLASS);
       this.removeClass(EDIT_CLASS);
     }
+    if (activeCell) {
+      activeCell.addClass(ACTIVE_CLASS);
+    }
 
     let count = 0;
-    for (const widget of this.widgets) {
-      // Set tabIndex to -1 to allow calling .focus() on cell without allowing
-      // focus via tab key. This allows focus (document.activeElement) to move
-      // up and down the document, cell by cell, when the user presses J/K or
-      // ArrowDown/ArrowUp, but (unlike tabIndex = 0) does not add the notebook
-      // cells (which could be numerous) to the set of nodes that the user would
-      // have to visit when pressing the tab key to move about the UI.
-      widget.node.tabIndex = -1;
-      widget.removeClass(ACTIVE_CLASS);
+    each(this.widgets, widget => {
+      if (widget !== activeCell) {
+        widget.removeClass(ACTIVE_CLASS);
+      }
       widget.removeClass(OTHER_SELECTED_CLASS);
       if (this.isSelectedOrActive(widget)) {
         widget.addClass(SELECTED_CLASS);
@@ -2102,18 +1765,25 @@
       } else {
         widget.removeClass(SELECTED_CLASS);
       }
-    }
-
-    if (activeCell) {
-      activeCell.addClass(ACTIVE_CLASS);
-      activeCell.addClass(SELECTED_CLASS);
-      // Set tab index to 0 on the active cell so that if the user tabs away from
-      // the notebook then tabs back, they will return to the cell where they
-      // left off.
-      activeCell.node.tabIndex = 0;
-      if (count > 1) {
-        activeCell.addClass(OTHER_SELECTED_CLASS);
-      }
+    });
+    if (count > 1) {
+      activeCell?.addClass(OTHER_SELECTED_CLASS);
+    }
+    if (this._fragment) {
+      let el;
+      try {
+        el = this.node.querySelector(
+          this._fragment.startsWith('#')
+            ? `#${CSS.escape(this._fragment.slice(1))}`
+            : this._fragment
+        );
+      } catch (error) {
+        console.warn('Unable to set URI fragment identifier', error);
+      }
+      if (el) {
+        el.scrollIntoView();
+      }
+      this._fragment = '';
     }
   }
 
@@ -2121,48 +1791,41 @@
    * Handle a cell being inserted.
    */
   protected onCellInserted(index: number, cell: Cell): void {
-    void cell.ready.then(() => {
-      if (!cell.isDisposed) {
-        cell.editor!.edgeRequested.connect(this._onEdgeRequest, this);
-      }
-    });
-    cell.scrollRequested.connect((_emitter, scrollRequest) => {
-      if (cell !== this.activeCell) {
-        // Do nothing for cells other than the active cell
-        // to avoid scroll requests from editor extensions
-        // stealing user focus (this may be revisited).
-        return;
-      }
-      if (!scrollRequest.defaultPrevented) {
-        // Nothing to do if scroll request was already handled.
-        return;
-      }
-      // Node which allows to scroll the notebook
-      const scroller = this.outerNode;
-
-      if (cell.inViewport) {
-        // If cell got scrolled to the viewport in the meantime,
-        // proceed with scrolling within the cell.
-        return scrollRequest.scrollWithinCell({ scroller });
-      }
-      // If cell is not in the viewport and needs scrolling,
-      // first scroll to the cell and then scroll within the cell.
-      this.scrollToItem(this.activeCellIndex)
-        .then(() => {
-          void cell.ready.then(() => {
-            scrollRequest.scrollWithinCell({ scroller });
-          });
-        })
-        .catch(reason => {
-          // no-op
-        });
-    });
+    if (this.model && this.model.modelDB.isCollaborative) {
+      const modelDB = this.model.modelDB;
+      void modelDB.connected.then(() => {
+        if (!cell.isDisposed) {
+          // Setup the selection style for collaborators.
+          const localCollaborator = modelDB.collaborators!.localCollaborator;
+          cell.editor.uuid = localCollaborator.sessionId;
+          cell.editor.selectionStyle = {
+            ...CodeEditor.defaultSelectionStyle,
+            color: localCollaborator.color
+          };
+        }
+      });
+    }
+    cell.editor.edgeRequested.connect(this._onEdgeRequest, this);
     // If the insertion happened above, increment the active cell
     // index, otherwise it stays the same.
     this.activeCellIndex =
       index <= this.activeCellIndex
         ? this.activeCellIndex + 1
         : this.activeCellIndex;
+  }
+
+  /**
+   * Handle a cell being moved.
+   */
+  protected onCellMoved(fromIndex: number, toIndex: number): void {
+    const i = this.activeCellIndex;
+    if (fromIndex === i) {
+      this.activeCellIndex = toIndex;
+    } else if (fromIndex < i && i <= toIndex) {
+      this.activeCellIndex--;
+    } else if (toIndex <= i && i < fromIndex) {
+      this.activeCellIndex++;
+    }
   }
 
   /**
@@ -2207,19 +1870,15 @@
       // Move the cursor to the first position on the last line.
       if (this.activeCellIndex < prev) {
         const editor = this.activeCell!.editor;
-        if (editor) {
-          const lastLine = editor.lineCount - 1;
-          editor.setCursorPosition({ line: lastLine, column: 0 });
-        }
+        const lastLine = editor.lineCount - 1;
+        editor.setCursorPosition({ line: lastLine, column: 0 });
       }
     } else if (location === 'bottom') {
       this.activeCellIndex++;
       // Move the cursor to the first character.
       if (this.activeCellIndex > prev) {
         const editor = this.activeCell!.editor;
-        if (editor) {
-          editor.setCursorPosition({ line: 0, column: 0 });
-        }
+        editor.setCursorPosition({ line: 0, column: 0 });
       }
     }
     this.mode = 'edit';
@@ -2229,38 +1888,14 @@
    * Ensure that the notebook has proper focus.
    */
   private _ensureFocus(force = false): void {
-    // No-op is the footer has the focus.
-    const footer = (this.layout as NotebookWindowedLayout).footer;
-    if (footer && document.activeElement === footer.node) {
-      return;
-    }
     const activeCell = this.activeCell;
     if (this.mode === 'edit' && activeCell) {
-      // Test for !== true to cover hasFocus is false and editor is not yet rendered.
-      if (activeCell.editor?.hasFocus() !== true) {
-        if (activeCell.inViewport) {
-          activeCell.editor?.focus();
-        } else {
-          this.scrollToItem(this.activeCellIndex)
-            .then(() => {
-              void activeCell.ready.then(() => {
-                activeCell.editor?.focus();
-              });
-            })
-            .catch(reason => {
-              // no-op
-            });
-        }
-      }
-    }
-    if (
-      force &&
-      activeCell &&
-      !activeCell.node.contains(document.activeElement)
-    ) {
-      void NotebookActions.focusActiveCell(this, {
-        preventScroll: true
-      });
+      if (!activeCell.editor.hasFocus()) {
+        activeCell.editor.focus();
+      }
+    }
+    if (force && !this.node.contains(document.activeElement)) {
+      this.node.focus();
     }
   }
 
@@ -2314,69 +1949,6 @@
   }
 
   /**
-   * Find heading with given ID in any of the cells.
-   */
-  async _findHeading(queryId: string): Promise<Private.IScrollTarget | null> {
-    // Loop on cells, get headings and search for first matching id.
-    for (let cellIdx = 0; cellIdx < this.widgets.length; cellIdx++) {
-      const cell = this.widgets[cellIdx];
-      if (
-        cell.model.type === 'raw' ||
-        (cell.model.type === 'markdown' && !(cell as MarkdownCell).rendered)
-      ) {
-        // Bail early
-        continue;
-      }
-      for (const heading of cell.headings) {
-        let id: string | undefined | null = '';
-        switch (heading.type) {
-          case Cell.HeadingType.HTML:
-            id = (heading as TableOfContentsUtils.IHTMLHeading).id;
-            break;
-          case Cell.HeadingType.Markdown:
-            {
-              const mdHeading =
-                heading as any as TableOfContentsUtils.Markdown.IMarkdownHeading;
-              id = await TableOfContentsUtils.Markdown.getHeadingId(
-                this.rendermime.markdownParser!,
-                mdHeading.raw,
-                mdHeading.level,
-                this.rendermime.sanitizer
-              );
-            }
-            break;
-        }
-        if (id === queryId) {
-          const element = this.node.querySelector(
-            `h${heading.level}[id="${CSS.escape(id)}"]`
-          ) as HTMLElement;
-
-          return {
-            cell,
-            element
-          };
-        }
-      }
-    }
-    return null;
-  }
-
-  /**
-   * Find cell by its unique ID.
-   */
-  _findCellById(queryId: string): Private.IScrollTarget | null {
-    for (let cellIdx = 0; cellIdx < this.widgets.length; cellIdx++) {
-      const cell = this.widgets[cellIdx];
-      if (cell.model.id === queryId) {
-        return {
-          cell
-        };
-      }
-    }
-    return null;
-  }
-
-  /**
    * Handle `contextmenu` event.
    */
   private _evtContextMenuCapture(event: PointerEvent): void {
@@ -2390,7 +1962,7 @@
     const [target, index] = this._findEventTargetAndCell(event);
     const widget = this.widgets[index];
 
-    if (widget && widget.editorWidget?.node.contains(target)) {
+    if (widget && widget.editorWidget.node.contains(target)) {
       // Prevent CodeMirror from focusing the editor.
       // TODO: find an editor-agnostic solution.
       event.preventDefault();
@@ -2413,7 +1985,7 @@
       button === 2 &&
       !shiftKey &&
       widget &&
-      widget.editorWidget?.node.contains(target)
+      widget.editorWidget.node.contains(target)
     ) {
       this.mode = 'command';
 
@@ -2444,9 +2016,9 @@
 
     let targetArea: 'input' | 'prompt' | 'cell' | 'notebook';
     if (widget) {
-      if (widget.editorWidget?.node.contains(target)) {
+      if (widget.editorWidget.node.contains(target)) {
         targetArea = 'input';
-      } else if (widget.promptNode?.contains(target)) {
+      } else if (widget.promptNode.contains(target)) {
         targetArea = 'prompt';
       } else {
         targetArea = 'cell';
@@ -2487,13 +2059,6 @@
         }
         // Enter selecting mode
         this._mouseMode = 'select';
-
-        // We don't want to block the shift-click mouse up handler
-        // when the current cell is (and remains) the active cell.
-        this._selectData = {
-          startedOnActiveCell: index == this.activeCellIndex,
-          startingCellIndex: this.activeCellIndex
-        };
         document.addEventListener('mouseup', this, true);
         document.addEventListener('mousemove', this, true);
       } else if (button === 0 && !shiftKey) {
@@ -2539,21 +2104,8 @@
    * Handle the `'mouseup'` event on the document.
    */
   private _evtDocumentMouseup(event: MouseEvent): void {
-    const [, index] = this._findEventTargetAndCell(event);
-
-    let shouldPreventDefault = true;
-    if (this._mouseMode === 'select' && this._selectData) {
-      // User did not move the mouse over to a difference cell, so there was no selection
-      const { startedOnActiveCell, startingCellIndex } = this._selectData;
-      if (startedOnActiveCell && index === startingCellIndex) {
-        shouldPreventDefault = false;
-      }
-      this._selectData = null;
-    }
-    if (shouldPreventDefault) {
-      event.preventDefault();
-      event.stopPropagation();
-    }
+    event.preventDefault();
+    event.stopPropagation();
 
     // Remove the event listeners we put on the document
     document.removeEventListener('mousemove', this, true);
@@ -2561,12 +2113,14 @@
 
     if (this._mouseMode === 'couldDrag') {
       // We didn't end up dragging if we are here, so treat it as a click event.
+
+      const [, index] = this._findEventTargetAndCell(event);
 
       this.deselectAll();
       this.activeCellIndex = index;
       // Focus notebook if active cell changes but does not have focus.
       if (!this.activeCell!.node.contains(document.activeElement)) {
-        void NotebookActions.focusActiveCell(this);
+        this.node.focus();
       }
     }
 
@@ -2609,7 +2163,7 @@
   /**
    * Handle the `'lm-dragenter'` event for the widget.
    */
-  private _evtDragEnter(event: Drag.Event): void {
+  private _evtDragEnter(event: IDragEvent): void {
     if (!event.mimeData.hasData(JUPYTER_CELL_MIME)) {
       return;
     }
@@ -2621,14 +2175,14 @@
       return;
     }
 
-    const widget = this.cellsArray[index];
+    const widget = (this.layout as PanelLayout).widgets[index];
     widget.node.classList.add(DROP_TARGET_CLASS);
   }
 
   /**
    * Handle the `'lm-dragleave'` event for the widget.
    */
-  private _evtDragLeave(event: Drag.Event): void {
+  private _evtDragLeave(event: IDragEvent): void {
     if (!event.mimeData.hasData(JUPYTER_CELL_MIME)) {
       return;
     }
@@ -2643,7 +2197,7 @@
   /**
    * Handle the `'lm-dragover'` event for the widget.
    */
-  private _evtDragOver(event: Drag.Event): void {
+  private _evtDragOver(event: IDragEvent): void {
     if (!event.mimeData.hasData(JUPYTER_CELL_MIME)) {
       return;
     }
@@ -2659,14 +2213,14 @@
     if (index === -1) {
       return;
     }
-    const widget = this.cellsArray[index];
+    const widget = (this.layout as PanelLayout).widgets[index];
     widget.node.classList.add(DROP_TARGET_CLASS);
   }
 
   /**
    * Handle the `'lm-drop'` event for the widget.
    */
-  private _evtDrop(event: Drag.Event): void {
+  private _evtDrop(event: IDragEvent): void {
     if (!event.mimeData.hasData(JUPYTER_CELL_MIME)) {
       return;
     }
@@ -2727,7 +2281,17 @@
       }
 
       // Move the cells one by one
-      this.moveCell(fromIndex, toIndex, toMove.length);
+      model.cells.beginCompoundOperation();
+      if (fromIndex < toIndex) {
+        each(toMove, cellWidget => {
+          model.cells.move(fromIndex, toIndex);
+        });
+      } else if (fromIndex > toIndex) {
+        each(toMove, cellWidget => {
+          model.cells.move(fromIndex++, toIndex++);
+        });
+      }
+      model.cells.endCompoundOperation();
     } else {
       // Handle the case where we are copying cells between
       // notebooks.
@@ -2739,15 +2303,31 @@
       }
       const start = index;
       const values = event.mimeData.getData(JUPYTER_CELL_MIME);
+      const factory = model.contentFactory;
+
       // Insert the copies of the original cells.
-      // We preserve trust status of pasted cells by not modifying metadata.
-      model.sharedModel.insertCells(index, values);
+      model.cells.beginCompoundOperation();
+      each(values, (cell: nbformat.ICell) => {
+        let value: ICellModel;
+        switch (cell.cell_type) {
+          case 'code':
+            value = factory.createCodeCell({ cell });
+            break;
+          case 'markdown':
+            value = factory.createMarkdownCell({ cell });
+            break;
+          default:
+            value = factory.createRawCell({ cell });
+            break;
+        }
+        model.cells.insert(index++, value);
+      });
+      model.cells.endCompoundOperation();
       // Select the inserted cells.
       this.deselectAll();
       this.activeCellIndex = start;
       this.extendContiguousSelectionTo(index - 1);
     }
-    void NotebookActions.focusActiveCell(this);
   }
 
   /**
@@ -2757,15 +2337,15 @@
     const cells = this.model!.cells;
     const selected: nbformat.ICell[] = [];
     const toMove: Cell[] = [];
-    let i = -1;
-    for (const widget of this.widgets) {
-      const cell = cells.get(++i);
+
+    each(this.widgets, (widget, i) => {
+      const cell = cells.get(i);
       if (this.isSelectedOrActive(widget)) {
         widget.addClass(DROP_SOURCE_CLASS);
         selected.push(cell.toJSON());
         toMove.push(widget);
       }
-    }
+    });
     const activeCell = this.activeCell;
     let dragImage: HTMLElement | null = null;
     let countString: string;
@@ -2784,8 +2364,7 @@
     dragImage = Private.createDragImage(
       selected.length,
       countString,
-      activeCell?.model.sharedModel.getSource().split('\n')[0].slice(0, 26) ??
-        ''
+      activeCell?.model.value.text.split('\n')[0].slice(0, 26) ?? ''
     );
 
     // Set up the drag event.
@@ -2803,9 +2382,7 @@
     this._drag.mimeData.setData('internal:cells', toMove);
     // Add mimeData for the text content of the selected cells,
     // allowing for drag/drop into plain text fields.
-    const textContent = toMove
-      .map(cell => cell.model.sharedModel.getSource())
-      .join('\n');
+    const textContent = toMove.map(cell => cell.model.value.text).join('\n');
     this._drag.mimeData.setData('text/plain', textContent);
 
     // Remove mousemove and mouseup listeners and start the drag.
@@ -2817,85 +2394,41 @@
         return;
       }
       this._drag = null;
-      for (const widget of toMove) {
+      each(toMove, widget => {
         widget.removeClass(DROP_SOURCE_CLASS);
-      }
+      });
     });
   }
 
   /**
-   * Update the notebook node with class indicating read-write state.
-   */
-  private _updateReadWrite(): void {
-    const inReadWrite = DOMUtils.hasActiveEditableElement(this.node);
-    this.node.classList.toggle(READ_WRITE_CLASS, inReadWrite);
-  }
-
-  /**
    * Handle `focus` events for the widget.
    */
-  private _evtFocusIn(event: FocusEvent): void {
-    // Update read-write class state.
-    this._updateReadWrite();
-
+  private _evtFocusIn(event: MouseEvent): void {
     const target = event.target as HTMLElement;
     const index = this._findCell(target);
     if (index !== -1) {
       const widget = this.widgets[index];
       // If the editor itself does not have focus, ensure command mode.
-      if (widget.editorWidget && !widget.editorWidget.node.contains(target)) {
-        this.setMode('command', { focus: false });
-      }
-
-      // Cell index needs to be updated before changing mode,
-      // otherwise the previous cell may get un-rendered.
+      if (!widget.editorWidget.node.contains(target)) {
+        this.mode = 'command';
+      }
       this.activeCellIndex = index;
-
       // If the editor has focus, ensure edit mode.
-      const node = widget.editorWidget?.node;
-      if (node?.contains(target)) {
-        this.setMode('edit', { focus: false });
-      }
+      const node = widget.editorWidget.node;
+      if (node.contains(target)) {
+        this.mode = 'edit';
+      }
+      this.activeCellIndex = index;
     } else {
       // No cell has focus, ensure command mode.
-      this.setMode('command', { focus: false });
-
-      // Prevents the parent element to get the focus.
-      event.preventDefault();
-
-      // Check if the focus was previously in the active cell to avoid focus looping
-      // between the cell and the cell toolbar.
-      const source = event.relatedTarget as HTMLElement;
-
-      // Focuses on the active cell if the focus did not come from it.
-      // Otherwise focus on the footer element (add cell button).
-      if (this._activeCell && !this._activeCell.node.contains(source)) {
-        this._activeCell.ready
-          .then(() => {
-            this._activeCell?.node.focus({
-              preventScroll: true
-            });
-          })
-          .catch(() => {
-            (this.layout as NotebookWindowedLayout).footer?.node.focus({
-              preventScroll: true
-            });
-          });
-      } else {
-        (this.layout as NotebookWindowedLayout).footer?.node.focus({
-          preventScroll: true
-        });
-      }
+      this.mode = 'command';
     }
   }
 
   /**
    * Handle `focusout` events for the notebook.
    */
-  private _evtFocusOut(event: FocusEvent): void {
-    // Update read-write class state.
-    this._updateReadWrite();
-
+  private _evtFocusOut(event: MouseEvent): void {
     const relatedTarget = event.relatedTarget as HTMLElement;
 
     // Bail if the window is losing focus, to preserve edit mode. This test
@@ -2909,14 +2442,20 @@
     const index = this._findCell(relatedTarget);
     if (index !== -1) {
       const widget = this.widgets[index];
-      if (widget.editorWidget?.node.contains(relatedTarget)) {
+      if (widget.editorWidget.node.contains(relatedTarget)) {
         return;
       }
     }
 
     // Otherwise enter command mode if not already.
     if (this.mode !== 'command') {
-      this.setMode('command', { focus: false });
+      this.mode = 'command';
+
+      // Switching to command mode currently focuses the notebook element, so
+      // refocus the relatedTarget so the focus actually switches as intended.
+      if (relatedTarget) {
+        relatedTarget.focus();
+      }
     }
   }
 
@@ -2957,9 +2496,7 @@
     for (let i = 0; i < this.widgets.length; i++) {
       if (i !== this._activeCellIndex) {
         const cell = this.widgets[i];
-        if (!cell.model.isDisposed && cell.editor) {
-          cell.model.selections.delete(cell.editor.uuid);
-        }
+        cell.model.selections.delete(cell.editor.uuid);
       }
     }
   }
@@ -2968,17 +2505,14 @@
   private _activeCell: Cell | null = null;
   private _mode: NotebookMode = 'command';
   private _drag: Drag | null = null;
+  private _fragment = '';
   private _dragData: {
     pressX: number;
     pressY: number;
     index: number;
   } | null = null;
-  private _selectData: {
-    startedOnActiveCell: boolean;
-    startingCellIndex: number;
-  } | null = null;
   private _mouseMode: 'select' | 'couldDrag' | null = null;
-  private _activeCellChanged = new Signal<this, Cell | null>(this);
+  private _activeCellChanged = new Signal<this, Cell>(this);
   private _stateChanged = new Signal<this, IChangedArgs<any>>(this);
   private _selectionChanged = new Signal<this, void>(this);
 
@@ -2987,15 +2521,6 @@
   private _checkCacheOnNextResize = false;
 
   private _lastClipboardInteraction: 'copy' | 'cut' | 'paste' | null = null;
-  private _updateSelectedCells(): void {
-    this._selectedCells = this.widgets.filter(cell =>
-      this.isSelectedOrActive(cell)
-    );
-    if (this.kernelHistory) {
-      this.kernelHistory.reset();
-    }
-  }
-  private _selectedCells: Cell[] = [];
 }
 
 /**
@@ -3030,6 +2555,8 @@
      */
     export interface IOptions extends StaticNotebook.ContentFactory.IOptions {}
   }
+
+  export const defaultContentFactory: IContentFactory = new ContentFactory();
 }
 
 /**
@@ -3124,30 +2651,23 @@
   }
 
   /**
-   * Information about resolved scroll target defined by URL fragment.
-   */
-  export interface IScrollTarget {
-    /**
-     * Target cell.
-     */
-    cell: Cell;
-    /**
-     * Element to scroll to within the cell.
-     */
-    element?: HTMLElement;
-  }
-
-  /**
-   * Parsed fragment identifier data.
-   */
-  export interface IFragmentData {
-    /**
-     * The kind of notebook element targetted by the fragment identifier.
-     */
-    kind: 'heading' | 'cell-id';
-    /*
-     * The value of the fragment query.
-     */
-    value: string;
+   * Process the `IOptions` passed to the notebook widget.
+   *
+   * #### Notes
+   * This defaults the content factory to that in the `Notebook` namespace.
+   */
+  export function processNotebookOptions(
+    options: Notebook.IOptions
+  ): Notebook.IOptions {
+    if (options.contentFactory) {
+      return options;
+    } else {
+      return {
+        rendermime: options.rendermime,
+        languagePreference: options.languagePreference,
+        contentFactory: Notebook.defaultContentFactory,
+        mimeTypeService: options.mimeTypeService
+      };
+    }
   }
 }