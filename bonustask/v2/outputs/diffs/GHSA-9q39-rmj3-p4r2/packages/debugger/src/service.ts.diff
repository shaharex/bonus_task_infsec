--- packages\debugger\src\service.ts (old)
+++ packages\debugger\src\service.ts (new)
@@ -2,12 +2,6 @@
 // Distributed under the terms of the Modified BSD License.
 
 import { KernelSpec, Session } from '@jupyterlab/services';
-
-import {
-  ITranslator,
-  nullTranslator,
-  TranslationBundle
-} from '@jupyterlab/translation';
 
 import { IDisposable } from '@lumino/disposable';
 
@@ -41,7 +35,6 @@
     this._specsManager = options.specsManager ?? null;
     this._model = new Debugger.Model();
     this._debuggerSources = options.debuggerSources ?? null;
-    this._trans = (options.translator || nullTranslator).load('jupyterlab');
   }
 
   /**
@@ -52,13 +45,6 @@
   }
 
   /**
-   * Get debugger config.
-   */
-  get config(): IDebugger.IConfig {
-    return this._config;
-  }
-
-  /**
    * Whether the debug service is disposed.
    */
   get isDisposed(): boolean {
@@ -73,10 +59,20 @@
   }
 
   /**
-   * A signal emitted when the pause on exception filter changes.
-   */
-  get pauseOnExceptionChanged(): Signal<IDebugger, void> {
-    return this._pauseOnExceptionChanged;
+   * Whether the current debugger is pausing on exceptions.
+   */
+  get isPausingOnExceptions(): boolean {
+    const kernel = this.session?.connection?.kernel?.name ?? '';
+    if (kernel) {
+      const tmpFileParams = this._config.getTmpFileParams(kernel);
+      if (tmpFileParams) {
+        return (
+          this._session?.pausingOnExceptions.includes(tmpFileParams.prefix) ??
+          false
+        );
+      }
+    }
+    return false;
   }
 
   /**
@@ -118,7 +114,6 @@
       }
       this._eventMessage.emit(event);
     });
-
     this._sessionChanged.emit(session);
   }
 
@@ -328,41 +323,6 @@
   }
 
   /**
-   * Request to set a variable in the global scope.
-   *
-   * @param name The name of the variable.
-   */
-  async copyToGlobals(name: string): Promise<void> {
-    if (!this.session) {
-      throw new Error('No active debugger session');
-    }
-    if (!this.model.supportCopyToGlobals) {
-      throw new Error(
-        'The "copyToGlobals" request is not supported by the kernel'
-      );
-    }
-
-    const frames = this.model.callstack.frames;
-    this.session
-      .sendRequest('copyToGlobals', {
-        srcVariableName: name,
-        dstVariableName: name,
-        srcFrameId: frames[0].id
-      })
-      .then(async () => {
-        const scopes = await this._getScopes(frames[0]);
-        const variables = await Promise.all(
-          scopes.map(scope => this._getVariables(scope))
-        );
-        const variableScopes = this._convertScopes(scopes, variables);
-        this._model.variables.scopes = variableScopes;
-      })
-      .catch(reason => {
-        console.error(reason);
-      });
-  }
-
-  /**
    * Requests all the defined variables and display them in the
    * table view.
    */
@@ -375,27 +335,11 @@
 
     const variableScopes = [
       {
-        name: this._trans.__('Globals'),
+        name: 'Globals',
         variables: variables
       }
     ];
     this._model.variables.scopes = variableScopes;
-  }
-
-  async displayModules(): Promise<void> {
-    if (!this.session) {
-      throw new Error('No active debugger session');
-    }
-
-    const modules = await this.session.sendRequest('modules', {});
-    this._model.kernelSources.kernelSources = modules.body.modules.map(
-      module => {
-        return {
-          name: module.name as string,
-          path: module.path as string
-        };
-      }
-    );
   }
 
   /**
@@ -424,8 +368,6 @@
     const stoppedThreads = new Set(body.stoppedThreads);
 
     this._model.hasRichVariableRendering = body.richRendering === true;
-    this._model.supportCopyToGlobals = body.copyToGlobals === true;
-
     this._config.setHashParams({
       kernel: this.session?.connection?.kernel?.name ?? '',
       method: body.hashMethod,
@@ -461,11 +403,6 @@
     } else if (this.isStarted) {
       this._clearModel();
       this._clearSignals();
-    }
-
-    // Send the currentExceptionFilters to debugger.
-    if (this.session.currentExceptionFilters) {
-      await this.pauseOnExceptions(this.session.currentExceptionFilters);
     }
   }
 
@@ -576,19 +513,11 @@
       this._model.breakpoints.restoreBreakpoints(remoteBreakpoints);
     }
 
-    // Removes duplicated breakpoints. It is better to do it here than
-    // in the editor, because the kernel can change the line of a
-    // breakpoint (when you attemp to set a breakpoint on an empty
-    // line for instance).
-    let addedLines = new Set<number>();
     // Set the kernel's breakpoints for this path.
     const reply = await this._setBreakpoints(localBreakpoints, path);
-    const updatedBreakpoints = reply.body.breakpoints.filter((val, _, arr) => {
-      const cond1 = arr.findIndex(el => el.line === val.line) > -1;
-      const cond2 = !addedLines.has(val.line!);
-      addedLines.add(val.line!);
-      return cond1 && cond2;
-    });
+    const updatedBreakpoints = reply.body.breakpoints.filter(
+      (val, _, arr) => arr.findIndex(el => el.line === val.line) > -1
+    );
 
     // Update the local model and finish kernel configuration.
     this._model.breakpoints.setBreakpoints(path, updatedBreakpoints);
@@ -597,10 +526,11 @@
 
   /**
    * Determines if pausing on exceptions is supported by the kernel
+   *
    */
   pauseOnExceptionsIsValid(): boolean {
     if (this.isStarted) {
-      if (this.session?.exceptionBreakpointFilters?.length !== 0) {
+      if (this.session?.exceptionBreakpointFilters) {
         return true;
       }
     }
@@ -608,46 +538,56 @@
   }
 
   /**
-   * Add or remove a filter from the current used filters.
-   *
-   * @param exceptionFilter - The filter to add or remove from current filters.
-   */
-  async pauseOnExceptionsFilter(exceptionFilter: string): Promise<void> {
+   * Enable or disable pausing on exceptions.
+   *
+   * @param enable - Whether to enbale or disable pausing on exceptions.
+   */
+  async pauseOnExceptions(enable: boolean): Promise<void> {
     if (!this.session?.isStarted) {
       return;
     }
-    let exceptionFilters = this.session.currentExceptionFilters;
-    if (this.session.isPausingOnException(exceptionFilter)) {
-      const index = exceptionFilters.indexOf(exceptionFilter);
-      exceptionFilters.splice(index, 1);
+
+    const kernel = this.session?.connection?.kernel?.name ?? '';
+    if (!kernel) {
+      return;
+    }
+    const tmpFileParams = this._config.getTmpFileParams(kernel);
+    if (!tmpFileParams) {
+      return;
+    }
+    let prefix = tmpFileParams.prefix;
+    const exceptionBreakpointFilters = this.session.exceptionBreakpointFilters;
+    let pauseOnExceptionKernels = this.session.pausingOnExceptions;
+    if (enable) {
+      if (!this.session.pausingOnExceptions.includes(prefix)) {
+        pauseOnExceptionKernels.push(prefix);
+        this.session.pausingOnExceptions = pauseOnExceptionKernels;
+      }
     } else {
-      exceptionFilters?.push(exceptionFilter);
-    }
-    await this.pauseOnExceptions(exceptionFilters);
-  }
-
-  /**
-   * Enable or disable pausing on exceptions.
-   *
-   * @param exceptionFilters - The filters to use for the current debugging session.
-   */
-  async pauseOnExceptions(exceptionFilters: string[]): Promise<void> {
-    if (!this.session?.isStarted) {
-      return;
-    }
-    const exceptionBreakpointFilters =
-      this.session.exceptionBreakpointFilters?.map(e => e.filter) || [];
-    let options: DebugProtocol.SetExceptionBreakpointsArguments = {
-      filters: []
+      let prefixIndex = this.session.pausingOnExceptions.indexOf(prefix);
+      if (prefixIndex > -1) {
+        this.session.pausingOnExceptions = pauseOnExceptionKernels.splice(
+          prefixIndex,
+          1
+        );
+        this.session.pausingOnExceptions = pauseOnExceptionKernels;
+      }
+    }
+    const filters: string[] = [];
+    const exceptionOptions: DebugProtocol.ExceptionOptions[] = [];
+    const breakMode = enable ? 'userUnhandled' : 'never';
+    for (let filterDict of exceptionBreakpointFilters ?? []) {
+      filters.push(filterDict.filter);
+      exceptionOptions.push({
+        path: [{ names: this.session.exceptionPaths }],
+        breakMode: breakMode
+      });
+    }
+    const options: DebugProtocol.SetExceptionBreakpointsArguments = {
+      filters: filters,
+      exceptionOptions: exceptionOptions
     };
-    exceptionFilters.forEach(filter => {
-      if (exceptionBreakpointFilters.includes(filter)) {
-        options.filters.push(filter);
-      }
-    });
-    this.session.currentExceptionFilters = options.filters;
     await this.session.sendRequest('setExceptionBreakpoints', options);
-    this._pauseOnExceptionChanged.emit();
   }
 
   /**
@@ -658,17 +598,15 @@
   getDebuggerState(): IDebugger.State {
     const breakpoints = this._model.breakpoints.breakpoints;
     let cells: string[] = [];
-    if (this._debuggerSources) {
-      for (const id of breakpoints.keys()) {
-        const editorList = this._debuggerSources.find({
-          focus: false,
-          kernel: this.session?.connection?.kernel?.name ?? '',
-          path: this._session?.connection?.path ?? '',
-          source: id
-        });
-        const tmpCells = editorList.map(e => e.src.getSource());
-        cells = cells.concat(tmpCells);
-      }
+    for (const id of breakpoints.keys()) {
+      const editorList = this._debuggerSources!.find({
+        focus: false,
+        kernel: this.session?.connection?.kernel?.name ?? '',
+        path: this._session?.connection?.path ?? '',
+        source: id
+      });
+      const tmp_cells = editorList.map(e => e.model.value.text);
+      cells = cells.concat(tmp_cells);
     }
     return { cells, breakpoints };
   }
@@ -929,6 +867,22 @@
     this._model.variables.scopes = variableScopes;
   }
 
+  async displayModules(): Promise<void> {
+    if (!this.session) {
+      throw new Error('No active debugger session');
+    }
+
+    const modules = await this.session.sendRequest('modules', {});
+    this._model.kernelSources.kernelSources = modules.body.modules.map(
+      module => {
+        return {
+          name: module.name as string,
+          path: module.path as string
+        };
+      }
+    );
+  }
+
   /**
    * Handle a variable expanded event and request variables from the kernel.
    *
@@ -1011,8 +965,6 @@
     this
   );
   private _specsManager: KernelSpec.IManager | null;
-  private _trans: TranslationBundle;
-  private _pauseOnExceptionChanged = new Signal<IDebugger, void>(this);
 }
 
 /**
@@ -1037,10 +989,5 @@
      * The optional kernel specs manager.
      */
     specsManager?: KernelSpec.IManager | null;
-
-    /**
-     * The application language translator.
-     */
-    translator?: ITranslator | null;
   }
 }