--- packages\debugger\src\handlers\notebook.ts (old)
+++ packages\debugger\src\handlers\notebook.ts (new)
@@ -2,15 +2,22 @@
 // Distributed under the terms of the Modified BSD License.
 
 import { Cell, CodeCell, ICellModel } from '@jupyterlab/cells';
-import { NotebookPanel } from '@jupyterlab/notebook';
+
 import {
   IObservableList,
   IObservableMap,
+  IObservableUndoableList,
   ObservableMap
 } from '@jupyterlab/observables';
+
+import { Notebook, NotebookPanel } from '@jupyterlab/notebook';
+
 import { IDisposable } from '@lumino/disposable';
+
 import { Signal } from '@lumino/signaling';
+
 import { IDebugger } from '../tokens';
+
 import { EditorHandler } from './editor';
 
 /**
@@ -28,7 +35,8 @@
     this._cellMap = new ObservableMap<EditorHandler>();
 
     const notebook = this._notebookPanel.content;
-    notebook.model!.cells.changed.connect(this._onCellsChanged, this);
+    notebook.activeCellChanged.connect(this._onActiveCellChanged, this);
+    notebook.model?.cells.changed.connect(this._onCellsChanged, this);
 
     this._onCellsChanged();
   }
@@ -49,7 +57,7 @@
     this._cellMap.values().forEach(handler => {
       handler.dispose();
       // Ensure to restore notebook editor settings
-      handler.editor?.setOptions({
+      handler.editor.setOptions({
         ...this._notebookPanel.content.editorConfig.code
       });
     });
@@ -61,7 +69,7 @@
    * Handle a notebook cells changed event.
    */
   private _onCellsChanged(
-    cells?: any,
+    cells?: IObservableUndoableList<ICellModel>,
     changes?: IObservableList.IChangedArgs<ICellModel>
   ): void {
     this._notebookPanel.content.widgets.forEach(cell =>
@@ -88,18 +96,26 @@
     const codeCell = cell as CodeCell;
     const editorHandler = new EditorHandler({
       debuggerService: this._debuggerService,
-      editorReady: async () => {
-        await codeCell.ready;
-        return codeCell.editor!;
-      },
-      getEditor: () => codeCell.editor,
-      src: cell.model.sharedModel
+      editor: codeCell.editor
     });
     codeCell.disposed.connect(() => {
       this._cellMap.delete(modelId);
       editorHandler.dispose();
     });
     this._cellMap.set(cell.model.id, editorHandler);
+  }
+
+  /**
+   * Handle a new active cell.
+   *
+   * @param notebook The notebook for which the active cell has changed.
+   * @param cell The new active cell.
+   */
+  private _onActiveCellChanged(notebook: Notebook, cell: Cell): void {
+    if (this._notebookPanel.content !== notebook) {
+      return;
+    }
+    this._addEditorHandler(cell);
   }
 
   private _debuggerService: IDebugger;