--- packages\application\src\shell.ts (old)
+++ packages\application\src\shell.ts (new)
@@ -7,18 +7,14 @@
   classes,
   DockPanelSvg,
   LabIcon,
-  SidePanel,
-  TabBarSvg,
-  tabIcon,
   TabPanelSvg
 } from '@jupyterlab/ui-components';
-import { ArrayExt, find, map } from '@lumino/algorithm';
-import { JSONExt, PromiseDelegate, Token } from '@lumino/coreutils';
+import { ArrayExt, find, IIterator, iter, toArray } from '@lumino/algorithm';
+import { PromiseDelegate, Token } from '@lumino/coreutils';
 import { IMessageHandler, Message, MessageLoop } from '@lumino/messaging';
 import { Debouncer } from '@lumino/polling';
 import { ISignal, Signal } from '@lumino/signaling';
 import {
-  AccordionPanel,
   BoxLayout,
   BoxPanel,
   DockLayout,
@@ -66,8 +62,7 @@
  * The JupyterLab application shell token.
  */
 export const ILabShell = new Token<ILabShell>(
-  '@jupyterlab/application:ILabShell',
-  'A service for interacting with the JupyterLab shell. The top-level ``application`` object also has a reference to the shell, but it has a restricted interface in order to be agnostic to different shell implementations on the application. Use this to get more detailed information about currently active widgets and layout state.'
+  '@jupyterlab/application:ILabShell'
 );
 
 /**
@@ -102,12 +97,9 @@
    */
   export type IOptions = {
     /**
-     * Whether the layout should wait to be restored before adding widgets or not.
-     *
-     * #### Notes
-     * It defaults to true
-     */
-    waitForRestore?: boolean;
+     * The application language translator.
+     */
+    translator?: ITranslator;
   };
 
   /**
@@ -130,37 +122,6 @@
   }
 
   /**
-   * Widget position
-   */
-  export interface IWidgetPosition {
-    /**
-     * Widget area
-     */
-    area?: Area;
-    /**
-     * Widget opening options
-     */
-    options?: DocumentRegistry.IOpenOptions;
-  }
-
-  /**
-   * To-be-added widget and associated position
-   */
-  export interface IDelayedWidget extends IWidgetPosition {
-    widget: Widget;
-  }
-
-  /**
-   * Mapping of widget type identifier and their user customized position
-   */
-  export interface IUserLayout {
-    /**
-     * Widget customized position
-     */
-    [k: string]: IWidgetPosition;
-  }
-
-  /**
    * The args for the current path change signal.
    */
   export interface ICurrentPathChangedArgs {
@@ -211,11 +172,6 @@
     readonly rightArea: ISideArea | null;
 
     /**
-     * The top area of the user interface.
-     */
-    readonly topArea: ITopArea | null;
-
-    /**
      * The relatives sizes of the areas of the user interface.
      */
     readonly relativeSizes: number[] | null;
@@ -270,50 +226,11 @@
     readonly currentWidget: Widget | null;
 
     /**
-     * A flag denoting whether the side tab bar is visible.
-     */
-    readonly visible: boolean;
-
-    /**
      * The collection of widgets held by the sidebar.
      */
     readonly widgets: Array<Widget> | null;
-
-    /**
-     * The collection of widgets states held by the sidebar.
-     */
-    readonly widgetStates: {
-      [id: string]: {
-        /**
-         * Vertical sizes of the widgets.
-         */
-        readonly sizes: Array<number> | null;
-
-        /**
-         * Expansion states of the widgets.
-         */
-        readonly expansionStates: Array<boolean> | null;
-      };
-    };
-  }
-
-  /**
-   * The restorable description of the top area in the user interface.
-   */
-  export interface ITopArea {
-    /**
-     * Top area visibility in simple mode.
-     */
-    readonly simpleVisibility: boolean;
   }
 }
-
-/**
- * The restorable description of the top area in the user interface.
- *
- * @deprecated It has been moved to {@link ILabShell.ITopArea} for consistency.
- */
-export interface ITopArea extends ILabShell.ITopArea {}
 
 /**
  * The application shell for JupyterLab.
@@ -326,37 +243,27 @@
     super();
     this.addClass(APPLICATION_SHELL_CLASS);
     this.id = 'main';
-    if (options?.waitForRestore === false) {
-      this._userLayout = { 'multiple-document': {}, 'single-document': {} };
-    }
-
-    // Skip Links
-    const skipLinkWidget = (this._skipLinkWidget = new Private.SkipLinkWidget(
-      this
-    ));
-    this._skipLinkWidget.show();
-    //  Wrap the skip widget to customize its position and size
-    const skipLinkWrapper = new Panel();
-    skipLinkWrapper.addClass('jp-skiplink-wrapper');
-    skipLinkWrapper.addWidget(skipLinkWidget);
-
+
+    const trans = ((options && options.translator) || nullTranslator).load(
+      'jupyterlab'
+    );
     const headerPanel = (this._headerPanel = new BoxPanel());
     const menuHandler = (this._menuHandler = new Private.PanelHandler());
     menuHandler.panel.node.setAttribute('role', 'navigation');
+    menuHandler.panel.node.setAttribute('aria-label', trans.__('main'));
     const topHandler = (this._topHandler = new Private.PanelHandler());
     topHandler.panel.node.setAttribute('role', 'banner');
     const bottomPanel = (this._bottomPanel = new BoxPanel());
     bottomPanel.node.setAttribute('role', 'contentinfo');
     const hboxPanel = new BoxPanel();
-    const vsplitPanel = (this._vsplitPanel =
-      new Private.RestorableSplitPanel());
+    const vsplitPanel = (this._vsplitPanel = new Private.RestorableSplitPanel());
     const dockPanel = (this._dockPanel = new DockPanelSvg({
-      hiddenMode: Widget.HiddenMode.Display
+      hiddenMode: Widget.HiddenMode.Display,
+      translator: options?.translator
     }));
     MessageLoop.installMessageHook(dockPanel, this._dockChildHook);
 
-    const hsplitPanel = (this._hsplitPanel =
-      new Private.RestorableSplitPanel());
+    const hsplitPanel = (this._hsplitPanel = new Private.RestorableSplitPanel());
     const downPanel = (this._downPanel = new TabPanelSvg({
       tabsMovable: true
     }));
@@ -376,11 +283,27 @@
 
     leftHandler.sideBar.addClass(SIDEBAR_CLASS);
     leftHandler.sideBar.addClass('jp-mod-left');
+    leftHandler.sideBar.node.setAttribute(
+      'aria-label',
+      trans.__('main sidebar')
+    );
+    leftHandler.sideBar.contentNode.setAttribute(
+      'aria-label',
+      trans.__('main sidebar')
+    );
     leftHandler.sideBar.node.setAttribute('role', 'complementary');
     leftHandler.stackedPanel.id = 'jp-left-stack';
 
     rightHandler.sideBar.addClass(SIDEBAR_CLASS);
     rightHandler.sideBar.addClass('jp-mod-right');
+    rightHandler.sideBar.node.setAttribute(
+      'aria-label',
+      trans.__('alternate sidebar')
+    );
+    rightHandler.sideBar.contentNode.setAttribute(
+      'aria-label',
+      trans.__('alternate sidebar')
+    );
     rightHandler.sideBar.node.setAttribute('role', 'complementary');
     rightHandler.stackedPanel.id = 'jp-right-stack';
 
@@ -433,7 +356,6 @@
     BoxLayout.setStretch(hboxPanel, 1);
     BoxLayout.setStretch(bottomPanel, 0);
 
-    rootLayout.addWidget(skipLinkWrapper);
     rootLayout.addWidget(headerPanel);
     rootLayout.addWidget(topHandler.panel);
     rootLayout.addWidget(hboxPanel);
@@ -465,8 +387,14 @@
     );
 
     // Catch current changed events on the side handlers.
-    this._leftHandler.updated.connect(this._onLayoutModified, this);
-    this._rightHandler.updated.connect(this._onLayoutModified, this);
+    this._leftHandler.sideBar.currentChanged.connect(
+      this._onLayoutModified,
+      this
+    );
+    this._rightHandler.sideBar.currentChanged.connect(
+      this._onLayoutModified,
+      this
+    );
 
     // Catch update events on the horizontal split panel
     this._hsplitPanel.updated.connect(this._onLayoutModified, this);
@@ -479,10 +407,16 @@
       this._topHandler.addWidget(this._menuHandler.panel, 100);
       titleHandler.hide();
     } else {
-      rootLayout.insertWidget(3, this._menuHandler.panel);
-    }
-
-    this.translator = nullTranslator;
+      rootLayout.insertWidget(2, this._menuHandler.panel);
+    }
+
+    // Skip Links
+    const skipLinkWidget = (this._skipLinkWidget = new Private.SkipLinkWidget(
+      this
+    ));
+
+    this.add(skipLinkWidget, 'top', { rank: 0 });
+    this._skipLinkWidget.show();
 
     // Wire up signals to update the title panel of the simple interface mode to
     // follow the title of this.currentWidget
@@ -493,23 +427,16 @@
       // Stop watching the title of the previously current widget
       if (oldValue) {
         oldValue.title.changed.disconnect(this._updateTitlePanelTitle, this);
-
-        if (oldValue instanceof DocumentWidget) {
-          oldValue.context.pathChanged.disconnect(
-            this._updateCurrentPath,
-            this
-          );
-        }
       }
 
       // Start watching the title of the new current widget
       if (newValue) {
         newValue.title.changed.connect(this._updateTitlePanelTitle, this);
         this._updateTitlePanelTitle();
-
-        if (newValue instanceof DocumentWidget) {
-          newValue.context.pathChanged.connect(this._updateCurrentPath, this);
-        }
+      }
+
+      if (newValue && newValue instanceof DocumentWidget) {
+        newValue.context.pathChanged.connect(this._updateCurrentPath, this);
       }
       this._updateCurrentPath();
     });
@@ -530,23 +457,6 @@
   }
 
   /**
-   * Whether the add buttons for each main area tab bar are enabled.
-   */
-  get addButtonEnabled(): boolean {
-    return this._dockPanel.addButtonEnabled;
-  }
-  set addButtonEnabled(value: boolean) {
-    this._dockPanel.addButtonEnabled = value;
-  }
-
-  /**
-   * A signal emitted when the add button on a main area tab bar is clicked.
-   */
-  get addRequested(): ISignal<DockPanel, TabBar<Widget>> {
-    return this._dockPanel.addRequested;
-  }
-
-  /**
    * A signal emitted when main area's current focus changes.
    */
   get currentChanged(): ISignal<this, ILabShell.IChangedArgs> {
@@ -554,11 +464,10 @@
   }
 
   /**
-   * Current document path.
-   */
-  // FIXME deprecation `undefined` is to ensure backward compatibility in 4.x
-  get currentPath(): string | null | undefined {
-    return this._currentPath;
+   * A signal emitted when the shell/dock panel change modes (single/multiple document).
+   */
+  get modeChanged(): ISignal<this, DockPanel.Mode> {
+    return this._modeChanged;
   }
 
   /**
@@ -605,6 +514,11 @@
   get presentationMode(): boolean {
     return this.hasClass('jp-mod-presentationMode');
   }
+
+  /**
+   * Enable/disable presentation mode (`jp-mod-presentationMode` CSS class) with
+   * a boolean.
+   */
   set presentationMode(value: boolean) {
     this.toggleClass('jp-mod-presentationMode', value);
   }
@@ -635,16 +549,13 @@
       }
 
       // Adjust menu and title
-      (this.layout as BoxLayout).insertWidget(3, this._menuHandler.panel);
+      (this.layout as BoxLayout).insertWidget(2, this._menuHandler.panel);
       this._titleHandler.show();
       this._updateTitlePanelTitle();
-      if (this._topHandlerHiddenByUser) {
-        this._topHandler.panel.hide();
-      }
     } else {
       // Cache a reference to every widget currently in the dock panel before
       // changing its mode.
-      const widgets = Array.from(dock.widgets());
+      const widgets = toArray(dock.widgets());
       dock.mode = mode;
 
       // Restore cached layout if possible.
@@ -699,6 +610,7 @@
 
       // Adjust menu and title
       this.add(this._menuHandler.panel, 'top', { rank: 100 });
+      // this._topHandler.addWidget(this._menuHandler.panel, 100)
       this._titleHandler.hide();
     }
 
@@ -711,62 +623,11 @@
   }
 
   /**
-   * A signal emitted when the shell/dock panel change modes (single/multiple document).
-   */
-  get modeChanged(): ISignal<this, DockPanel.Mode> {
-    return this._modeChanged;
-  }
-
-  /**
    * Promise that resolves when state is first restored, returning layout
    * description.
    */
   get restored(): Promise<ILabShell.ILayout> {
     return this._restored.promise;
-  }
-
-  get translator(): ITranslator {
-    return this._translator ?? nullTranslator;
-  }
-  set translator(value: ITranslator) {
-    if (value !== this._translator) {
-      this._translator = value;
-
-      // Set translator for tab bars
-      TabBarSvg.translator = value;
-
-      const trans = value.load('jupyterlab');
-      this._menuHandler.panel.node.setAttribute(
-        'aria-label',
-        trans.__('main menu')
-      );
-      this._leftHandler.sideBar.node.setAttribute(
-        'aria-label',
-        trans.__('main sidebar')
-      );
-      this._leftHandler.sideBar.contentNode.setAttribute(
-        'aria-label',
-        trans.__('main sidebar')
-      );
-      this._rightHandler.sideBar.node.setAttribute(
-        'aria-label',
-        trans.__('alternate sidebar')
-      );
-      this._rightHandler.sideBar.contentNode.setAttribute(
-        'aria-label',
-        trans.__('alternate sidebar')
-      );
-    }
-  }
-
-  /**
-   * User customized shell layout.
-   */
-  get userLayout(): {
-    'single-document': ILabShell.IUserLayout;
-    'multiple-document': ILabShell.IUserLayout;
-  } {
-    return JSONExt.deepCopy(this._userLayout as any);
   }
 
   /**
@@ -799,41 +660,7 @@
     }
   }
 
-  /**
-   * Activate widget in specified area.
-   *
-   * ### Notes
-   * The alpha version of this method only supports activating the "main" area.
-   *
-   * @alpha
-   * @param area Name of area to activate
-   */
-  activateArea(area: ILabShell.Area = 'main'): void {
-    switch (area) {
-      case 'main':
-        {
-          const current = this._currentTabBar();
-          if (!current) {
-            return;
-          }
-          if (current.currentTitle) {
-            current.currentTitle.owner.activate();
-          }
-        }
-        return;
-      case 'left':
-      case 'right':
-      case 'header':
-      case 'top':
-      case 'menu':
-      case 'bottom':
-        console.debug(`Area: ${area} activation not yet implemented`);
-        break;
-      default:
-        throw new Error(`Invalid area: ${area}`);
-    }
-  }
-  /**
+  /*
    * Activate the next Tab in the active TabBar.
    */
   activateNextTab(): void {
@@ -866,7 +693,25 @@
     }
   }
 
-  /**
+  /*
+   * Whether the add buttons for each main area tab bar are enabled.
+   */
+  get addButtonEnabled(): boolean {
+    return this._dockPanel.addButtonEnabled;
+  }
+
+  set addButtonEnabled(value: boolean) {
+    this._dockPanel.addButtonEnabled = value;
+  }
+
+  /*
+   * A signal emitted when the add button on a main area tab bar is clicked.
+   */
+  get addRequested(): ISignal<DockPanel, TabBar<Widget>> {
+    return this._dockPanel.addRequested;
+  }
+
+  /*
    * Activate the previous Tab in the active TabBar.
    */
   activatePreviousTab(): void {
@@ -900,7 +745,7 @@
     }
   }
 
-  /**
+  /*
    * Activate the next TabBar.
    */
   activateNextTabBar(): void {
@@ -912,7 +757,7 @@
     }
   }
 
-  /**
+  /*
    * Activate the next TabBar.
    */
   activatePreviousTabBar(): void {
@@ -924,46 +769,11 @@
     }
   }
 
-  /**
-   * Add a widget to the JupyterLab shell
-   *
-   * @param widget Widget
-   * @param area Area
-   * @param options Options
-   */
   add(
     widget: Widget,
     area: ILabShell.Area = 'main',
     options?: DocumentRegistry.IOpenOptions
   ): void {
-    if (!this._userLayout) {
-      this._delayedWidget.push({ widget, area, options });
-      return;
-    }
-
-    let userPosition: ILabShell.IWidgetPosition | undefined;
-    if (options?.type && this._userLayout[this.mode][options.type]) {
-      userPosition = this._userLayout[this.mode][options.type];
-      this._idTypeMap.set(widget.id, options.type);
-    } else {
-      userPosition = this._userLayout[this.mode][widget.id];
-    }
-    if (options?.type) {
-      this._idTypeMap.set(widget.id, options.type);
-      widget.disposed.connect(() => {
-        this._idTypeMap.delete(widget.id);
-      });
-    }
-
-    area = userPosition?.area ?? area;
-    options =
-      options || userPosition?.options
-        ? {
-            ...options,
-            ...userPosition?.options
-          }
-        : undefined;
-
     switch (area || 'main') {
       case 'bottom':
         return this._addToBottomArea(widget, options);
@@ -987,43 +797,6 @@
   }
 
   /**
-   * Move a widget type to a new area.
-   *
-   * The type is determined from the `widget.id` and fallback to `widget.id`.
-   *
-   * #### Notes
-   * If `mode` is undefined, both mode are updated.
-   * The new layout is now persisted.
-   *
-   * @param widget Widget to move
-   * @param area New area
-   * @param mode Mode to change
-   * @returns The new user layout
-   */
-  move(
-    widget: Widget,
-    area: ILabShell.Area,
-    mode?: DockPanel.Mode
-  ): {
-    'single-document': ILabShell.IUserLayout;
-    'multiple-document': ILabShell.IUserLayout;
-  } {
-    const type = this._idTypeMap.get(widget.id) ?? widget.id;
-    for (const m of ['single-document', 'multiple-document'].filter(
-      c => !mode || c === mode
-    )) {
-      this._userLayout[m as DockPanel.Mode][type] = {
-        ...this._userLayout[m as DockPanel.Mode][type],
-        area
-      };
-    }
-
-    this.add(widget, area);
-
-    return this._userLayout;
-  }
-
-  /**
    * Collapse the left area.
    */
   collapseLeft(): void {
@@ -1078,36 +851,12 @@
    * Close all widgets in the main and down area.
    */
   closeAll(): void {
-    // Make a copy of all the widget in the dock panel (using `Array.from()`)
+    // Make a copy of all the widget in the dock panel (using `toArray()`)
     // before removing them because removing them while iterating through them
     // modifies the underlying data of the iterator.
-    Array.from(this._dockPanel.widgets()).forEach(widget => widget.close());
+    toArray(this._dockPanel.widgets()).forEach(widget => widget.close());
 
     this._downPanel.stackedPanel.widgets.forEach(widget => widget.close());
-  }
-
-  /**
-   * Whether an side tab bar is visible or not.
-   *
-   * @param side Sidebar of interest
-   * @returns Side tab bar visibility
-   */
-  isSideTabBarVisible(side: 'left' | 'right'): boolean {
-    switch (side) {
-      case 'left':
-        return this._leftHandler.isVisible;
-      case 'right':
-        return this._rightHandler.isVisible;
-    }
-  }
-
-  /**
-   * Whether the top bar in simple mode is visible or not.
-   *
-   * @returns Top bar visibility
-   */
-  isTopInSimpleModeVisible(): boolean {
-    return !this._topHandlerHiddenByUser;
   }
 
   /**
@@ -1137,35 +886,19 @@
   }
 
   /**
-   * Restore the layout state and configuration for the application shell.
-   *
-   * #### Notes
-   * This should only be called once.
+   * Restore the layout state for the application shell.
    */
   async restoreLayout(
     mode: DockPanel.Mode,
-    layoutRestorer: LayoutRestorer,
-    configuration: {
-      [m: string]: ILabShell.IUserLayout;
-    } = {}
-  ): Promise<void> {
-    // Set the configuration and add widgets added before the shell was ready.
-    this._userLayout = {
-      'single-document': configuration['single-document'] ?? {},
-      'multiple-document': configuration['multiple-document'] ?? {}
-    };
-    this._delayedWidget.forEach(({ widget, area, options }) => {
-      this.add(widget, area, options);
-    });
-    this._delayedWidget.length = 0;
+    layoutRestorer: LayoutRestorer
+  ): Promise<ILabShell.ILayout> {
     this._layoutRestorer = layoutRestorer;
 
     // Get the layout from the restorer
     const layout = await layoutRestorer.fetch();
 
     // Reset the layout
-    const { mainArea, downArea, leftArea, rightArea, topArea, relativeSizes } =
-      layout;
+    const { mainArea, downArea, leftArea, rightArea, relativeSizes } = layout;
 
     // Rehydrate the main area.
     if (mainArea) {
@@ -1184,13 +917,6 @@
       // This is needed when loading in an empty workspace in single doc mode
       if (mode) {
         this.mode = mode;
-      }
-    }
-
-    if (topArea?.simpleVisibility !== undefined) {
-      this._topHandlerHiddenByUser = !topArea.simpleVisibility;
-      if (this.mode === 'single-document') {
-        this._topHandler.panel.setHidden(this._topHandlerHiddenByUser);
       }
     }
 
@@ -1274,6 +1000,8 @@
       MessageLoop.flush();
       this._restored.resolve(layout);
     }
+
+    return layout;
   }
 
   /**
@@ -1292,58 +1020,15 @@
       },
       downArea: {
         currentWidget: this._downPanel.currentWidget,
-        widgets: Array.from(this._downPanel.stackedPanel.widgets),
+        widgets: toArray(this._downPanel.stackedPanel.widgets),
         size: this._vsplitPanel.relativeSizes()[1]
       },
       leftArea: this._leftHandler.dehydrate(),
       rightArea: this._rightHandler.dehydrate(),
-      topArea: { simpleVisibility: !this._topHandlerHiddenByUser },
       relativeSizes: this._hsplitPanel.relativeSizes()
     };
     return layout;
   }
-
-  /**
-   * Toggle top header visibility in simple mode
-   *
-   * Note: Does nothing in multi-document mode
-   */
-  toggleTopInSimpleModeVisibility(): void {
-    if (this.mode === 'single-document') {
-      if (this._topHandler.panel.isVisible) {
-        this._topHandlerHiddenByUser = true;
-        this._topHandler.panel.hide();
-      } else {
-        this._topHandlerHiddenByUser = false;
-        this._topHandler.panel.show();
-
-        this._updateTitlePanelTitle();
-      }
-      this._onLayoutModified();
-    }
-  }
-
-  /**
-   * Toggle side tab bar visibility
-   *
-   * @param side Sidebar of interest
-   */
-  toggleSideTabBarVisibility(side: 'right' | 'left'): void {
-    if (side === 'right') {
-      if (this._rightHandler.isVisible) {
-        this._rightHandler.hide();
-      } else {
-        this._rightHandler.show();
-      }
-    } else {
-      if (this._leftHandler.isVisible) {
-        this._leftHandler.hide();
-      } else {
-        this._leftHandler.show();
-      }
-    }
-  }
-
   /**
    * Update the shell configuration.
    *
@@ -1368,14 +1053,14 @@
   /**
    * Returns the widgets for an application area.
    */
-  widgets(area?: ILabShell.Area): IterableIterator<Widget> {
+  widgets(area?: ILabShell.Area): IIterator<Widget> {
     switch (area ?? 'main') {
       case 'main':
         return this._dockPanel.widgets();
       case 'left':
-        return map(this._leftHandler.sideBar.titles, t => t.owner);
+        return iter(this._leftHandler.sideBar.titles.map(t => t.owner));
       case 'right':
-        return map(this._rightHandler.sideBar.titles, t => t.owner);
+        return iter(this._rightHandler.sideBar.titles.map(t => t.owner));
       case 'header':
         return this._headerPanel.children();
       case 'top':
@@ -1660,7 +1345,7 @@
       return null;
     }
 
-    const bars = Array.from(this._dockPanel.tabBars());
+    const bars = toArray(this._dockPanel.tabBars());
     const len = bars.length;
     const index = bars.indexOf(current);
 
@@ -1792,20 +1477,12 @@
   private _hsplitPanel: Private.RestorableSplitPanel;
   private _vsplitPanel: Private.RestorableSplitPanel;
   private _topHandler: Private.PanelHandler;
-  private _topHandlerHiddenByUser = false;
   private _menuHandler: Private.PanelHandler;
   private _skipLinkWidget: Private.SkipLinkWidget;
   private _titleHandler: Private.TitleHandler;
   private _bottomPanel: Panel;
-  private _idTypeMap = new Map<string, string>();
   private _mainOptionsCache = new Map<Widget, DocumentRegistry.IOpenOptions>();
   private _sideOptionsCache = new Map<Widget, DocumentRegistry.IOpenOptions>();
-  private _userLayout: {
-    'single-document': ILabShell.IUserLayout;
-    'multiple-document': ILabShell.IUserLayout;
-  };
-  private _delayedWidget = new Array<ILabShell.IDelayedWidget>();
-  private _translator: ITranslator;
   private _layoutRestorer: LayoutRestorer;
 }
 
@@ -1864,7 +1541,7 @@
     /**
      * Get the panel managed by the handler.
      */
-    get panel(): Panel {
+    get panel() {
       return this._panel;
     }
 
@@ -1945,13 +1622,6 @@
     }
 
     /**
-     * Whether the side bar is visible
-     */
-    get isVisible(): boolean {
-      return this._sideBar.isVisible;
-    }
-
-    /**
      * Get the tab bar managed by the handler.
      */
     get sideBar(): TabBar<Widget> {
@@ -1963,27 +1633,6 @@
      */
     get stackedPanel(): StackedPanel {
       return this._stackedPanel;
-    }
-
-    /**
-     * Signal fires when the stack panel or the sidebar changes
-     */
-    get updated(): ISignal<SideBarHandler, void> {
-      return this._updated;
-    }
-
-    /**
-     * Handles a movement to the handles of a widget
-     */
-    private _onHandleMoved(): void {
-      return this._refreshVisibility();
-    }
-
-    /**
-     * Handles changes to the expansion status of a widget
-     */
-    private _onExpansionToggle(sender: AccordionPanel, index: number): void {
-      return this._refreshVisibility();
     }
 
     /**
@@ -2044,24 +1693,17 @@
       // Store the parent id in the title dataset
       // in order to dispatch click events to the right widget.
       title.dataset = { id: widget.id };
+
       if (title.icon instanceof LabIcon) {
         // bind an appropriate style to the icon
         title.icon = title.icon.bindprops({
           stylesheet: 'sideBar'
         });
-      } else if (typeof title.icon === 'string' && title.icon != '') {
+      } else if (typeof title.icon === 'string' || !title.icon) {
         // add some classes to help with displaying css background imgs
         title.iconClass = classes(title.iconClass, 'jp-Icon', 'jp-Icon-20');
-      } else if (!title.icon && !title.label) {
-        // add a fallback icon if there is no title label nor icon
-        title.icon = tabIcon.bindprops({
-          stylesheet: 'sideBar'
-        });
-      }
-      // @ts-expect-error sometimes widget is an Accordion Panel
-      widget.content?.expansionToggled?.connect(this._onExpansionToggle, this);
-      // @ts-expect-error sometimes widget is a SidePanel
-      widget.content?.handleMoved?.connect(this._onHandleMoved, this);
+      }
+
       this._refreshVisibility();
     }
 
@@ -2070,29 +1712,9 @@
      */
     dehydrate(): ILabShell.ISideArea {
       const collapsed = this._sideBar.currentTitle === null;
-      const widgets = Array.from(this._stackedPanel.widgets);
+      const widgets = toArray(this._stackedPanel.widgets);
       const currentWidget = widgets[this._sideBar.currentIndex];
-      const widgetStates: {
-        [id: string]: {
-          sizes: number[] | null;
-          expansionStates: boolean[] | null;
-        };
-      } = {};
-      this._stackedPanel.widgets.forEach((w: SidePanel) => {
-        if (w.id && w.content instanceof SplitPanel) {
-          widgetStates[w.id] = {
-            sizes: w.content.relativeSizes() as number[],
-            expansionStates: w.content.widgets.map(wi => wi.isVisible)
-          };
-        }
-      });
-      return {
-        collapsed,
-        currentWidget,
-        visible: !this._isHiddenByUser,
-        widgets,
-        widgetStates
-      };
+      return { collapsed, currentWidget, widgets };
     }
 
     /**
@@ -2105,44 +1727,6 @@
       if (data.collapsed) {
         this.collapse();
       }
-      if (!data.visible) {
-        this.hide();
-      }
-      if (data.widgetStates) {
-        this._stackedPanel.widgets.forEach((w: SidePanel) => {
-          if (w.id && w.content instanceof SplitPanel) {
-            const state = data.widgetStates[w.id] ?? {};
-            w.content.widgets.forEach((wi, widx) => {
-              const expansion = (state.expansionStates ?? [])[widx];
-              if (
-                typeof expansion === 'boolean' &&
-                w.content instanceof AccordionPanel
-              ) {
-                expansion ? w.content.expand(widx) : w.content.collapse(widx);
-              }
-            });
-            if (state.sizes) {
-              w.content.setRelativeSizes(state.sizes);
-            }
-          }
-        });
-      }
-    }
-
-    /**
-     * Hide the side bar even if it contains widgets
-     */
-    hide(): void {
-      this._isHiddenByUser = true;
-      this._refreshVisibility();
-    }
-
-    /**
-     * Show the side bar if it contains widgets
-     */
-    show(): void {
-      this._isHiddenByUser = false;
-      this._refreshVisibility();
     }
 
     /**
@@ -2179,11 +1763,8 @@
      * Refresh the visibility of the side bar and stacked panel.
      */
     private _refreshVisibility(): void {
+      this._sideBar.setHidden(this._sideBar.titles.length === 0);
       this._stackedPanel.setHidden(this._sideBar.currentTitle === null);
-      this._sideBar.setHidden(
-        this._isHiddenByUser || this._sideBar.titles.length === 0
-      );
-      this._updated.emit();
     }
 
     /**
@@ -2231,12 +1812,10 @@
       this._refreshVisibility();
     }
 
-    private _isHiddenByUser = false;
     private _items = new Array<Private.IRankItem>();
     private _sideBar: TabBar<Widget>;
     private _stackedPanel: StackedPanel;
     private _lastCurrent: Widget | null;
-    private _updated: Signal<SideBarHandler, void> = new Signal(this);
   }
 
   export class SkipLinkWidget extends Widget {
@@ -2248,17 +1827,13 @@
       this.addClass('jp-skiplink');
       this.id = 'jp-skiplink';
       this._shell = shell;
-      this._createSkipLink('Skip to main panel', 'main');
+      this._createSkipLink('Skip to left side bar');
     }
 
     handleEvent(event: Event): void {
       switch (event.type) {
         case 'click':
-          if (event.target instanceof HTMLElement) {
-            this._shell.activateArea(
-              event.target?.dataset?.targetarea as ILabShell.Area
-            );
-          }
+          this._focusLeftSideBar();
           break;
       }
     }
@@ -2279,15 +1854,18 @@
       this.node.removeEventListener('click', this);
       super.onBeforeDetach(msg);
     }
+
+    private _focusLeftSideBar() {
+      this._shell.expandLeft();
+    }
     private _shell: ILabShell;
 
-    private _createSkipLink(skipLinkText: string, area: ILabShell.Area): void {
+    private _createSkipLink(skipLinkText: string): void {
       const skipLink = document.createElement('a');
       skipLink.href = '#';
-      skipLink.tabIndex = 0;
+      skipLink.tabIndex = 1;
       skipLink.text = skipLinkText;
       skipLink.className = 'skip-link';
-      skipLink.dataset['targetarea'] = area;
       this.node.appendChild(skipLink);
     }
   }