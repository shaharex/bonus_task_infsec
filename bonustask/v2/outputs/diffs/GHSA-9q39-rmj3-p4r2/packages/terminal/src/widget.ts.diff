--- packages\terminal\src\widget.ts (old)
+++ packages\terminal\src\widget.ts (new)
@@ -7,19 +7,12 @@
   nullTranslator,
   TranslationBundle
 } from '@jupyterlab/translation';
-import { PromiseDelegate } from '@lumino/coreutils';
 import { Platform } from '@lumino/domutils';
 import { Message, MessageLoop } from '@lumino/messaging';
 import { Widget } from '@lumino/widgets';
-import type {
-  ITerminalInitOnlyOptions,
-  ITerminalOptions,
-  Terminal as Xterm
-} from '@xterm/xterm';
-import type { CanvasAddon } from '@xterm/addon-canvas';
-import type { FitAddon } from '@xterm/addon-fit';
-import type { WebLinksAddon } from '@xterm/addon-web-links';
-import type { WebglAddon } from '@xterm/addon-webgl';
+import { Terminal as Xterm } from 'xterm';
+import { FitAddon } from 'xterm-addon-fit';
+import { WebLinksAddon } from 'xterm-addon-web-links';
 import { ITerminal } from '.';
 
 /**
@@ -68,68 +61,66 @@
 
     this._setThemeAttribute(theme);
 
-    // Buffer session message while waiting for the terminal
-    let buffer = '';
-    const bufferMessage = (
-      sender: TerminalNS.ITerminalConnection,
-      msg: TerminalNS.IMessage
-    ): void => {
-      switch (msg.type) {
-        case 'stdout':
-          if (msg.content) {
-            buffer += msg.content[0] as string;
-          }
-          break;
-        default:
-          break;
-      }
-    };
-    session.messageReceived.connect(bufferMessage);
+    // Create the xterm.
+    this._term = new Xterm(xtermOptions);
+    this._fitAddon = new FitAddon();
+    this._webLinksAddon = new WebLinksAddon();
+    this._term.loadAddon(this._fitAddon);
+    this._term.loadAddon(this._webLinksAddon);
+
+    this._initializeTerm();
+
+    this.id = `jp-Terminal-${Private.id++}`;
+    this.title.label = this._trans.__('Terminal');
+
+    session.messageReceived.connect(this._onMessage, this);
     session.disposed.connect(() => {
       if (this.getOption('closeOnExit')) {
         this.dispose();
       }
     }, this);
 
-    // Create the xterm.
-    Private.createTerminal(xtermOptions)
-      .then(([term, fitAddon]) => {
-        this._term = term;
-        this._fitAddon = fitAddon;
-        this._initializeTerm();
-
-        this.id = `jp-Terminal-${Private.id++}`;
-        this.title.label = this._trans.__('Terminal');
-        this._isReady = true;
-        this._ready.resolve();
-
-        if (buffer) {
-          this._term.write(buffer);
-        }
-        session.messageReceived.disconnect(bufferMessage);
-        session.messageReceived.connect(this._onMessage, this);
-
-        if (session.connectionStatus === 'connected') {
-          this._initialConnection();
-        } else {
-          session.connectionStatusChanged.connect(
-            this._initialConnection,
-            this
-          );
-        }
-        this.update();
-      })
-      .catch(reason => {
-        console.error('Failed to create a terminal.\n', reason);
-        this._ready.reject(reason);
+    if (session.connectionStatus === 'connected') {
+      this._initialConnection();
+    } else {
+      session.connectionStatusChanged.connect(this._initialConnection, this);
+    }
+  }
+
+  private _setThemeAttribute(theme: string | null | undefined) {
+    if (this.isDisposed) {
+      return;
+    }
+
+    this.node.setAttribute(
+      'data-term-theme',
+      theme ? theme.toLowerCase() : 'inherit'
+    );
+  }
+
+  private _initialConnection() {
+    if (this.isDisposed) {
+      return;
+    }
+
+    if (this.session.connectionStatus !== 'connected') {
+      return;
+    }
+
+    this.title.label = this._trans.__('Terminal %1', this.session.name);
+    this._setSessionSize();
+    if (this._options.initialCommand) {
+      this.session.send({
+        type: 'stdin',
+        content: [this._options.initialCommand + '\r']
       });
-  }
-
-  /**
-   * A promise that is fulfilled when the terminal is ready.
-   */
-  get ready(): Promise<void> {
-    return this._ready.promise;
+    }
+
+    // Only run this initial connection logic once.
+    this.session.connectionStatusChanged.disconnect(
+      this._initialConnection,
+      this
+    );
   }
 
   /**
@@ -163,32 +154,18 @@
     this._options[option] = value;
 
     switch (option) {
-      case 'fontFamily':
-        this._term.options.fontFamily = value as string | undefined;
-        break;
-      case 'fontSize':
-        this._term.options.fontSize = value as number | undefined;
-        break;
-      case 'lineHeight':
-        this._term.options.lineHeight = value as number | undefined;
-        break;
-      case 'screenReaderMode':
-        this._term.options.screenReaderMode = value as boolean | undefined;
-        break;
-      case 'scrollback':
-        this._term.options.scrollback = value as number | undefined;
+      case 'shutdownOnClose': // Do not transmit to XTerm
+      case 'closeOnExit': // Do not transmit to XTerm
         break;
       case 'theme':
-        this._term.options.theme = {
-          ...Private.getXTermTheme(value as ITerminal.Theme)
-        };
+        this._term.setOption(
+          'theme',
+          Private.getXTermTheme(value as ITerminal.Theme)
+        );
         this._setThemeAttribute(value as ITerminal.Theme);
         break;
-      case 'macOptionIsMeta':
-        this._term.options.macOptionIsMeta = value as boolean | undefined;
-        break;
       default:
-        // Do not transmit options not listed above to XTerm
+        this._term.setOption(option, value);
         break;
     }
 
@@ -207,9 +184,7 @@
         });
       }
     }
-    void this.ready.then(() => {
-      this._term.dispose();
-    });
+    this._term.dispose();
     super.dispose();
   }
 
@@ -220,7 +195,7 @@
    * Failure to reconnect to the session should be caught appropriately
    */
   async refresh(): Promise<void> {
-    if (!this.isDisposed && this._isReady) {
+    if (!this.isDisposed) {
       await this.session.reconnect();
       this._term.clear();
     }
@@ -230,7 +205,7 @@
    * Check if terminal has any text selected.
    */
   hasSelection(): boolean {
-    if (!this.isDisposed && this._isReady) {
+    if (!this.isDisposed) {
       return this._term.hasSelection();
     }
     return false;
@@ -240,7 +215,7 @@
    * Paste text into terminal.
    */
   paste(data: string): void {
-    if (!this.isDisposed && this._isReady) {
+    if (!this.isDisposed) {
       return this._term.paste(data);
     }
   }
@@ -249,7 +224,7 @@
    * Get selected text from terminal.
    */
   getSelection(): string | null {
-    if (!this.isDisposed && this._isReady) {
+    if (!this.isDisposed) {
       return this._term.getSelection();
     }
     return null;
@@ -302,7 +277,7 @@
    * A message handler invoked on an `'update-request'` message.
    */
   protected onUpdateRequest(msg: Message): void {
-    if (!this.isVisible || !this.isAttached || !this._isReady) {
+    if (!this.isVisible || !this.isAttached) {
       return;
     }
 
@@ -330,32 +305,7 @@
    * Handle `'activate-request'` messages.
    */
   protected onActivateRequest(msg: Message): void {
-    this._term?.focus();
-  }
-
-  private _initialConnection() {
-    if (this.isDisposed) {
-      return;
-    }
-
-    if (this.session.connectionStatus !== 'connected') {
-      return;
-    }
-
-    this.title.label = this._trans.__('Terminal %1', this.session.name);
-    this._setSessionSize();
-    if (this._options.initialCommand) {
-      this.session.send({
-        type: 'stdin',
-        content: [this._options.initialCommand + '\r']
-      });
-    }
-
-    // Only run this initial connection logic once.
-    this.session.connectionStatusChanged.disconnect(
-      this._initialConnection,
-      this
-    );
+    this._term.focus();
   }
 
   /**
@@ -452,27 +402,15 @@
     }
   }
 
-  private _setThemeAttribute(theme: string | null | undefined) {
-    if (this.isDisposed) {
-      return;
-    }
-
-    this.node.setAttribute(
-      'data-term-theme',
-      theme ? theme.toLowerCase() : 'inherit'
-    );
-  }
-
-  private _fitAddon: FitAddon;
+  private readonly _term: Xterm;
+  private readonly _fitAddon: FitAddon;
+  private readonly _webLinksAddon: WebLinksAddon;
+  private _trans: TranslationBundle;
   private _needsResize = true;
+  private _termOpened = false;
   private _offsetWidth = -1;
   private _offsetHeight = -1;
   private _options: ITerminal.IOptions;
-  private _isReady = false;
-  private _ready = new PromiseDelegate<void>();
-  private _term: Xterm;
-  private _termOpened = false;
-  private _trans: TranslationBundle;
 }
 
 /**
@@ -492,8 +430,7 @@
     background: '#fff',
     cursor: '#616161', // md-grey-700
     cursorAccent: '#F5F5F5', // md-grey-100
-    selectionBackground: 'rgba(97, 97, 97, 0.3)', // md-grey-700
-    selectionInactiveBackground: 'rgba(189, 189, 189, 0.3)' // md-grey-400
+    selection: 'rgba(97, 97, 97, 0.3)' // md-grey-700
   };
 
   /**
@@ -504,8 +441,7 @@
     background: '#000',
     cursor: '#fff',
     cursorAccent: '#000',
-    selectionBackground: 'rgba(255, 255, 255, 0.3)',
-    selectionInactiveBackground: 'rgba(238, 238, 238, 0.3)' // md-grey-200
+    selection: 'rgba(255, 255, 255, 0.3)'
   };
 
   /**
@@ -524,11 +460,8 @@
     cursorAccent: getComputedStyle(document.body)
       .getPropertyValue('--jp-ui-inverse-font-color0')
       .trim(),
-    selectionBackground: getComputedStyle(document.body)
-      .getPropertyValue('--jp-layout-color3')
-      .trim(),
-    selectionInactiveBackground: getComputedStyle(document.body)
-      .getPropertyValue('--jp-layout-color2')
+    selection: getComputedStyle(document.body)
+      .getPropertyValue('--jp-ui-font-color3')
       .trim()
   });
 
@@ -546,81 +479,3 @@
     }
   }
 }
-
-/**
- * Utility functions for creating a Terminal widget
- */
-namespace Private {
-  let supportWebGL: boolean = false;
-  let Xterm_: typeof Xterm;
-  let FitAddon_: typeof FitAddon;
-  let WeblinksAddon_: typeof WebLinksAddon;
-  let Renderer_: typeof CanvasAddon | typeof WebglAddon;
-
-  /**
-   * Detect if the browser supports WebGL or not.
-   *
-   * Reference: https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/By_example/Detect_WebGL
-   */
-  function hasWebGLContext(): boolean {
-    // Create canvas element. The canvas is not added to the
-    // document itself, so it is never displayed in the
-    // browser window.
-    const canvas = document.createElement('canvas');
-
-    // Get WebGLRenderingContext from canvas element.
-    const gl =
-      canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
-
-    // Report the result.
-    try {
-      return gl instanceof WebGLRenderingContext;
-    } catch (error) {
-      return false;
-    }
-  }
-
-  function addRenderer(term: Xterm): void {
-    let renderer = new Renderer_();
-    term.loadAddon(renderer);
-    if (supportWebGL) {
-      (renderer as WebglAddon).onContextLoss(event => {
-        console.debug('WebGL context lost - reinitialize Xtermjs renderer.');
-        renderer.dispose();
-        // If the Webgl context is lost, reinitialize the addon
-        addRenderer(term);
-      });
-    }
-  }
-
-  /**
-   * Create a xterm.js terminal asynchronously.
-   */
-  export async function createTerminal(
-    options: ITerminalOptions & ITerminalInitOnlyOptions
-  ): Promise<[Xterm, FitAddon]> {
-    if (!Xterm_) {
-      supportWebGL = hasWebGLContext();
-      const [xterm_, fitAddon_, renderer_, weblinksAddon_] = await Promise.all([
-        import('@xterm/xterm'),
-        import('@xterm/addon-fit'),
-        supportWebGL
-          ? import('@xterm/addon-webgl')
-          : import('@xterm/addon-canvas'),
-        import('@xterm/addon-web-links')
-      ]);
-      Xterm_ = xterm_.Terminal;
-      FitAddon_ = fitAddon_.FitAddon;
-      Renderer_ =
-        (renderer_ as any).WebglAddon ?? (renderer_ as any).CanvasAddon;
-      WeblinksAddon_ = weblinksAddon_.WebLinksAddon;
-    }
-
-    const term = new Xterm_(options);
-    addRenderer(term);
-    const fitAddon = new FitAddon_();
-    term.loadAddon(fitAddon);
-    term.loadAddon(new WeblinksAddon_());
-    return [term, fitAddon];
-  }
-}