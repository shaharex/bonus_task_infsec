--- packages\observables\src\undoablelist.ts (old)
+++ packages\observables\src\undoablelist.ts (new)
@@ -1,6 +1,7 @@
 // Copyright (c) Jupyter Development Team.
 // Distributed under the terms of the Modified BSD License.
 
+import { each } from '@lumino/algorithm';
 import { JSONValue } from '@lumino/coreutils';
 import { IObservableList, ObservableList } from './observablelist';
 
@@ -68,8 +69,7 @@
  */
 export class ObservableUndoableList<T>
   extends ObservableList<T>
-  implements IObservableUndoableList<T>
-{
+  implements IObservableUndoableList<T> {
   /**
    * Construct a new undoable observable list.
    */
@@ -194,21 +194,21 @@
     const serializer = this._serializer;
     switch (change.type) {
       case 'add':
-        for (let length = change.newValues.length; length > 0; length--) {
+        each(change.newValues, () => {
           this.remove(change.newIndex);
-        }
+        });
         break;
       case 'set':
         index = change.oldIndex;
-        for (const value of change.oldValues) {
+        each(change.oldValues, value => {
           this.set(index++, serializer.fromJSON(value));
-        }
+        });
         break;
       case 'remove':
         index = change.oldIndex;
-        for (const value of change.oldValues) {
+        each(change.oldValues, value => {
           this.insert(index++, serializer.fromJSON(value));
-        }
+        });
         break;
       case 'move':
         this.move(change.newIndex, change.oldIndex);
@@ -227,20 +227,20 @@
     switch (change.type) {
       case 'add':
         index = change.newIndex;
-        for (const value of change.newValues) {
+        each(change.newValues, value => {
           this.insert(index++, serializer.fromJSON(value));
-        }
+        });
         break;
       case 'set':
         index = change.newIndex;
-        for (const value of change.newValues) {
+        each(change.newValues, value => {
           this.set(change.newIndex++, serializer.fromJSON(value));
-        }
+        });
         break;
       case 'remove':
-        for (let length = change.oldValues.length; length > 0; length--) {
+        each(change.oldValues, () => {
           this.remove(change.oldIndex);
-        }
+        });
         break;
       case 'move':
         this.move(change.oldIndex, change.newIndex);
@@ -257,13 +257,13 @@
     change: IObservableList.IChangedArgs<T>
   ): IObservableList.IChangedArgs<JSONValue> {
     const oldValues: JSONValue[] = [];
-    for (const value of change.oldValues) {
+    each(change.oldValues, value => {
       oldValues.push(this._serializer.toJSON(value));
-    }
+    });
     const newValues: JSONValue[] = [];
-    for (const value of change.newValues) {
+    each(change.newValues, value => {
       newValues.push(this._serializer.toJSON(value));
-    }
+    });
     return {
       type: change.type,
       oldIndex: change.oldIndex,
@@ -289,8 +289,7 @@
    * A default, identity serializer.
    */
   export class IdentitySerializer<T extends JSONValue>
-    implements ISerializer<T>
-  {
+    implements ISerializer<T> {
     /**
      * Identity serialize.
      */