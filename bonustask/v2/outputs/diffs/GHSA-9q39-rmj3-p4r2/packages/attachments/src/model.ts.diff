--- packages\attachments\src\model.ts (old)
+++ packages\attachments\src\model.ts (new)
@@ -3,9 +3,11 @@
 
 import * as nbformat from '@jupyterlab/nbformat';
 import {
+  IModelDB,
   IObservableMap,
   IObservableValue,
-  ObservableMap
+  ObservableMap,
+  ObservableValue
 } from '@jupyterlab/observables';
 import {
   AttachmentModel,
@@ -104,6 +106,11 @@
      * If not given, a default factory will be used.
      */
     contentFactory?: IContentFactory;
+
+    /**
+     * An optional IModelDB to store the attachments model.
+     */
+    modelDB?: IModelDB;
   }
 
   /**
@@ -129,9 +136,9 @@
   /**
    * Construct a new observable outputs instance.
    */
-  constructor(options: IAttachmentsModel.IOptions) {
+  constructor(options: IAttachmentsModel.IOptions = {}) {
     this.contentFactory =
-      options.contentFactory ?? AttachmentsModel.defaultContentFactory;
+      options.contentFactory || AttachmentsModel.defaultContentFactory;
     if (options.values) {
       for (const key of Object.keys(options.values)) {
         if (options.values[key] !== undefined) {
@@ -140,6 +147,19 @@
       }
     }
     this._map.changed.connect(this._onMapChanged, this);
+
+    // If we are given a IModelDB, keep an up-to-date
+    // serialized copy of the AttachmentsModel in it.
+    if (options.modelDB) {
+      this._modelDB = options.modelDB;
+      this._serialized = this._modelDB.createValue('attachments');
+      if (this._serialized.get()) {
+        this.fromJSON(this._serialized.get() as nbformat.IAttachments);
+      } else {
+        this._serialized.set(this.toJSON());
+      }
+      this._serialized.changed.connect(this._onSerializedChanged, this);
+    }
   }
 
   /**
@@ -240,7 +260,7 @@
    * #### Notes
    * This will clear any existing data.
    */
-  fromJSON(values: nbformat.IAttachments): void {
+  fromJSON(values: nbformat.IAttachments) {
     this.clear();
     Object.keys(values).forEach(key => {
       if (values[key] !== undefined) {
@@ -287,6 +307,21 @@
   }
 
   /**
+   * If the serialized version of the outputs have changed due to a remote
+   * action, then update the model accordingly.
+   */
+  private _onSerializedChanged(
+    sender: IObservableValue,
+    args: ObservableValue.IChangedArgs
+  ) {
+    if (!this._changeGuard) {
+      this._changeGuard = true;
+      this.fromJSON(args.newValue as nbformat.IAttachments);
+      this._changeGuard = false;
+    }
+  }
+
+  /**
    * Handle a change to an item.
    */
   private _onGenericChange(): void {
@@ -297,6 +332,7 @@
   private _isDisposed = false;
   private _stateChanged = new Signal<IAttachmentsModel, void>(this);
   private _changed = new Signal<this, IAttachmentsModel.ChangedArgs>(this);
+  private _modelDB: IModelDB | null = null;
   private _serialized: IObservableValue | null = null;
   private _changeGuard = false;
 }