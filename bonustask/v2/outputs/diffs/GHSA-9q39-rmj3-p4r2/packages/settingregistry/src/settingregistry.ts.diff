--- packages\settingregistry\src\settingregistry.ts (old)
+++ packages\settingregistry\src\settingregistry.ts (new)
@@ -16,7 +16,7 @@
 } from '@lumino/coreutils';
 import { DisposableDelegate, IDisposable } from '@lumino/disposable';
 import { ISignal, Signal } from '@lumino/signaling';
-import Ajv, { Options as AjvOptions } from 'ajv';
+import Ajv from 'ajv';
 import * as json5 from 'json5';
 import SCHEMA from './plugin-schema.json';
 import { ISettingRegistry } from './tokens';
@@ -26,17 +26,12 @@
  */
 const copy = JSONExt.deepCopy;
 
-/** Default arguments for Ajv instances.
- *
- * https://ajv.js.org/options.html
+/**
+ * The default number of milliseconds before a `load()` call to the registry
+ * will wait before timing out if it requires a transformation that has not been
+ * registered.
  */
-const AJV_DEFAULT_OPTIONS: Partial<AjvOptions> = {
-  /**
-   * @todo the implications of enabling strict mode are beyond the scope of
-   *       the initial PR
-   */
-  strict: false
-};
+const DEFAULT_TRANSFORM_TIMEOUT = 1000;
 
 /**
  * The ASCII record separator character.
@@ -56,7 +51,7 @@
    * @param populate - Whether plugin data should be populated, defaults to
    * `true`.
    *
-   * @returns A list of errors if either the schema or data fail to validate or
+   * @return A list of errors if either the schema or data fail to validate or
    * `null` if there are no errors.
    */
   validateData(
@@ -74,14 +69,19 @@
    */
   export interface IError {
     /**
+     * The path in the data where the error occurred.
+     */
+    dataPath: string;
+
+    /**
      * The keyword whose validation failed.
      */
-    keyword: string | string[];
+    keyword: string;
 
     /**
      * The error message.
      */
-    message?: string;
+    message: string;
 
     /**
      * Optional parameter metadata that might be included in an error.
@@ -92,31 +92,6 @@
      * The path in the schema where the error occurred.
      */
     schemaPath: string;
-
-    /**
-     * @todo handle new fields from ajv8
-     **/
-    schema?: unknown;
-
-    /**
-     * @todo handle new fields from ajv8
-     **/
-    instancePath: string;
-
-    /**
-     * @todo handle new fields from ajv8
-     **/
-    propertyName?: string;
-
-    /**
-     * @todo handle new fields from ajv8
-     **/
-    data?: unknown;
-
-    /**
-     * @todo handle new fields from ajv8
-     **/
-    parentSchema?: unknown;
   }
 }
 
@@ -141,7 +116,7 @@
    * @param populate - Whether plugin data should be populated, defaults to
    * `true`.
    *
-   * @returns A list of errors if either the schema or data fail to validate or
+   * @return A list of errors if either the schema or data fail to validate or
    * `null` if there are no errors.
    */
   validateData(
@@ -159,7 +134,7 @@
           `Setting registry schemas' root-level type must be ` +
           `'object', rejecting type: ${plugin.schema.type}`;
 
-        return [{ instancePath: 'type', keyword, schemaPath: '', message }];
+        return [{ dataPath: 'type', keyword, schemaPath: '', message }];
       }
 
       const errors = this._addSchema(plugin.id, plugin.schema);
@@ -175,7 +150,7 @@
       if (error instanceof SyntaxError) {
         return [
           {
-            instancePath: '',
+            dataPath: '',
             keyword: 'syntax',
             schemaPath: '',
             message: error.message
@@ -188,7 +163,7 @@
 
       return [
         {
-          instancePath: '',
+          dataPath: '',
           keyword: 'parse',
           schemaPath: '',
           message: `${description} (line ${line} column ${column})`
@@ -221,7 +196,7 @@
    *
    * @param schema - The schema being added.
    *
-   * @returns A list of errors if the schema fails to validate or `null` if there
+   * @return A list of errors if the schema fails to validate or `null` if there
    * are no errors.
    *
    * #### Notes
@@ -256,11 +231,8 @@
     return null;
   }
 
-  private _composer: Ajv = new Ajv({
-    useDefaults: true,
-    ...AJV_DEFAULT_OPTIONS
-  });
-  private _validator: Ajv = new Ajv({ ...AJV_DEFAULT_OPTIONS });
+  private _composer = new Ajv({ useDefaults: true });
+  private _validator = new Ajv();
 }
 
 /**
@@ -273,16 +245,10 @@
   constructor(options: SettingRegistry.IOptions) {
     this.connector = options.connector;
     this.validator = options.validator || new DefaultSchemaValidator();
-
-    // Plugins with transformation may not be loaded if the transformation function is
-    // not yet available. To avoid fetching again the associated data when the transformation
-    // function is available, the plugin data is kept in cache.
+    this._timeout = options.timeout || DEFAULT_TRANSFORM_TIMEOUT;
+
+    // Preload with any available data at instantiation-time.
     if (options.plugins) {
-      options.plugins
-        .filter(plugin => plugin.schema['jupyter.lab.transform'])
-        .forEach(plugin => this._unloadedPlugins.set(plugin.id, plugin));
-
-      // Preload with any available data at instantiation-time.
       this._ready = this._preload(options.plugins);
     }
   }
@@ -355,15 +321,10 @@
    *
    * @param plugin - The name of the plugin whose settings are being loaded.
    *
-   * @param forceTransform - An optional parameter to force replay the transforms methods.
-   *
    * @returns A promise that resolves with a plugin settings object or rejects
    * if the plugin is not found.
    */
-  async load(
-    plugin: string,
-    forceTransform: boolean = false
-  ): Promise<ISettingRegistry.ISettings> {
+  async load(plugin: string): Promise<ISettingRegistry.ISettings> {
     // Wait for data preload before allowing normal operation.
     await this._ready;
 
@@ -372,26 +333,7 @@
 
     // If the plugin exists, resolve.
     if (plugin in plugins) {
-      // Force replaying the transform function if expected.
-      if (forceTransform) {
-        // Empty the composite and user data before replaying the transforms.
-        plugins[plugin].data = { composite: {}, user: {} };
-        await this._load(await this._transform('fetch', plugins[plugin]));
-        this._pluginChanged.emit(plugin);
-      }
       return new Settings({ plugin: plugins[plugin], registry });
-    }
-
-    // If the plugin is not loaded but has already been fetched.
-    if (this._unloadedPlugins.has(plugin) && plugin in this._transformers) {
-      await this._load(
-        await this._transform('fetch', this._unloadedPlugins.get(plugin)!)
-      );
-      if (plugin in plugins) {
-        this._pluginChanged.emit(plugin);
-        this._unloadedPlugins.delete(plugin);
-        return new Settings({ plugin: plugins[plugin], registry });
-      }
     }
 
     // If the plugin needs to be loaded from the data connector, fetch.
@@ -417,7 +359,7 @@
     if (fetched === undefined) {
       throw [
         {
-          instancePath: '',
+          dataPath: '',
           keyword: 'id',
           message: `Could not fetch settings for ${plugin}.`,
           schemaPath: ''
@@ -572,12 +514,10 @@
       const output = [`Validating ${plugin} failed:`];
 
       (errors as ISchemaValidator.IError[]).forEach((error, index) => {
-        const { instancePath, schemaPath, keyword, message } = error;
-
-        if (instancePath || schemaPath) {
-          output.push(
-            `${index} - schema @ ${schemaPath}, data @ ${instancePath}`
-          );
+        const { dataPath, schemaPath, keyword, message } = error;
+
+        if (dataPath || schemaPath) {
+          output.push(`${index} - schema @ ${schemaPath}, data @ ${dataPath}`);
         }
         output.push(`{${keyword}} ${message}`);
       });
@@ -597,8 +537,8 @@
           // Apply a transformation to the plugin if necessary.
           await this._load(await this._transform('fetch', plugin));
         } catch (errors) {
-          /* Ignore silently if no transformers. */
-          if (errors[0]?.keyword !== 'unset') {
+          /* Ignore preload timeout errors silently. */
+          if (errors[0]?.keyword !== 'timeout') {
             console.warn('Ignored setting registry preload errors.', errors);
           }
         }
@@ -629,7 +569,7 @@
     if (fetched === undefined) {
       throw [
         {
-          instancePath: '',
+          dataPath: '',
           keyword: 'id',
           message: `Could not fetch settings for ${plugin}.`,
           schemaPath: ''
@@ -645,10 +585,13 @@
    */
   private async _transform(
     phase: ISettingRegistry.IPlugin.Phase,
-    plugin: ISettingRegistry.IPlugin
+    plugin: ISettingRegistry.IPlugin,
+    started = new Date().getTime()
   ): Promise<ISettingRegistry.IPlugin> {
+    const elapsed = new Date().getTime() - started;
     const id = plugin.id;
     const transformers = this._transformers;
+    const timeout = this._timeout;
 
     if (!plugin.schema['jupyter.lab.transform']) {
       return plugin;
@@ -660,21 +603,32 @@
       if (transformed.id !== id) {
         throw [
           {
-            instancePath: '',
+            dataPath: '',
             keyword: 'id',
             message: 'Plugin transformations cannot change plugin IDs.',
             schemaPath: ''
           } as ISchemaValidator.IError
         ];
       }
+
       return transformed;
     }
-    // If the plugin has no transformers, throw an error and bail.
+
+    // If the timeout has not been exceeded, stall and try again in 250ms.
+    if (elapsed < timeout) {
+      await new Promise<void>(resolve => {
+        setTimeout(() => {
+          resolve();
+        }, 250);
+      });
+      return this._transform(phase, plugin, started);
+    }
+
     throw [
       {
-        instancePath: '',
-        keyword: 'unset',
-        message: `${plugin.id} has no transformers yet.`,
+        dataPath: '',
+        keyword: 'timeout',
+        message: `Transforming ${plugin.id} timed out.`,
         schemaPath: ''
       } as ISchemaValidator.IError
     ];
@@ -697,29 +651,74 @@
 
   private _pluginChanged = new Signal<this, string>(this);
   private _ready = Promise.resolve();
+  private _timeout: number;
   private _transformers: {
     [plugin: string]: {
       [phase in ISettingRegistry.IPlugin.Phase]: ISettingRegistry.IPlugin.Transform;
     };
   } = Object.create(null);
-  private _unloadedPlugins = new Map<string, ISettingRegistry.IPlugin>();
 }
 
 /**
- * Base settings specified by a JSON schema.
+ * A manager for a specific plugin's settings.
  */
-export class BaseSettings<
-  T extends ISettingRegistry.IProperty = ISettingRegistry.IProperty
-> {
-  constructor(options: { schema: T }) {
-    this._schema = options.schema;
+export class Settings implements ISettingRegistry.ISettings {
+  /**
+   * Instantiate a new plugin settings manager.
+   */
+  constructor(options: Settings.IOptions) {
+    this.id = options.plugin.id;
+    this.registry = options.registry;
+    this.registry.pluginChanged.connect(this._onPluginChanged, this);
+  }
+
+  /**
+   * The plugin name.
+   */
+  readonly id: string;
+
+  /**
+   * The setting registry instance used as a back-end for these settings.
+   */
+  readonly registry: ISettingRegistry;
+
+  /**
+   * A signal that emits when the plugin's settings have changed.
+   */
+  get changed(): ISignal<this, void> {
+    return this._changed;
+  }
+
+  /**
+   * The composite of user settings and extension defaults.
+   */
+  get composite(): ReadonlyPartialJSONObject {
+    return this.plugin.data.composite;
+  }
+
+  /**
+   * Test whether the plugin settings manager disposed.
+   */
+  get isDisposed(): boolean {
+    return this._isDisposed;
+  }
+
+  get plugin(): ISettingRegistry.IPlugin {
+    return this.registry.plugins[this.id]!;
   }
 
   /**
    * The plugin's schema.
    */
-  get schema(): T {
-    return this._schema;
+  get schema(): ISettingRegistry.ISchema {
+    return this.plugin.schema;
+  }
+
+  /**
+   * The plugin settings raw text value.
+   */
+  get raw(): string {
+    return this.plugin.raw;
   }
 
   /**
@@ -744,6 +743,31 @@
     return true;
   }
 
+  get isModified(): boolean {
+    return !this.isDefault(this.user);
+  }
+
+  /**
+   * The user settings.
+   */
+  get user(): ReadonlyPartialJSONObject {
+    return this.plugin.data.user;
+  }
+
+  /**
+   * The published version of the NPM package containing these settings.
+   */
+  get version(): string {
+    return this.plugin.version;
+  }
+
+  /**
+   * Return the defaults in a commented JSON format.
+   */
+  annotatedDefaults(): string {
+    return Private.annotatedDefaults(this.schema, this.id);
+  }
+
   /**
    * Calculate the default value of a setting by iterating through the schema.
    *
@@ -753,96 +777,6 @@
    */
   default(key?: string): PartialJSONValue | undefined {
     return Private.reifyDefault(this.schema, key);
-  }
-
-  private _schema: T;
-}
-
-/**
- * A manager for a specific plugin's settings.
- */
-export class Settings
-  extends BaseSettings<ISettingRegistry.ISchema>
-  implements ISettingRegistry.ISettings
-{
-  /**
-   * Instantiate a new plugin settings manager.
-   */
-  constructor(options: Settings.IOptions) {
-    super({ schema: options.plugin.schema });
-    this.id = options.plugin.id;
-    this.registry = options.registry;
-    this.registry.pluginChanged.connect(this._onPluginChanged, this);
-  }
-
-  /**
-   * The plugin name.
-   */
-  readonly id: string;
-
-  /**
-   * The setting registry instance used as a back-end for these settings.
-   */
-  readonly registry: ISettingRegistry;
-
-  /**
-   * A signal that emits when the plugin's settings have changed.
-   */
-  get changed(): ISignal<this, void> {
-    return this._changed;
-  }
-
-  /**
-   * The composite of user settings and extension defaults.
-   */
-  get composite(): ReadonlyPartialJSONObject {
-    return this.plugin.data.composite;
-  }
-
-  /**
-   * Test whether the plugin settings manager disposed.
-   */
-  get isDisposed(): boolean {
-    return this._isDisposed;
-  }
-
-  get plugin(): ISettingRegistry.IPlugin {
-    return this.registry.plugins[this.id]!;
-  }
-
-  /**
-   * The plugin settings raw text value.
-   */
-  get raw(): string {
-    return this.plugin.raw;
-  }
-
-  /**
-   * Whether the settings have been modified by the user or not.
-   */
-  get isModified(): boolean {
-    return !this.isDefault(this.user);
-  }
-
-  /**
-   * The user settings.
-   */
-  get user(): ReadonlyPartialJSONObject {
-    return this.plugin.data.user;
-  }
-
-  /**
-   * The published version of the NPM package containing these settings.
-   */
-  get version(): string {
-    return this.plugin.version;
-  }
-
-  /**
-   * Return the defaults in a commented JSON format.
-   */
-  annotatedDefaults(): string {
-    return Private.annotatedDefaults(this.schema, this.id);
   }
 
   /**
@@ -868,7 +802,9 @@
    * This method returns synchronously because it uses a cached copy of the
    * plugin settings that is synchronized with the registry.
    */
-  get(key: string): {
+  get(
+    key: string
+  ): {
     composite: ReadonlyPartialJSONValue | undefined;
     user: ReadonlyPartialJSONValue | undefined;
   } {
@@ -1160,8 +1096,9 @@
 
     // If a user shortcut collides with another user shortcut warn and filter.
     user = user.filter(shortcut => {
-      const keys =
-        CommandRegistry.normalizeKeys(shortcut).join(RECORD_SEPARATOR);
+      const keys = CommandRegistry.normalizeKeys(shortcut).join(
+        RECORD_SEPARATOR
+      );
       if (!keys) {
         console.warn(
           'Skipping this shortcut because there are no actionable keys on this platform',
@@ -1195,8 +1132,9 @@
       ...defaults.filter(s => !!s.disabled),
       ...defaults.filter(s => !s.disabled)
     ].filter(shortcut => {
-      const keys =
-        CommandRegistry.normalizeKeys(shortcut).join(RECORD_SEPARATOR);
+      const keys = CommandRegistry.normalizeKeys(shortcut).join(
+        RECORD_SEPARATOR
+      );
 
       if (!keys) {
         return false;
@@ -1224,7 +1162,7 @@
     });
 
     // Return all the shortcuts that should be registered
-    return Private.upgradeShortcuts(
+    return (
       user
         .concat(defaults)
         .filter(shortcut => !shortcut.disabled)
@@ -1437,25 +1375,13 @@
 
   /**
    * Create a fully extrapolated default value for a root key in a schema.
-   *
-   * @todo This function would ideally reuse `getDefaultFormState` from rjsf
-   * with appropriate`defaultFormStateBehavior` setting, as currently
-   * these two implementations duplicate each other.
-   *
-   * Note: absence of a property may mean something else than the default.
    */
   export function reifyDefault(
     schema: ISettingRegistry.IProperty,
-    root?: string,
-    definitions?: PartialJSONObject,
-    required?: boolean
+    root?: string
   ): PartialJSONValue | undefined {
-    definitions = definitions ?? (schema.definitions as PartialJSONObject);
+    const definitions = schema.definitions as PartialJSONObject;
     // If the property is at the root level, traverse its schema.
-    required = root
-      ? schema.required instanceof Array &&
-        schema.required?.includes(root as any)
-      : required;
     schema = (root ? schema.properties?.[root] : schema) || {};
 
     if (schema.type === 'object') {
@@ -1465,26 +1391,13 @@
       // Iterate through and populate each child property.
       const props = schema.properties || {};
       for (const property in props) {
-        result[property] = reifyDefault(
-          props[property],
-          undefined,
-          definitions,
-          schema.required instanceof Array &&
-            schema.required?.includes(property as any)
-        );
+        result[property] = reifyDefault(props[property]);
       }
 
       return result;
     } else if (schema.type === 'array') {
-      const defaultDefined = typeof schema.default !== 'undefined';
-      const shouldPopulateDefaultArray = defaultDefined || required;
-      if (!shouldPopulateDefaultArray) {
-        return undefined;
-      }
       // Make a copy of the default value to populate.
-      const result = defaultDefined
-        ? JSONExt.deepCopy(schema.default as PartialJSONArray)
-        : [];
+      const result = JSONExt.deepCopy(schema.default as PartialJSONArray);
 
       // Items defines the properties of each item in the array
       let props = (schema.items as PartialJSONObject) || {};
@@ -1498,23 +1411,14 @@
       }
       // Iterate through the items in the array and fill in defaults
       for (const item in result) {
-        if (props.type === 'object') {
-          // Use the values that are hard-coded in the default array over the defaults for each field.
-          const reified =
-            (reifyDefault(
-              props,
-              undefined,
-              definitions
-            ) as PartialJSONObject) ??
-            result[item] ??
-            {};
-          for (const prop in reified) {
-            if ((result[item] as PartialJSONObject)?.[prop]) {
-              reified[prop] = (result[item] as PartialJSONObject)[prop];
-            }
+        // Use the values that are hard-coded in the default array over the defaults for each field.
+        const reified = (reifyDefault(props) as PartialJSONObject) || {};
+        for (const prop in reified) {
+          if ((result[item] as PartialJSONObject)?.[prop]) {
+            reified[prop] = (result[item] as PartialJSONObject)[prop];
           }
-          result[item] = reified;
         }
+        result[item] = reified;
       }
 
       return result;
@@ -1522,75 +1426,4 @@
       return schema.default;
     }
   }
-
-  /**
-   * Selectors which were previously warned about.
-   */
-  const selectorsAlreadyWarnedAbout = new Set<string>();
-
-  /**
-   * Upgrade shortcuts to ensure no breaking changes between minor versions.
-   */
-  export function upgradeShortcuts(
-    shortcuts: ISettingRegistry.IShortcut[]
-  ): ISettingRegistry.IShortcut[] {
-    const selectorDeprecationWarnings = new Set();
-    const changes = [
-      {
-        old: '.jp-Notebook:focus.jp-mod-commandMode',
-        new: '.jp-Notebook.jp-mod-commandMode:not(.jp-mod-readWrite) :focus',
-        versionDeprecated: 'JupyterLab 4.1'
-      },
-      {
-        old: '.jp-Notebook.jp-mod-commandMode :focus:not(:read-write)',
-        new: '.jp-Notebook.jp-mod-commandMode:not(.jp-mod-readWrite) :focus',
-        versionDeprecated: 'JupyterLab 4.1.1'
-      },
-      {
-        old: '.jp-Notebook:focus',
-        new: '.jp-Notebook.jp-mod-commandMode:not(.jp-mod-readWrite) :focus',
-        versionDeprecated: 'JupyterLab 4.1'
-      },
-      {
-        old: '[data-jp-traversable]:focus',
-        new: '.jp-Notebook.jp-mod-commandMode:not(.jp-mod-readWrite) :focus',
-        versionDeprecated: 'JupyterLab 4.1'
-      },
-      {
-        old: '[data-jp-kernel-user]:focus',
-        new: '[data-jp-kernel-user]:not(.jp-mod-readWrite) :focus:not(:read-write)',
-        versionDeprecated: 'JupyterLab 4.1'
-      },
-      {
-        old: '[data-jp-kernel-user] :focus:not(:read-write)',
-        new: '[data-jp-kernel-user]:not(.jp-mod-readWrite) :focus:not(:read-write)',
-        versionDeprecated: 'JupyterLab 4.1.1'
-      }
-    ];
-    const upgraded = shortcuts.map(shortcut => {
-      const oldSelector = shortcut.selector;
-      let newSelector = oldSelector;
-      for (const change of changes) {
-        if (oldSelector.includes(change.old)) {
-          newSelector = oldSelector.replace(change.old, change.new);
-          if (!selectorsAlreadyWarnedAbout.has(oldSelector)) {
-            selectorDeprecationWarnings.add(
-              `"${change.old}" was replaced with "${change.new}" in ${change.versionDeprecated} (present in "${oldSelector}")`
-            );
-            selectorsAlreadyWarnedAbout.add(oldSelector);
-          }
-        }
-      }
-      shortcut.selector = newSelector;
-      return shortcut;
-    });
-    if (selectorDeprecationWarnings.size > 0) {
-      console.warn(
-        'Deprecated shortcut selectors: ' +
-          [...selectorDeprecationWarnings].join('\n') +
-          '\n\nThe selectors will be substituted transparently this time, but need to be updated at source before next major release.'
-      );
-    }
-    return upgraded;
-  }
 }