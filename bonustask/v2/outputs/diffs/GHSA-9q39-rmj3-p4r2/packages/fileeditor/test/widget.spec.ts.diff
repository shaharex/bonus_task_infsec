--- packages\fileeditor\test\widget.spec.ts (old)
+++ packages\fileeditor\test\widget.spec.ts (new)
@@ -3,8 +3,7 @@
 
 import {
   CodeMirrorEditorFactory,
-  CodeMirrorMimeTypeService,
-  EditorLanguageRegistry
+  CodeMirrorMimeTypeService
 } from '@jupyterlab/codemirror';
 import {
   Context,
@@ -14,12 +13,12 @@
 } from '@jupyterlab/docregistry';
 import {
   FileEditor,
-  FileEditorFactory,
-  FileEditorWidget
+  FileEditorCodeWrapper,
+  FileEditorFactory
 } from '@jupyterlab/fileeditor';
 import { ServiceManager } from '@jupyterlab/services';
-import { framePromise } from '@jupyterlab/testing';
-import { ServiceManagerMock } from '@jupyterlab/services/lib/testutils';
+import { framePromise } from '@jupyterlab/testutils';
+import * as Mock from '@jupyterlab/testutils/lib/mock';
 import { UUID } from '@lumino/coreutils';
 import { Message, MessageLoop } from '@lumino/messaging';
 import { Widget } from '@lumino/widgets';
@@ -54,22 +53,50 @@
 describe('fileeditorcodewrapper', () => {
   const factoryService = new CodeMirrorEditorFactory();
   const modelFactory = new TextModelFactory();
-  const languages = (() => {
-    const registry = new EditorLanguageRegistry();
-    EditorLanguageRegistry.getDefaultLanguages()
-      .filter(language => ['Julia', 'Python'].includes(language.name))
-      .forEach(language => {
-        registry.addLanguage(language);
-      });
-    return registry;
-  })();
-  const mimeTypeService = new CodeMirrorMimeTypeService(languages);
+  const mimeTypeService = new CodeMirrorMimeTypeService();
   let context: Context<DocumentRegistry.ICodeModel>;
   let manager: ServiceManager.IManager;
 
   beforeAll(() => {
-    manager = new ServiceManagerMock();
+    manager = new Mock.ServiceManagerMock();
     return manager.ready;
+  });
+
+  describe('FileEditorCodeWrapper', () => {
+    let widget: FileEditorCodeWrapper;
+
+    beforeEach(() => {
+      const path = UUID.uuid4() + '.py';
+      context = new Context({ manager, factory: modelFactory, path });
+      widget = new FileEditorCodeWrapper({
+        factory: options => factoryService.newDocumentEditor(options),
+        mimeTypeService,
+        context
+      });
+    });
+
+    afterEach(() => {
+      widget.dispose();
+    });
+
+    describe('#constructor()', () => {
+      it('should create an editor wrapper widget', () => {
+        expect(widget).toBeInstanceOf(FileEditorCodeWrapper);
+      });
+
+      it('should update the editor text when the model changes', async () => {
+        await context.initialize(true);
+        await context.ready;
+        widget.context.model.fromString('foo');
+        expect(widget.editor.model.value.text).toBe('foo');
+      });
+    });
+
+    describe('#context', () => {
+      it('should be the context used by the widget', () => {
+        expect(widget.context).toBe(context);
+      });
+    });
   });
 
   describe('FileEditor', () => {
@@ -98,7 +125,7 @@
         await context.initialize(true);
         await context.ready;
         widget.context.model.fromString('foo');
-        expect(widget.editor.model.sharedModel.getSource()).toBe('foo');
+        expect(widget.editor.model.value.text).toBe('foo');
       });
 
       it('should set the mime type for the path', () => {
@@ -171,62 +198,6 @@
         expect(widget.methods).toContain('onActivateRequest');
         await framePromise();
         expect(widget.editor.hasFocus()).toBe(true);
-      });
-    });
-
-    describe('#ready', () => {
-      it('should resolve after initialization', async () => {
-        await context.initialize(true);
-        return expect(widget.ready).resolves.toBe(undefined);
-      });
-    });
-  });
-
-  describe('FileEditorWidget', () => {
-    let documentWidget: FileEditorWidget;
-
-    beforeEach(() => {
-      const path = UUID.uuid4() + '.py';
-      context = new Context({ manager, factory: modelFactory, path });
-      context.model.sharedModel.setSource('a\nb\nc');
-      const content = new FileEditor({
-        factory: options => factoryService.newDocumentEditor(options),
-        mimeTypeService,
-        context
-      });
-      documentWidget = new FileEditorWidget({ content, context });
-    });
-
-    afterEach(() => {
-      documentWidget.dispose();
-    });
-
-    describe('#setFragment', () => {
-      it('should set fragment for a single line', async () => {
-        await context.initialize(true);
-        await context.ready;
-        const widget = documentWidget.content;
-
-        await documentWidget.setFragment('#line=2');
-        let cursor = widget.editor.getCursorPosition();
-        expect(cursor.line).toBe(2);
-
-        await documentWidget.setFragment('#line=0');
-        cursor = widget.editor.getCursorPosition();
-        expect(cursor.line).toBe(0);
-      });
-      it('should set fragment for a range', async () => {
-        await context.initialize(true);
-        await context.ready;
-        const widget = documentWidget.content;
-
-        await documentWidget.setFragment('#line=,3');
-        let cursor = widget.editor.getCursorPosition();
-        expect(cursor.line).toBe(0);
-
-        await documentWidget.setFragment('#line=2,3');
-        cursor = widget.editor.getCursorPosition();
-        expect(cursor.line).toBe(2);
       });
     });
   });