--- packages\fileeditor\src\widget.ts (old)
+++ packages\fileeditor\src\widget.ts (new)
@@ -29,6 +29,110 @@
 const UNDOER = 'jpUndoer';
 
 /**
+ * A code editor wrapper for the file editor.
+ *
+ * @deprecated since v3.4
+ * Note: This class will be removed in v4.0.
+ * From now on, you can directly use the class
+ * `CodeEditorWrapper` instead on `FileEditorCodeWrapper`.
+ */
+export class FileEditorCodeWrapper extends CodeEditorWrapper {
+  /**
+   * Construct a new editor widget.
+   */
+  constructor(options: FileEditor.IOptions) {
+    super({
+      factory: options.factory,
+      model: options.context.model
+    });
+
+    const context = (this._context = options.context);
+
+    // TODO: move this to the FileEditor when removing the
+    // `FileEditorCodeWrapper`
+    this.addClass('jp-FileEditorCodeWrapper');
+    this.node.dataset[CODE_RUNNER] = 'true';
+    this.node.dataset[UNDOER] = 'true';
+
+    void context.ready.then(() => {
+      this._onContextReady();
+    });
+
+    if (context.model.modelDB.isCollaborative) {
+      const modelDB = context.model.modelDB;
+      void modelDB.connected.then(() => {
+        const collaborators = modelDB.collaborators;
+        if (!collaborators) {
+          return;
+        }
+
+        // Setup the selection style for collaborators
+        const localCollaborator = collaborators.localCollaborator;
+        this.editor.uuid = localCollaborator.sessionId;
+
+        this.editor.selectionStyle = {
+          ...CodeEditor.defaultSelectionStyle,
+          color: localCollaborator.color
+        };
+
+        collaborators.changed.connect(this._onCollaboratorsChanged, this);
+        // Trigger an initial onCollaboratorsChanged event.
+        this._onCollaboratorsChanged();
+      });
+    }
+  }
+
+  /**
+   * Get the context for the editor widget.
+   */
+  get context(): DocumentRegistry.Context {
+    return this._context;
+  }
+
+  /**
+   * A promise that resolves when the file editor is ready.
+   */
+  get ready(): Promise<void> {
+    return this._ready.promise;
+  }
+
+  /**
+   * Handle actions that should be taken when the context is ready.
+   */
+  private _onContextReady(): void {
+    if (this.isDisposed) {
+      return;
+    }
+
+    // Prevent the initial loading from disk from being in the editor history.
+    this.editor.clearHistory();
+    // Resolve the ready promise.
+    this._ready.resolve(undefined);
+  }
+
+  /**
+   * Handle a change to the collaborators on the model
+   * by updating UI elements associated with them.
+   */
+  private _onCollaboratorsChanged(): void {
+    // If there are selections corresponding to non-collaborators,
+    // they are stale and should be removed.
+    const collaborators = this._context.model.modelDB.collaborators;
+    if (!collaborators) {
+      return;
+    }
+    for (const key of this.editor.model.selections.keys()) {
+      if (!collaborators.has(key)) {
+        this.editor.model.selections.delete(key);
+      }
+    }
+  }
+
+  protected _context: DocumentRegistry.Context;
+  private _ready = new PromiseDelegate<void>();
+}
+
+/**
  * A widget for editors.
  */
 export class FileEditor extends Widget {
@@ -42,27 +146,15 @@
     const context = (this._context = options.context);
     this._mimeTypeService = options.mimeTypeService;
 
-    const editorWidget = (this._editorWidget = new CodeEditorWrapper({
-      factory: options.factory,
-      model: context.model,
-      editorOptions: {
-        config: FileEditor.defaultEditorConfig
-      }
-    }));
-    this._editorWidget.addClass('jp-FileEditorCodeWrapper');
-    this._editorWidget.node.dataset[CODE_RUNNER] = 'true';
-    this._editorWidget.node.dataset[UNDOER] = 'true';
-
+    const editorWidget = (this.editorWidget = new FileEditorCodeWrapper(
+      options
+    ));
     this.editor = editorWidget.editor;
     this.model = editorWidget.model;
 
-    void context.ready.then(() => {
-      this._onContextReady();
-    });
-
     // Listen for changes to the path.
+    context.pathChanged.connect(this._onPathChanged, this);
     this._onPathChanged();
-    context.pathChanged.connect(this._onPathChanged, this);
 
     const layout = (this.layout = new StackedLayout());
     layout.addWidget(editorWidget);
@@ -72,14 +164,14 @@
    * Get the context for the editor widget.
    */
   get context(): DocumentRegistry.Context {
-    return this._context;
+    return this.editorWidget.context;
   }
 
   /**
    * A promise that resolves when the file editor is ready.
    */
   get ready(): Promise<void> {
-    return this._ready.promise;
+    return this.editorWidget.ready;
   }
 
   /**
@@ -139,36 +231,22 @@
   }
 
   /**
-   * Handle actions that should be taken when the context is ready.
-   */
-  private _onContextReady(): void {
-    if (this.isDisposed) {
-      return;
-    }
-
-    // Prevent the initial loading from disk from being in the editor history.
-    this.editor.clearHistory();
-    // Resolve the ready promise.
-    this._ready.resolve(undefined);
-  }
-
-  /**
    * Handle a change to the path.
    */
   private _onPathChanged(): void {
     const editor = this.editor;
     const localPath = this._context.localPath;
 
-    editor.model.mimeType =
-      this._mimeTypeService.getMimeTypeByFilePath(localPath);
-  }
-
-  model: CodeEditor.IModel;
-  editor: CodeEditor.IEditor;
-  private _context: DocumentRegistry.Context;
-  private _editorWidget: CodeEditorWrapper;
+    editor.model.mimeType = this._mimeTypeService.getMimeTypeByFilePath(
+      localPath
+    );
+  }
+
+  private editorWidget: FileEditorCodeWrapper;
+  public model: CodeEditor.IModel;
+  public editor: CodeEditor.IEditor;
+  protected _context: DocumentRegistry.Context;
   private _mimeTypeService: IEditorMimeTypeService;
-  private _ready = new PromiseDelegate<void>();
 }
 
 /**
@@ -193,51 +271,6 @@
      * The document context associated with the editor.
      */
     context: DocumentRegistry.CodeContext;
-  }
-
-  /**
-   * File editor default configuration.
-   */
-  export const defaultEditorConfig: Record<string, any> = {
-    lineNumbers: true,
-    scrollPastEnd: true
-  };
-}
-
-/**
- * A document widget for file editor widgets.
- */
-export class FileEditorWidget extends DocumentWidget<FileEditor> {
-  /**
-   * Set URI fragment identifier for text files
-   */
-  async setFragment(fragment: string): Promise<void> {
-    const parsedFragments = fragment.split('=');
-
-    // TODO: expand to allow more schemes of Fragment Identification Syntax
-    // reference: https://datatracker.ietf.org/doc/html/rfc5147#section-3
-    if (parsedFragments[0] !== '#line') {
-      return;
-    }
-
-    const positionOrRange = parsedFragments[1];
-    let firstLine: string;
-    if (positionOrRange.includes(',')) {
-      // Only respect range start for now.
-      firstLine = positionOrRange.split(',')[0] || '0';
-    } else {
-      firstLine = positionOrRange;
-    }
-
-    // Reveal the line
-    return this.context.ready.then(() => {
-      const position = {
-        line: parseInt(firstLine, 10),
-        column: 0
-      };
-      this.content.editor.setCursorPosition(position);
-      this.content.editor.revealPosition(position);
-    });
   }
 }
 
@@ -264,7 +297,6 @@
   ): IDocumentWidget<FileEditor> {
     const func = this._services.factoryService.newDocumentEditor;
     const factory: CodeEditor.Factory = options => {
-      // Use same id as document factory
       return func(options);
     };
     const content = new FileEditor({
@@ -274,7 +306,7 @@
     });
 
     content.title.icon = textEditorIcon;
-    const widget = new FileEditorWidget({ content, context });
+    const widget = new DocumentWidget({ content, context });
     return widget;
   }
 