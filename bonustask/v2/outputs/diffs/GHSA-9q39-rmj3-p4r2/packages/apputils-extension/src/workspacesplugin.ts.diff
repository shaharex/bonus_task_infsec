--- packages\apputils-extension\src\workspacesplugin.ts (old)
+++ packages\apputils-extension\src\workspacesplugin.ts (new)
@@ -6,6 +6,7 @@
   JupyterFrontEnd,
   JupyterFrontEndPlugin
 } from '@jupyterlab/application';
+import { Dialog, IWindowResolver, showDialog } from '@jupyterlab/apputils';
 import { URLExt } from '@jupyterlab/coreutils';
 import {
   ABCWidgetFactory,
@@ -13,11 +14,21 @@
   DocumentWidget,
   IDocumentWidget
 } from '@jupyterlab/docregistry';
-import { Workspace, WorkspaceManager } from '@jupyterlab/services';
+import { FileBrowser, IFileBrowserFactory } from '@jupyterlab/filebrowser';
+import {
+  ContentsManager,
+  Workspace,
+  WorkspaceManager
+} from '@jupyterlab/services';
 import { IStateDB } from '@jupyterlab/statedb';
-import { IWorkspaceCommands } from '@jupyterlab/workspaces';
 import { ITranslator, nullTranslator } from '@jupyterlab/translation';
 import { Widget } from '@lumino/widgets';
+
+namespace CommandIDs {
+  export const saveWorkspace = 'workspace-ui:save';
+
+  export const saveWorkspaceAs = 'workspace-ui:save-as';
+}
 
 const WORKSPACE_NAME = 'jupyterlab-workspace';
 const WORKSPACE_EXT = '.' + WORKSPACE_NAME;
@@ -25,43 +36,35 @@
 const ICON_NAME = 'jp-JupyterIcon';
 
 /**
- * The workspace MIME renderer.
+ * The workspace MIME renderer and save plugin.
  */
 export const workspacesPlugin: JupyterFrontEndPlugin<void> = {
   id: '@jupyterlab/apputils-extension:workspaces',
-  description: 'Add workspace file type.',
   autoStart: true,
-  requires: [IStateDB, ITranslator, JupyterFrontEnd.IPaths],
-  optional: [IRouter, IWorkspaceCommands],
+  requires: [
+    IFileBrowserFactory,
+    IWindowResolver,
+    IStateDB,
+    ITranslator,
+    JupyterFrontEnd.IPaths
+  ],
+  optional: [IRouter],
   activate: (
     app: JupyterFrontEnd,
+    fbf: IFileBrowserFactory,
+    resolver: IWindowResolver,
     state: IStateDB,
     translator: ITranslator,
     paths: JupyterFrontEnd.IPaths,
-    router: IRouter | null,
-    workspaceCommands: IWorkspaceCommands | null
+    router: IRouter | null
   ): void => {
     // The workspace factory creates dummy widgets to load a new workspace.
     const factory = new Private.WorkspaceFactory({
       workspaces: app.serviceManager.workspaces,
+      router,
       state,
       translator,
-      open: async (id: string) => {
-        if (workspaceCommands) {
-          await app.commands.execute(workspaceCommands.open, { workspace: id });
-        } else {
-          const workspacesBase = URLExt.join(paths.urls.app, 'workspaces');
-          const url = URLExt.join(workspacesBase, id);
-          if (!url.startsWith(workspacesBase)) {
-            throw new Error('Can only be used for workspaces');
-          }
-          if (router) {
-            router.navigate(url, { hard: true });
-          } else {
-            document.location.href = url;
-          }
-        }
-      }
+      paths
     });
     const trans = translator.load('jupyterlab');
 
@@ -69,16 +72,108 @@
       name: WORKSPACE_NAME,
       contentType: 'file',
       fileFormat: 'text',
-      displayName: trans.__('JupyterLab Workspace File'),
+      displayName: trans.__('JupyterLab workspace File'),
       extensions: [WORKSPACE_EXT],
       mimeTypes: ['text/json'],
       iconClass: ICON_NAME
     });
     app.docRegistry.addWidgetFactory(factory);
+    app.commands.addCommand(CommandIDs.saveWorkspaceAs, {
+      label: trans.__('Save Current Workspace As…'),
+      execute: async () => {
+        const data = app.serviceManager.workspaces.fetch(resolver.name);
+        await Private.saveAs(
+          fbf.defaultBrowser,
+          app.serviceManager.contents,
+          data,
+          state,
+          translator
+        );
+      }
+    });
+
+    app.commands.addCommand(CommandIDs.saveWorkspace, {
+      label: trans.__('Save Current Workspace'),
+      execute: async () => {
+        const { contents } = app.serviceManager;
+        const data = app.serviceManager.workspaces.fetch(resolver.name);
+        const lastSave = (await state.fetch(LAST_SAVE_ID)) as string;
+        if (lastSave === undefined) {
+          await Private.saveAs(
+            fbf.defaultBrowser,
+            contents,
+            data,
+            state,
+            translator
+          );
+        } else {
+          await Private.save(lastSave, contents, data, state);
+        }
+      }
+    });
   }
 };
 
 namespace Private {
+  /**
+   * Save workspace to a user provided location
+   */
+  export async function save(
+    userPath: string,
+    contents: ContentsManager,
+    data: Promise<Workspace.IWorkspace>,
+    state: IStateDB
+  ): Promise<void> {
+    let name = userPath.split('/').pop();
+
+    // Add extension if not provided or remove extension from name if it was.
+    if (name !== undefined && name.includes('.')) {
+      name = name.split('.')[0];
+    } else {
+      userPath = userPath + WORKSPACE_EXT;
+    }
+
+    // Save last save location, for save button to work
+    await state.save(LAST_SAVE_ID, userPath);
+
+    const resolvedData = await data;
+    resolvedData.metadata.id = `${name}`;
+    await contents.save(userPath, {
+      type: 'file',
+      format: 'text',
+      content: JSON.stringify(resolvedData)
+    });
+  }
+
+  /**
+   * Ask user for location, and save workspace.
+   * Default location is the current directory in the file browser
+   */
+  export async function saveAs(
+    browser: FileBrowser,
+    contents: ContentsManager,
+    data: Promise<Workspace.IWorkspace>,
+    state: IStateDB,
+    translator?: ITranslator
+  ): Promise<void> {
+    translator = translator || nullTranslator;
+    const lastSave = await state.fetch(LAST_SAVE_ID);
+
+    let defaultName;
+    if (lastSave === undefined) {
+      defaultName = 'new-workspace';
+    } else {
+      defaultName = (lastSave as string).split('/').pop()?.split('.')[0];
+    }
+
+    const defaultPath = browser.model.path + '/' + defaultName + WORKSPACE_EXT;
+    const userPath = await getSavePath(defaultPath, translator);
+
+    if (userPath) {
+      await save(userPath, contents, data, state);
+    }
+  }
+
   /**
    * This widget factory is used to handle double click on workspace
    */
@@ -91,20 +186,20 @@
     constructor(options: WorkspaceFactory.IOptions) {
       const trans = (options.translator || nullTranslator).load('jupyterlab');
       super({
-        name: 'Workspace loader',
-        label: trans.__('Workspace loader'),
+        name: trans.__('Workspace loader'),
         fileTypes: [WORKSPACE_NAME],
         defaultFor: [WORKSPACE_NAME],
         readOnly: true
       });
+      this._application = options.paths.urls.app;
+      this._router = options.router;
       this._state = options.state;
       this._workspaces = options.workspaces;
-      this._open = options.open;
     }
 
     /**
      * Loads the workspace into load, and jump to it
-     * @param context This is used to query the workspace content
+     * @param context This is used queried to query the workspace content
      */
     protected createNewWidget(
       context: DocumentRegistry.Context
@@ -112,9 +207,8 @@
       // Save a file's contents as a workspace and navigate to that workspace.
       void context.ready.then(async () => {
         const file = context.model;
-        const workspace = file.toJSON() as unknown as Workspace.IWorkspace;
+        const workspace = (file.toJSON() as unknown) as Workspace.IWorkspace;
         const path = context.path;
-
         const id = workspace.metadata.id;
 
         // Save the file contents as a workspace.
@@ -124,12 +218,22 @@
         await this._state.save(LAST_SAVE_ID, path);
 
         // Navigate to new workspace.
-        await this._open(id);
+        const workspacesBase = URLExt.join(this._application, 'workspaces');
+        const url = URLExt.join(workspacesBase, id);
+        if (!url.startsWith(workspacesBase)) {
+          throw new Error('Can only be used for workspaces');
+        }
+        if (this._router) {
+          this._router.navigate(url, { hard: true });
+        } else {
+          document.location.href = url;
+        }
       });
       return dummyWidget(context);
     }
 
-    private _open: (id: string) => Promise<void>;
+    private _application: string;
+    private _router: IRouter | null;
     private _state: IStateDB;
     private _workspaces: WorkspaceManager;
   }
@@ -142,10 +246,11 @@
      * Instantiation options for a `WorkspaceFactory`
      */
     export interface IOptions {
+      paths: JupyterFrontEnd.IPaths;
+      router: IRouter | null;
       state: IStateDB;
       translator: ITranslator;
       workspaces: WorkspaceManager;
-      open: (id: string) => Promise<void>;
     }
   }
 
@@ -159,4 +264,56 @@
     widget.content.dispose();
     return widget;
   }
+
+  /**
+   * Ask user for a path to save to.
+   * @param defaultPath Path already present when the dialog is shown
+   */
+  async function getSavePath(
+    defaultPath: string,
+    translator?: ITranslator
+  ): Promise<string | null> {
+    translator = translator || nullTranslator;
+    const trans = translator.load('jupyterlab');
+    const saveBtn = Dialog.okButton({ label: trans.__('Save') });
+    const result = await showDialog({
+      title: trans.__('Save Current Workspace As…'),
+      body: new SaveWidget(defaultPath),
+      buttons: [Dialog.cancelButton({ label: trans.__('Cancel') }), saveBtn]
+    });
+    if (result.button.label === trans.__('Save')) {
+      return result.value;
+    } else {
+      return null;
+    }
+  }
+
+  /**
+   * A widget that gets a file path from a user.
+   */
+  class SaveWidget extends Widget {
+    /**
+     * Gets a modal node for getting save location. Will have a default to the current opened directory
+     * @param path Default location
+     */
+    constructor(path: string) {
+      super({ node: createSaveNode(path) });
+    }
+
+    /**
+     * Gets the save path entered by the user
+     */
+    getValue(): string {
+      return (this.node as HTMLInputElement).value;
+    }
+  }
+
+  /**
+   * Create the node for a save widget.
+   */
+  function createSaveNode(path: string): HTMLElement {
+    const input = document.createElement('input');
+    input.value = path;
+    return input;
+  }
 }